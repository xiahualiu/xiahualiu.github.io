<?xml version="1.0" encoding="utf-8" ?>
<?xml-stylesheet type="text/xsl" href="https://xiahualiu.github.io/xml/base.min.xml" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xiahua</title>
    <link>https://xiahualiu.github.io/</link>
    <description>Recent content on Xiahua</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 30 Jan 2020 20:17:54 -0500</lastBuildDate>
    <atom:link href="https://xiahualiu.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Matrix Calculus</title>
      <link>https://xiahualiu.github.io/posts/2020-01-30-matrix-multiplication/</link>
      <pubDate>Thu, 30 Jan 2020 20:17:54 -0500</pubDate>
      <guid>https://xiahualiu.github.io/posts/2020-01-30-matrix-multiplication/</guid>
      <description>&lt;p&gt;Matrix calculus is very important in machine learning and control theories. However there are all kinds of rules making it hard to remember and use. In this post, I summarize some basic rules and an important proof in machine learning theory, which includes the famous &amp;quot;Trace Trick&amp;quot;! This trick is super useful and super hard as well! Haha, this is the reason why we always explore new things, because it is hard!&lt;/p&gt;

&lt;h2 id=&#34;differentiation&#34;&gt;Differentiation&lt;/h2&gt;

&lt;p&gt;For the rules of matrix differentiation, all we need to remember are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Gradient&lt;/li&gt;
&lt;li&gt;The Jacobian matrix&lt;/li&gt;
&lt;li&gt;The Hessian matrix&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;* All vectors in this post refer to column vectors with dimension &lt;span  class=&#34;math&#34;&gt;\(N\)&lt;/span&gt;.&lt;/p&gt;

&lt;h3 id=&#34;getting-started&#34;&gt;Getting started&lt;/h3&gt;

&lt;p&gt;To start with the concept, we differentiate a matrix with respect to a scalar variable, the result is pretty intuitive and natural:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\dot{A}=\begin{bmatrix}
\dot{A}_{11} &amp; \cdots &amp; \dot{A}_{1n} \\
\vdots &amp; \ddots &amp; \vdots \\
\dot{A}_{n1} &amp; \cdots &amp; \dot{A}_{nn} 
\end{bmatrix}\]&lt;/span&gt;&lt;/p&gt;

&lt;h3 id=&#34;gradient&#34;&gt;Gradient&lt;/h3&gt;

&lt;p&gt;The gradient of a scalar function can be visualized as the changes in different directions.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\nabla f(\textbf{x})=\begin{bmatrix}
\frac{\partial f}{\partial x_1} \\
\frac{\partial f}{\partial x_2} \\
\vdots \\
\frac{\partial f}{\partial x_n} \\
\end{bmatrix}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;It is the most simplifed case, remember it returns a vector that&#39;s in the same shape as the input vector variable.&lt;/p&gt;

&lt;h3 id=&#34;jacobian-matrix&#34;&gt;Jacobian Matrix&lt;/h3&gt;

&lt;p&gt;Jacobian matrix is the first-order derivative of a &lt;strong&gt;vector function&lt;/strong&gt;, a vector function is a function that &lt;strong&gt;receives a vector value and returns a vector value&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Jacobian matrix is obtained from &lt;span  class=&#34;math&#34;&gt;\((\nabla \textbf{f})^{\top}\)&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[(\nabla \textbf{f})^{\top}=[\frac{\partial \textbf{f}}{\partial x_1} \cdots \frac{\partial \textbf{f}}{\partial x_n}]=\begin{bmatrix}
\frac{\partial f_1}{\partial x_1}  &amp; \cdots &amp; \frac{\partial f_1}{\partial x_n} \\
\vdots &amp; \ddots &amp; \vdots \\
\frac{\partial f_n}{\partial x_1} &amp; \cdots &amp; \frac{\partial f_n}{\partial x_n}
\end{bmatrix}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;We did gradient operation at first, transposed the result, then applied the simple first derivative expansion as discussed in the warm up section.&lt;/p&gt;

&lt;h2 id=&#34;hessian-matrix&#34;&gt;Hessian Matrix&lt;/h2&gt;

&lt;p&gt;Hessian matrix is the second-order partial derivatives of a &lt;strong&gt;scalar-valued&lt;/strong&gt; function. A scalar-valued function is a function that &lt;strong&gt;receives a scalar or vector and returns a scalar&lt;/strong&gt;. Here we assume it the function receives a vector.&lt;/p&gt;

&lt;p&gt;Since it is a scalar function, first we find the gradient:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\frac{\partial y}{\partial \textbf{x}}=\begin{bmatrix} \frac{\partial y}{\partial x_1} \\
\vdots \\
\frac{\partial y}{\partial x_n} \\
\end{bmatrix}=\nabla \textbf{f}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;And we need to do this one more time.A sharp eye reader may notice the second derivative is the Jacobian matrix of the gradient, which is:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\textbf{J}(\nabla \textbf{f})\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;However, &lt;strong&gt;Hessian matrix is defined with an extra tranpose operation&lt;/strong&gt;, so it is actually:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\textbf{J}(\nabla \textbf{f})^{\top}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\mathbf{H}=\left[\begin{array}{cccc}
{\frac{\partial^{2} f}{\partial x_{1}^{2}}} &amp; {\frac{\partial^{2} f}{\partial x_{1} \partial x_{2}}} &amp; {\cdots} &amp; {\frac{\partial^{2} f}{\partial x_{1} \partial x_{n}}} \\
{\frac{\partial^{2} f}{\partial x_{2} \partial x_{1}}} &amp; {\frac{\partial^{2} f}{\partial x_{2}^{2}}} &amp; {\cdots} &amp; {\frac{\partial^{2} f}{\partial x_{2} \partial x_{n}}} \\
{\vdots} &amp; {\vdots} &amp; {\ddots} &amp; {\vdots} \\
{\frac{\partial^{2} f}{\partial x_{n} \partial x_{1}}} &amp; {\frac{\partial^{2} f}{\partial x_{n} \partial x_{2}}} &amp; {\cdots} &amp; {\frac{\partial^{2} f}{\partial x_{n}^{2}}}
\end{array}\right]\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Till now I hope you can understand what Jacobian matrix and Hessian matrix are, and be able to write the steps how we get Jacobian and Hessian matrix.&lt;/p&gt;

&lt;h2 id=&#34;integral&#34;&gt;Integral&lt;/h2&gt;

&lt;p&gt;Calculating the integral of the whole matrix is as simple as the warm up part.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\int A(t) {\rm d}t=\begin{bmatrix}
\int A_{11}{\rm d}t &amp; \cdots &amp; \int A_{1n}(t){\rm d}t \\
\vdots &amp; \ddots &amp; \vdots \\
\int A_{n1}(t){\rm d}t &amp; \cdots &amp; \int A_{nn}(t){\rm d}t
\end{bmatrix}\]&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&#34;trace-trick&#34;&gt;Trace trick&lt;/h2&gt;

&lt;p&gt;In this section, we will teach you what trace trick is. As usual, we start with a simple case:&lt;/p&gt;

&lt;h3 id=&#34;derivative-of-a-quadratic-form&#34;&gt;Derivative of a quadratic form&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;If you have no idea what a quadratic form is, I suggest you stop reading downwards&lt;/strong&gt;, because you have to have a good understanding of it, otherwise you cannot realize why we want to find its derivative.&lt;/p&gt;

&lt;p&gt;I also suggest a wonderful book for that foundation, &lt;em&gt;Linear Algebra and its Applications&lt;/em&gt;, this is a must-read for all new learners.&lt;/p&gt;

&lt;p&gt;So here we begin!&lt;/p&gt;

&lt;p&gt;Define a function:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[f(\textbf{x})=\textbf{x}^{\top}\textbf{Ax}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;This is a scalar function, since &lt;span  class=&#34;math&#34;&gt;\(\textbf{x}\)&lt;/span&gt; is &lt;span  class=&#34;math&#34;&gt;\(m\times 1\)&lt;/span&gt;. So the size of the output is:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[(1\times m)\times(m\times m)\times(m\times 1)=(1\times 1)\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;And we need to find its first derivative w.r.t &lt;span  class=&#34;math&#34;&gt;\(\textbf{x}\)&lt;/span&gt;. How?&lt;/p&gt;

&lt;p&gt;You may think, it is same as finding the gradient of the function, so just expand the equation and find the partial derivative.&lt;/p&gt;

&lt;p&gt;Yes, it is indeed a reasonal idea, but expanding all the terms is way to tedious and humans are fallible. Is there any other way to obtain the result without messing the matrix?&lt;/p&gt;

&lt;p&gt;Yes, there is. It is called &lt;strong&gt;&amp;quot;Trace Trick&amp;quot;&lt;/strong&gt; and is widely used in finding the derivative of quadratic form function.&lt;/p&gt;

&lt;h3 id=&#34;trace&#34;&gt;Trace&lt;/h3&gt;

&lt;p&gt;From wikipedia:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;In linear algebra, the trace of a square matrix &lt;span  class=&#34;math&#34;&gt;\(A\)&lt;/span&gt; is defined to be the sum of elements on the main diagonal of &lt;span  class=&#34;math&#34;&gt;\(A\)&lt;/span&gt;. The trace of a matrix is the sum of its eigenvalues, and it is invariant with respect to a change of basis.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;trace-laws&#34;&gt;Trace laws&lt;/h3&gt;

&lt;p&gt;Here are two most important laws:&lt;/p&gt;

&lt;h4 id=&#34;transpose-law&#34;&gt;Transpose law&lt;/h4&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\operatorname{tr}(\mathbf{A})=\operatorname{tr}\left(\mathbf{A}^{\top}\right)\]&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;cyclic-permutation-law&#34;&gt;Cyclic permutation law&lt;/h4&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\operatorname{tr}(\mathbf{A B C D})=\operatorname{tr}(\mathbf{B C D A})=\operatorname{tr}(\mathbf{C D A B})=\operatorname{tr}(\mathbf{D A B C})\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;How do we apply the trace trick in our calculation? Well, from the definition of the trace, a trace of a scalar (which can be considered as a &lt;span  class=&#34;math&#34;&gt;\(1\times 1\)&lt;/span&gt; matrix) is itself, so:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\operatorname{tr}(\textbf{x}^{\top}\textbf{Ax})=\textbf{x}^{\top}\textbf{Ax}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Now it is the trick time, I will write everything here, please read the following equation, and try to understand how I get to the final line:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\begin{aligned}
{\rm d}(\textbf{x}^{\top}\textbf{Ax}) &amp;={\rm d}(\operatorname{tr}(\textbf{x}^{\top}\textbf{Ax})) \\
&amp;=\operatorname{tr}({\rm d}(\textbf{Ax}\textbf{x}^{\top})) \\
&amp;=\operatorname{tr}({\rm d}(\textbf{Ax})\textbf{x}^{\top}+{\bf Ax}{\rm d}(\textbf{x}^{\top})) \\
&amp;=\operatorname{tr}({\rm d}(\textbf{Ax})\textbf{x}^{\top})+\operatorname{tr}({\bf Ax}{\rm d}(\textbf{x}^{\top})) \\
&amp;=\operatorname{tr}(\textbf{A}({\rm d}\textbf{x})\textbf{x}^{\top})+\operatorname{tr}\left((({\rm d}\textbf{x})\textbf{x}^{\top} \textbf{A}^{\top})^{\top}\right) \\
&amp;=\operatorname{tr}((\textbf{x}^{\top}\textbf{A}({\rm d}\textbf{x})) + \operatorname{tr}(\textbf{x}^{\top}\textbf{A}^{\top}({\rm d}\textbf{x})) \\
&amp;=\operatorname{tr}(\textbf{x}^{\top}\textbf{A}){\rm d}\textbf{x} + \operatorname{tr}(\textbf{x}^{\top}\textbf{A}^{\top}){\rm d}\textbf{x} \\
&amp;=\operatorname{tr}\left((\textbf{x}^{\top}\textbf{A}+\textbf{x}^{\top}\textbf{A}^{\top}){\rm d}\textbf{x}\right) \\
&amp;=(\textbf{x}^{\top}\textbf{A}+\textbf{x}^{\top}\textbf{A}^{\top}){\rm d}\textbf{x}
\end{aligned}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;I used cyclic permutation law at beginning and at the end twice, and used transpose law only once to transform &lt;span  class=&#34;math&#34;&gt;\({\rm d}\textbf{x}^{\top}\)&lt;/span&gt;. I installed trace function on first line and uninstall the trace function on the last line, &lt;span  class=&#34;math&#34;&gt;\({\rm d}\textbf{x}=\lim(\textbf{x}_1-\textbf{x}_2)\in \Bbb{R}^{N}\)&lt;/span&gt;, it can be proved that the expression on final line is still a scalar.&lt;/p&gt;

&lt;p&gt;And we can get the result &lt;span  class=&#34;math&#34;&gt;\(\textbf{x}^{\top}\textbf{A}+\textbf{x}^{\top}\textbf{A}^{\top}\)&lt;/span&gt; simply in several steps!&lt;/p&gt;

&lt;h4 id=&#34;another-important-law&#34;&gt;Another Important Law&lt;/h4&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\frac{\partial}{\partial A}\operatorname{tr}(AB)=B^{\top}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;This law will be used once in the next section.&lt;/p&gt;

&lt;h2 id=&#34;multivariate-guassian-distribution-maximum-likelihood-estimate&#34;&gt;Multivariate Guassian Distribution Maximum Likelihood Estimate&lt;/h2&gt;

&lt;p&gt;In the end, I want to show you how to calculate the MLE for a multivariate guassian distribution model with all the stuff discussed in this post, I really hope you can enjoy it as much as I do!&lt;/p&gt;

&lt;h4 id=&#34;problem&#34;&gt;Problem:&lt;/h4&gt;

&lt;p&gt;Given &lt;span  class=&#34;math&#34;&gt;\(N\)&lt;/span&gt; samples &lt;span  class=&#34;math&#34;&gt;\(\{X_1,X_2,X_3,...,X_i\}\)&lt;/span&gt; are drawn from a p-variate multivariate guassian distribution model i.i.d:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[p(x | \mu, \Sigma)=\frac{1}{(2 \pi)^{p / 2}|\Sigma|^{1 / 2}} \exp \left\{-\frac{1}{2}(x-\mu)^{T} \Sigma^{-1}(x-\mu)\right\}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Find the MLE for &lt;span  class=&#34;math&#34;&gt;\(\mu\ \Sigma\)&lt;/span&gt;.&lt;/p&gt;

&lt;h4 id=&#34;solution&#34;&gt;Solution:&lt;/h4&gt;

&lt;p&gt;Define the likelihood function &lt;span  class=&#34;math&#34;&gt;\(L\)&lt;/span&gt;:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[f(\mu, \Sigma)=\frac{1}{(2\pi)^{\frac{pN}{2}}|\Sigma|^{\frac{N}{2}}}\exp{\left\{\sum_{i=1}^{N}-\frac{1}{2}(X_i-\mu)^{\top}\Sigma^{-1}(X_i-\mu)\right\}}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;In order to simplify the problem, plus due to the fact that the multivariate guassian distribution belongs to the exponential distribution family. Instead straight differentiating the likelihood function, it is better to calculate the logarithmic differentiation of the function.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[L(\mu, \Sigma)=\ln f(\mu, \Sigma)=\sum_{i=1}^{N}-\frac{1}{2}(X_i-\mu)^{\top}\Sigma^{-1}(X_i-\mu)-\frac{pN}{2}\ln 2\pi - \frac{N}{2}\ln|\Sigma|\]&lt;/span&gt;&lt;/p&gt;

&lt;h5 id=&#34;find-the-mle-for-the-the-mean&#34;&gt;Find the MLE for the the mean&lt;/h5&gt;

&lt;p&gt;Find &lt;span  class=&#34;math&#34;&gt;\(\mu\)&lt;/span&gt; first, then &lt;span  class=&#34;math&#34;&gt;\(\Sigma\)&lt;/span&gt;, calculate the first-order partial derivative of &lt;span  class=&#34;math&#34;&gt;\(L(\mu, \Sigma)\)&lt;/span&gt; w.r.t &lt;span  class=&#34;math&#34;&gt;\(\mu\)&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\frac{\partial L(\mu, \Sigma)}{\partial \mu} = \sum_{i=1}^n - \partial \frac{1}{2}(X_i-\mu)^{\top}\Sigma^{-1}(X_i-\mu) /\partial \mu \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;And if we regard &lt;span  class=&#34;math&#34;&gt;\((X_i-\mu)\)&lt;/span&gt; as &lt;span  class=&#34;math&#34;&gt;\(\textbf{x}\)&lt;/span&gt; in the former section, the partial derivative on the right side is simply:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\frac{1}{2}\sum_{i=1}^{N} (X_i-\mu)^{\top}\Sigma^{-1}+ (X_i-\mu)^{\top}(\Sigma^{-1})^T\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Since &lt;span  class=&#34;math&#34;&gt;\(\Sigma\)&lt;/span&gt; is the covariance matrix, it is symmetric:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\begin{aligned}
\Sigma^{-1}\Sigma&amp;=(\Sigma\Sigma^{-1})^{\top} \\
\Sigma^{-1}\Sigma&amp;=(\Sigma^{-1})^{\top}\Sigma^{\top} \\
\Sigma^{-1}&amp;=(\Sigma^{-1})^{\top}
\end{aligned}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;The partial derivative w.r.t &lt;span  class=&#34;math&#34;&gt;\(\mu\)&lt;/span&gt; in the conclusion:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\frac{\partial L(\mu, \Sigma)}{\partial \mu} =\sum_{i=1}^n(X_i-\mu)^{\top}\Sigma^{-1}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Find its critical point, i.e. the mean of all samples:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\hat{\mu}=\frac{1}{N}\sum_{i=1}^{N}X_i\]&lt;/span&gt;&lt;/p&gt;

&lt;h5 id=&#34;find-the-mle-for-the-covariance-matrix&#34;&gt;Find the MLE for the covariance matrix&lt;/h5&gt;

&lt;p&gt;Since we get &lt;span  class=&#34;math&#34;&gt;\(\hat{\mu}\)&lt;/span&gt;, and apparently the &lt;span  class=&#34;math&#34;&gt;\(\mu\)&lt;/span&gt; estimate does not rely on &lt;span  class=&#34;math&#34;&gt;\(\Sigma\)&lt;/span&gt;, these two parameters are independent. We can safely substitute all &lt;span  class=&#34;math&#34;&gt;\(\mu\)&lt;/span&gt; with &lt;span  class=&#34;math&#34;&gt;\(\hat{\mu}\)&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\begin{aligned}
\frac{\partial L(\hat{\mu}, \Sigma)}{\partial \Sigma^{-1}}&amp;=\partial\left(-\frac{N}{2}\ln|\Sigma|\right)/\partial\Sigma^{-1}-\frac{1}{2}\sum_{i=1}^{N}(X_i-\hat{\mu})(X_i-\hat{\mu})^{\top} \\
&amp;=\partial (\frac{N}{2}\ln|\Sigma^{-1}|)/\partial \Sigma^{-1} -\frac{1}{2}\sum_{i=1}^{N}(X_i-\hat{\mu})(X_i-\hat{\mu})^{\top} \\
&amp;=\frac{N}{2\Sigma^{-1}}-\frac{1}{2}\sum_{i=1}^{N}(X_i-\hat{\mu})(X_i-\hat{\mu})^{\top} \\
&amp;=\frac{N}{2}\Sigma-\frac{1}{2}\sum_{i=1}^{N}(X_i-\hat{\mu})(X_i-\hat{\mu})^{\top}
\end{aligned} \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;The last term on the first line was obtained by first using the cyclic permutaion then using the extra law in the former section.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\frac{1}{2} \sum_{n}\left(x_{n}-\mu\right)^{\top} \Sigma^{-1}\left(x_{n}-\mu\right)=\frac{1}{2} \sum_{i=1}^{N} \operatorname{tr}\left[\left(X_{i}-\hat{\mu}\right)\left(X_{i}-\hat{\mu}\right)^{\top} \Sigma^{-1}\right]\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Then using the extra law.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\frac{\partial}{\partial\Sigma^{-1}}(\frac{1}{2} \sum_{i=1}^{N} \operatorname{tr}\left[\left(X_{i}-\hat{\mu}\right)\left(X_{i}-\hat{\mu}\right)^{\top} \Sigma^{-1}\right])=\frac{1}{2}\sum_{i=1}^{N}(X_i-\hat{\mu})(X_i-\hat{\mu})^{\top}\]&lt;/span&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>LRTA* AND-OR ALPHA-BETA algorithms</title>
      <link>https://xiahualiu.github.io/posts/2020-01-11-lrta-ab/</link>
      <pubDate>Sat, 11 Jan 2020 21:59:55 -0500</pubDate>
      <guid>https://xiahualiu.github.io/posts/2020-01-11-lrta-ab/</guid>
      <description>&lt;p&gt;In this post, I will write down my understanding of these three algorithms, which are intended to solve:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Unknown but fully observable environment: LRTA*&lt;/li&gt;
&lt;li&gt;Known but non-deterministic environment: AND-OR Tree Search&lt;/li&gt;
&lt;li&gt;Classical two-player adversary game: ALPHA-BETA Tree Search&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The reason I put AND-OR and ALPHA-BETA Tree searches together is I think they are quite similiar, one is agent versus environment, one is agent versus another optimal agent.&lt;/p&gt;
&lt;p&gt;The reason I skipped genetic algorithm is that it is just a concept, and contains too many sub algorithms that follow the same evolutionary concept. I wrote a program using GA solving TSP problem, &lt;a href=&#34;https://github.com/xiahualiu/TSP_example&#34;&gt;TSP example&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;learning-real-time-a&#34;&gt;Learning Real Time A*&lt;/h2&gt;
&lt;p&gt;LRTA* is a simple implement of a online search agent. It is suitable for an unknown environment and the environment is safe to explore.&lt;/p&gt;
&lt;p&gt;The LRTA* algorithm is just like the value iteration algorithm of MDP, but the difference is in value iteration algorithm, the environment is known, we initialize the utility randomly with a random value linked to any state.&lt;/p&gt;
&lt;p&gt;But LRTA* is able to solve the unknown environment, we cannot assign a value at first, instead, the agent can only get access to the states where it has been in. So LRTA* use a &lt;code&gt;result&lt;/code&gt; to store transitions, and a &lt;code&gt;H&lt;/code&gt; to store the value of the explored states.&lt;/p&gt;
&lt;p&gt;And there is a problem which cannot be overcome by any type of algorithms, i.e. asserting the optimality of the solution, since we can only explored limited state space, so there is not guarantee that there is no better solution than the one we found.&lt;/p&gt;
&lt;h2 id=&#34;and-or-search&#34;&gt;AND-OR Search&lt;/h2&gt;
&lt;p&gt;AND-OR search include two functions that calling each other. It is an interesting idea.&lt;/p&gt;
&lt;p&gt;AND nodes can be regarded as an unstable transition model, which leads to different next states. AND-OR search is a DFS search, every path will end in a failure (loop or dead) or goal.&lt;/p&gt;
&lt;p&gt;OR nodes is the agent choice node, agent choose what to do in OR nodes. If the OR node is goal, OR search return the empty plan, and the upper OR nodes will add reflexes (if state n then do x) to that plan and the plan will eventually leads the agent to the goal.&lt;/p&gt;
&lt;p&gt;In AND nodes, the nodes return &amp;ldquo;switch&amp;rdquo; plans, so not matter what the environment outcome is, the plan is consistent for an agent. However this switch may have a failure case.&lt;/p&gt;
&lt;p&gt;It is a little tricky the fact that AND-OR search only need to find one goal, because OR searches exhausts all outcomes of an action, and AND searches are the choices of an agent, so if we only need a solution which can be not optimal, we just need find one possible plan.&lt;/p&gt;
&lt;h2 id=&#34;alpha-beta-pruningsearch&#34;&gt;ALPHA-BETA Pruning/Search&lt;/h2&gt;
&lt;p&gt;Alpha-Beta search is actually a smarter version of minimax search. Every path maintains a value bound (alpha and beta) that some bad branches will not be considered and explored if they are in the bound.&lt;/p&gt;
&lt;p&gt;Values need to be backed-up along the path. So every node on the path shares the same bound.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Searching Methods - AI: A Modern Approach Notes</title>
      <link>https://xiahualiu.github.io/posts/2020-01-07-searching/</link>
      <pubDate>Tue, 07 Jan 2020 13:02:01 -0500</pubDate>
      <guid>https://xiahualiu.github.io/posts/2020-01-07-searching/</guid>
      <description>&lt;h2 id=&#34;abstract&#34;&gt;Abstract&lt;/h2&gt;
&lt;p&gt;This article is my personal version summary of the famous book, Artificial Intelligence: A Modern Approach Chapter 3.&lt;/p&gt;
&lt;h2 id=&#34;tree-search-and-graph-search&#34;&gt;Tree Search and Graph Search&lt;/h2&gt;
&lt;p&gt;Tree search expands all child nodes and adds them into frontier even some of them have been visited.&lt;/p&gt;
&lt;p&gt;Graph search maintains a explored list where stores all visited nodes, it only adds unexplored nodes into frontier.&lt;/p&gt;
&lt;h2 id=&#34;uninformed-search&#34;&gt;Uninformed Search&lt;/h2&gt;
&lt;p&gt;There are many types of uninformed search algorithms:&lt;/p&gt;
&lt;h3 id=&#34;step-cost-problem&#34;&gt;Step-cost Problem&lt;/h3&gt;
&lt;p&gt;This kind of problems have the same step cost, we only need to find the minimal steps from initial state to goal state.&lt;/p&gt;
&lt;h4 id=&#34;breath-first-search&#34;&gt;Breath first search:&lt;/h4&gt;
&lt;p&gt;This method uses a FIFO (first-input-first-output) queue to implement. And is not sensitive to the choice between tree search or graph search.&lt;/p&gt;
&lt;h5 id=&#34;advantage-of-bfs&#34;&gt;Advantage of BFS:&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;It can find the optimal solution naturally without generating overhead nodes.&lt;/li&gt;
&lt;li&gt;It generates the fewest nodes before finding a solution for step-cost problem.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;distadvantage-of-bfs&#34;&gt;Distadvantage of BFS:&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;It needs to store all the nodes on last layer.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;depth-first-search&#34;&gt;Depth first search:&lt;/h4&gt;
&lt;p&gt;DFS can be implement by two ways, one is using a LIFO (last input first output) stack, the other is calling &lt;code&gt;child()&lt;/code&gt; function recursively.&lt;/p&gt;
&lt;p&gt;Natural DFS under tree search (not the graph search) condition is incomplete, because the depth is infinite. The DFS itself is not an optimal algrithm.&lt;/p&gt;
&lt;h5 id=&#34;advantage-of-dfs&#34;&gt;Advantage of DFS:&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;It frees node memory once it finishs digging a branch, all the nodes on the branch can be deleted. So it can run on a memory-limited machine.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;disadvantage-of-dfs&#34;&gt;Disadvantage of DFS:&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;It generates excessive nodes compared with BFS.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;varaints-of-dfs&#34;&gt;Varaints of DFS:&lt;/h4&gt;
&lt;h5 id=&#34;backtracking-search&#34;&gt;Backtracking search&lt;/h5&gt;
&lt;p&gt;It is more memory economical. Every generated node on searching tree has a successor information on its depth, so we only need to store &lt;em&gt;m&lt;/em&gt; nodes (m equals the depth of the frontier) at any time.&lt;/p&gt;
&lt;p&gt;It is suitable when a node is super large in memory.&lt;/p&gt;
&lt;h5 id=&#34;iterative-deeping-depth-first-search&#34;&gt;Iterative deeping depth-first search&lt;/h5&gt;
&lt;p&gt;It is simply a DFS with depth limitation. After each episode of IDS, the depth limit increases by 1.&lt;/p&gt;
&lt;p&gt;Two types of return result:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;cutoff: Current episode reached depth limit.&lt;/li&gt;
&lt;li&gt;failure: Current episode ends before reaching depth limit.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;uniform-cost-problem&#34;&gt;Uniform-cost Problem&lt;/h3&gt;
&lt;p&gt;Uniform-cost problems have a postive cost for each step, however costs for different steps varys.&lt;/p&gt;
&lt;h4 id=&#34;uniform-cost-search&#34;&gt;Uniform-cost search&lt;/h4&gt;
&lt;p&gt;It is origin from the two-point shortest-path algorithm of Dijkstra.&lt;/p&gt;
&lt;p&gt;It relys on a priority queue, instead expanding randomly, it always expands the lowest path cost node on the present searching tree.&lt;/p&gt;
&lt;p&gt;Two modification:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The goal test is applied to a node when it is selected for expansion (fetched from the priority queue). This seems inefficient but it is essential. Once a node is generated, we cannot ensure that it will be pushed back to the top of priority queue, but the second time we met it, it must be the optimal solution, beacuse the path cost can only increase in uniformed cost problem case.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The second modification is similar to dynamic programming, a test is added and when we enter the same state multiple times, rather than storing all of the nodes, we only store the best node that reach this state.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bidirection-search&#34;&gt;Bidirection search&lt;/h3&gt;
&lt;p&gt;Bidirection search is based on the simple math:&lt;/p&gt;
&lt;p&gt;$$2\ast branch^{depth/2} \quad  \text{is much less than} \quad branch^{depth}$$&lt;/p&gt;
&lt;p&gt;It needs a test to check whether the frontiers of two searches intersect.&lt;/p&gt;
&lt;p&gt;But calculating the predecessors needs substantial ingenuity.&lt;/p&gt;
&lt;h2 id=&#34;informed-heuristic-search&#34;&gt;Informed (Heuristic) Search&lt;/h2&gt;
&lt;p&gt;The difference between informed and uninformed search is whether we can find a heuristic function.&lt;/p&gt;
&lt;p&gt;$$h(n)=\text{heuristic function of a node}$$&lt;/p&gt;
&lt;h3 id=&#34;greedy-best-first-search&#34;&gt;Greedy best-first search&lt;/h3&gt;
&lt;p&gt;It chooses to expand the node that is most likely to lead to a solution. In two-point shortest route finding problem, the heuristic function is the 2-norm between the current address and goal address.&lt;/p&gt;
&lt;p&gt;In this case:&lt;/p&gt;
&lt;p&gt;$$h(n)=norm(n,goal)$$&lt;/p&gt;
&lt;h3 id=&#34;a-search&#34;&gt;A* search&lt;/h3&gt;
&lt;p&gt;Unlike uniform-cost search&#39;s only considering path cost from start, and greedy best-first search&#39;s only considering heuristic function value. A* combines them both.&lt;/p&gt;
&lt;p&gt;$$f(n)=g(n)+h(n)$$&lt;/p&gt;
&lt;h4 id=&#34;variants-of-a-search&#34;&gt;Variants of A* search&lt;/h4&gt;
&lt;p&gt;The biggest problem of A* is that A* stores all the nodes before finding a optimal solution.&lt;/p&gt;
&lt;p&gt;So the variants of A* mainly optimize the memory efficiency.&lt;/p&gt;
&lt;h5 id=&#34;iterative-deepening-a-search&#34;&gt;Iterative-deepening A* search&lt;/h5&gt;
&lt;p&gt;Cutoff &lt;em&gt;f&lt;/em&gt;-cost is the smallest &lt;em&gt;f&lt;/em&gt;-cost node that exceeded the cutoff on the previous iteration.&lt;/p&gt;
&lt;p&gt;Honestly, iterative deepening search only works efficiently for BFS, algorithms like iterative-deeping depth first search or iterative-deeping depth A* search all suffer from the cost of repeating expanding upper layers in each iteration.&lt;/p&gt;
&lt;h5 id=&#34;recursive-best-first-search-rbfs&#34;&gt;Recursive best-first search (RBFS)&lt;/h5&gt;
&lt;p&gt;If a node&#39;s children all cost more than a node&#39;s peer, we can just label the node with the best children cost then delete all the decendants, then move the peer node.&lt;/p&gt;
&lt;h5 id=&#34;memory-bounded-a-ma-and-simplified-ma-sma&#34;&gt;Memory-bounded A* (MA*) and simplified MA* (SMA*)&lt;/h5&gt;
&lt;p&gt;SMA* behaves same as A* before exhausting all the memory, after no node can be added to the memory, it removes the worst node in the tree and adds new node.&lt;/p&gt;
&lt;h3 id=&#34;how-to-choose-heuristic-function&#34;&gt;How to choose heuristic function&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Generating admissible heuristics from relaxed problem.&lt;/li&gt;
&lt;li&gt;Generating admissible heuristics from subproblems.&lt;/li&gt;
&lt;li&gt;Learning heuristics from experience.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;parallel-search&#34;&gt;Parallel search&lt;/h4&gt;
&lt;p&gt;Not covered but useful for computer cluster.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>A Dynamic Programming Tuturial</title>
      <link>https://xiahualiu.github.io/posts/2019-12-23-dp/</link>
      <pubDate>Mon, 23 Dec 2019 17:59:10 -0500</pubDate>
      <guid>https://xiahualiu.github.io/posts/2019-12-23-dp/</guid>
      <description>&lt;p&gt;Well, it sounds old but for me, the true understanding of dynamic programming actually happended after I finished reading the book:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Optimal Control Theory: An Introduction by Donald E. Kirk&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;However, the book used an example that is too complicated for a beginner to understand (I think, for me it is.). So I wrote this article to help those who want to take a peek in the basics of dynamic programming, I will try my best to make it easy and you will see that dynamic programming is quite simple and intuitive.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Revised:&lt;/strong&gt; After finishing the canonical book AI: A Modern Approach, I felt I was fooled by the former book, dynamic programming is as simple as BFS or DFS.&lt;/p&gt;
&lt;h2 id=&#34;some-notations&#34;&gt;Some notations&lt;/h2&gt;
&lt;p&gt;In the rest of the article, some notations will appear more than once and I do not want to confuse any of you about the notations, what they mean.&lt;/p&gt;
&lt;p&gt;The first two is state and policy:&lt;/p&gt;
&lt;p&gt;Dynamic programming is suitable for solving problems that contain a series of decisions and states.&lt;/p&gt;
&lt;p&gt;For example, if you are a postman and today your job is to deliver some packages in an area, a common postman will stick to the same route everyday or randomly drives the van. But a clever postman like you will try to find a path that can visit all the package addresses meanwhile has the shortest distance among all viable routes.&lt;/p&gt;
&lt;p&gt;And for your information, This problem has another name, called &lt;a href=&#34;https://en.wikipedia.org/wiki/Travelling_salesman_problem&#34;&gt;Traveling Salesman Problem (TSP)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We can tear the problem into a series of decisions, i.e. which address to visit first, then, after you finish the first delivery, at the first address, you have to decide which address to visit next.&lt;/p&gt;
&lt;p&gt;So here the states here, at first glance (not right though), are the different addresses, in other words, different outcomes of your decision. And the policy is like a GPS navigation system installed on your car, it tells you what is your next decision once you reach a state (address). So if your policy is optimal, you can follow the policy and traverse these addresses and finish the given task in the shortest path (and use less gas!). So&lt;/p&gt;
&lt;p&gt;Policy:&lt;/p&gt;
&lt;p&gt;$$P(state)=action$$&lt;/p&gt;
&lt;p&gt;Policy works like a function, it accepts discrete states and outputs corresponding actions at given state.&lt;/p&gt;
&lt;p&gt;However in the postman problem discribed above, the state is not simply address because once you made a decision, the outcome is not a simply change of your location, you also have one less package to deliver, so the state in this problem also has information of the package you are carry at the certain address. If you are at Address #1, but you only carry 1 package (1 address to go), apparently the situation differs from that you carry 10 packages (10 addresses to go), the biggest difference is your action set next is not same (you have 1 choice versus 10 choices).&lt;/p&gt;
&lt;p&gt;So a state can be more complexed.&lt;/p&gt;
&lt;h2 id=&#34;principle-of-optimality&#34;&gt;Principle of Optimality&lt;/h2&gt;
&lt;p&gt;Since we have discussed state and policy, we can move on to the principle of optimality.&lt;/p&gt;
&lt;p&gt;We can tear the problem into a series of decisions and states, right? Image we start at State #1 and reach State #n, the pricinple of optimality ensure that, if the policy is optimal, and path from the beginning state (State #1) to the State #(n-1) provided by the policy is optimal. This is simple to proof, if you can find a better path from State #1 to State #(n-1), you can simply do the same last step (State #(n-1) to State #n) and get a better result!&lt;/p&gt;
&lt;p&gt;This may confuse you a little, I will show an example using the above postman problem. Imagine you have reached the Address #i and you only have no package to deliver (but you need to return to the post office). And you recall your history moves, &amp;ldquo;Did I make the right moves?&amp;quot;. Well if you can think of a better waythat can lead you into the same situation you are right now, the route you chose is definitely not optimal, becase the next move clearly makes no difference on the total distance cost.&lt;/p&gt;
&lt;p&gt;If we do the backward deduction several times (Since the path from State #1 to State #(n-1) is optimal, the path from State #1 to State #(n-2) is also optimal, and so on), then we can get a conclusion:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If you get an optimal path to finish the task, all the sub-paths from the begginning state to any states inside the path are optimal.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;You may think, while, that is easy, we only need to find the optimal path from State #1 to State #2 and the optimal path from State #1 to State #3. Then we find State #1 to State #n.&lt;/p&gt;
&lt;p&gt;Yes, that is the gist of the dynamic programming. However, the hidden difficulty in the process is, once you get the optimal path from State #1 to State #2, how do you get the optimal path from State #1 to State #3.&lt;/p&gt;
&lt;p&gt;In some simple problems, like &lt;a href=&#34;https://en.wikipedia.org/wiki/Knapsack_problem&#34;&gt;Knapsack problem&lt;/a&gt;. You can use this way to find the best result, becasue in such problems, states are heavily history related, (Forgive me for not able to think of a better description), so you can push your current state towards the ending.&lt;/p&gt;
&lt;p&gt;Some of the problems are not simple like that, you need to search for all probably states that can reach State #3 in one move and check which one is the best, (In terms, which costs least).&lt;/p&gt;
&lt;p&gt;So the forward programming process can be simply described in one formula:&lt;/p&gt;
&lt;p&gt;$$ J^\ast=\min(C_h^\ast+C_i)$$&lt;/p&gt;
&lt;p&gt;The J star is the best cost for current state, Ch star is the best history cost from beginning to the state before current state, Ci is the cost for taking action i in a given former state.&lt;/p&gt;
&lt;p&gt;If you record all Ci&#39;s, you get the optimal path one by one.&lt;/p&gt;
&lt;h2 id=&#34;how-to-implement-dp&#34;&gt;How to implement DP&lt;/h2&gt;
&lt;p&gt;Well, there are two ways to implement a dynamic programming algorithm for a problem, one is forward way, like I discribed above, and you can do it backward. For every iteration, you do not own a history when you do it backward, but you can evaluate it later, and just accumulate the action costs, until you reach the begginning state.&lt;/p&gt;
&lt;p&gt;However they do not differ very much, choose one you like or according to the problem! Because you can planning the path in any direction you like, but you have to execute the actions one by one once you finish planning!&lt;/p&gt;
&lt;h2 id=&#34;a-tsp-example&#34;&gt;A TSP Example&lt;/h2&gt;
&lt;p&gt;This example can be found at my github repository &lt;a href=&#34;https://github.com/xiahualiu/TSP_example&#34;&gt;here&lt;/a&gt;. I used 3 different ways to solve the TSP problem but you only need the DP solution.&lt;/p&gt;
&lt;p&gt;So In this example the problem is stated as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There are 4 cities on the map. Their locations are (20,20) (20,40) (40,40) (40,20) respectively and they are are X Y values in the cartesian system. Find the shortest tour among those cities, each city must be at least visited once and you cannot visit a city twice, except the city where you start off, you need to return to the begin city after visiting all cities.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In this problem, we can start at any arbitrary city because the tours are required to be closed circles as described, the optimal solution is same for every beginning choice.&lt;/p&gt;
&lt;p&gt;Imagine we chose City #1 (20,20) to begin with.&lt;/p&gt;
&lt;p&gt;The states in this problem need to carry such information:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Total Distance&lt;/strong&gt;: How far did I go? (We need to know this while making comparsion in DP iteration)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Visited City Set&lt;/strong&gt;: Unordered set of all cities I have visited. (Why this is needed was talked above)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Current City&lt;/strong&gt;: Where am I now? (We need to know this before calculating the distance increments.)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So we have the structure of the state in this problem, what we need now is &lt;strong&gt;evolving the intial state until the state reachs the final state&lt;/strong&gt;. This may sound strange to you, but you will know what I am talking about later.&lt;/p&gt;
&lt;p&gt;I used a common notaion for our state.&lt;/p&gt;
&lt;p&gt;$$g(current_city | visited_set)=total_distance$$&lt;/p&gt;
&lt;p&gt;And we did the DP forward using our hand, what we get is a tree:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2019-12-23-DP/p2.png&#34; alt=&#34;DP tree&#34;&gt;&lt;/p&gt;
&lt;p&gt;This problem is simple, we simply did a breath first searching first, and this is enough to lead us to find out all the candidates in the DP iteration formulas (Because the states are historically related so the candidates can always be found out at the former layers). How we did the DP iteration?&lt;/p&gt;
&lt;p&gt;For example, following path 1-3-4-2 and we reach the state where current location is City #2 and we have visited {4,3,2,1}. And later we find a better path 1-4-3-2 which lets us reach exactly the same state and offers a better distance cost. So we update the state and overwrite the new path to the state.&lt;/p&gt;
&lt;p&gt;Please know that this problem can be solved efficiently by BFS (not most efficiently though) does not mean every DP problems can all be solved with BFS. We can use another way to discover the candidate states, but the DP iteration process is same for any problem types.&lt;/p&gt;
&lt;h2 id=&#34;some-comments&#34;&gt;Some comments&lt;/h2&gt;
&lt;p&gt;To be honest, dynamic programming is not a very complicated method, it just systematically records all the solutions for the subproblems then increases the length to the original problem.&lt;/p&gt;
&lt;p&gt;DP essentially, we start with the smallest cases of the subproblem, becase when we find all optimal solutions to every possible subproblems, we can use the DP iteration to find optimal solutions to a bigger subproblem, then do this again and again we will reach the original problem.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Signal Processing Math - Partial Fraction Expansion Strategies</title>
      <link>https://xiahualiu.github.io/posts/2019-07-28-partial-fraction-expansion/</link>
      <pubDate>Sun, 28 Jul 2019 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2019-07-28-partial-fraction-expansion/</guid>
      <description>&lt;p&gt;Partial fraction expansion (also known as partial fraction decomposition) is a very basic math operation when we want to simplify a problem involving a fraction with polynomial numerator and denominator. We have some methods to handle the fundamental fraction terms like Laplace transform of a simple exponential signal is:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[F(s)=\frac{1}{a+s}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;And the by inverse Laplace Transform we know the signal is either &lt;span  class=&#34;math&#34;&gt;\(e^{-at}u(t)\)&lt;/span&gt; or &lt;span  class=&#34;math&#34;&gt;\(-e^{-at}u(-t)\)&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;, depending on the transform is left-sided or right-sided.&lt;/p&gt;

&lt;p&gt;But in a more complicated situation, while we are facing the transform like&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[F(s)=\frac{s+3}{s^3+7s^2+10s}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;We want to decompose the fraction into a sum of simple fractions:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[F(s)=\frac{A_1}{s}+\frac{A_2}{s+2}+\frac{A_3}{s+5}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;So we can use the basic Laplace transform pairs to get the signal. But we need a way to determine the values of&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[A_1,\ A_2 \text{ and }A_3\]&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-simple-partial-fraction-expansion&#34;&gt;A Simple Partial Fraction Expansion&lt;/h2&gt;

&lt;p&gt;The simple situation is the one shown above, there is a simple and straightforward method to determining the unknown coefficients&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[A_1,\ A_2 \text{ and }A_3\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;To find &lt;span  class=&#34;math&#34;&gt;\(A_1\)&lt;/span&gt;, multiply &lt;span  class=&#34;math&#34;&gt;\(F(s)\)&lt;/span&gt; by &lt;span  class=&#34;math&#34;&gt;\(s\)&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\begin{aligned}
sF(s)&amp;=s\frac{s+3}{s(s+2)(s+5)} \cr 
&amp;=A_1+s\frac{A_2}{s+2}+s\frac{A_3}{s+5}
\end{aligned}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;and then set &lt;span  class=&#34;math&#34;&gt;\(s=0\)&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\begin{aligned}
sF(s)|_{s=0}&amp;=A_1+0\frac{A_2}{0+2}+0\frac{A_3}{0+5}=A_1 \cr
&amp;=\frac{s+3}{s(s+5)}|_{s=0}=\frac{3}{10}
\end{aligned}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Likewise, we can get &lt;span  class=&#34;math&#34;&gt;\(A_2\)&lt;/span&gt; by setting &lt;span  class=&#34;math&#34;&gt;\(s=-2\)&lt;/span&gt;, get &lt;span  class=&#34;math&#34;&gt;\(A_3\)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;by setting &lt;span  class=&#34;math&#34;&gt;\(s=-5\)&lt;/span&gt;.&lt;/p&gt;

&lt;h2 id=&#34;special-cases-of-parial-fraction-expansion&#34;&gt;Special Cases of Parial Fraction Expansion&lt;/h2&gt;

&lt;p&gt;The simple partial fraction expansion can expand fraction into a sum of simpler fractions. However, ther are many situations where the expansion is not so simple.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Order of numerator polynomial is not less than that of the denominator.&lt;/em&gt;&lt;/strong&gt; Partial fraction expansion can only be performed when the order of the denominator polynomial (the bottom term of the fraction) is greater than the order of the numerator (the top term).  If this condition is not met, we must perform an extra step before continuing with the expansion.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;DIstinct Real Roots&lt;/em&gt;&lt;/strong&gt; The problem solved above is described as the case of distinct, real roots. This means that each term only appears once in the denominator, and the root of each term in the denominator is a distinct real number.  In the example above, the roots were at &lt;span  class=&#34;math&#34;&gt;\(0\)&lt;/span&gt;, &lt;span  class=&#34;math&#34;&gt;\(-2\)&lt;/span&gt; and &lt;span  class=&#34;math&#34;&gt;\(-5\)&lt;/span&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;Repeated Real Roots&lt;/em&gt;&lt;/strong&gt; Another possibility is a case of repeated roots. For example&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[F(s)=\frac{s+3}{s(s+2)^2(s+5)}\]&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;em&gt;Complex Roots&lt;/em&gt;&lt;/strong&gt; If the denominator cannot be reduced to a product of real roots. For example&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[F(s)=\frac{s+3}{(s+5)(s^2+4s+5)}=\frac{s+3}{(s+5)(s+2+j)(s+2-j)}\]&lt;/span&gt;&lt;/p&gt;

&lt;h4 id=&#34;order-of-numerator-polynomial-is-not-less-than-that-of-the-denominator&#34;&gt;Order of numerator polynomial is not less than that of the denominator&lt;/h4&gt;

&lt;p&gt;We can use long division to eliminate the high-order terms on the numerater.&lt;/p&gt;

&lt;h4 id=&#34;distinct-real-roots&#34;&gt;Distinct Real Roots&lt;/h4&gt;

&lt;p&gt;Like the example done above, In general&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[F(s)=\frac{A_1}{s+a_1}+\frac{A_2}{s+a_2}+\cdot\cdot\cdot+\frac{A_n}{s+a_n}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[A_i=(s+a_i)F(s)|_{s=-a_i}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;When calculation is done by hand, it is easily to use the &amp;quot;cover-up&amp;quot; method.&lt;/p&gt;

&lt;h4 id=&#34;repeated-real-roots&#34;&gt;Repeated Real Roots&lt;/h4&gt;

&lt;p&gt;For example, consider the fraction:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[F(s)=\frac{s+3}{s(s+2)^2(s+5)}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;The expansion for this case is:&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[F(s)=\frac{A_1}{s}+\frac{A_2}{s+2}+\frac{A_3}{(s+2)^2}+\frac{A_4}{s+5}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;And we can proof the simple method cannot be used since $(s+2)$ appear twice, and we can only get one value by setting &lt;span  class=&#34;math&#34;&gt;\(s=-2\)&lt;/span&gt;.&lt;/p&gt;

&lt;p&gt;There are two ways, the most favored by the texbook method uses the relationship&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[A_2=\left[\frac{d}{ds}(s+2)^2F(s)\right]_{s=-2}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;so&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[A_2=\left.\frac{s(s+5)-(s+3)(2s+5)}{(s(s+5))^2}\right|_{s=-2}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;While this method is elegant (and can be extended to multiply repeated roots), the differentiation of the ratio of polynomials is prone to errors.&lt;/p&gt;

&lt;h5 id=&#34;example-cross-multiplication&#34;&gt;Example: Cross Multiplication&lt;/h5&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[F(s)=\frac{s+3}{s(s+2)^2(s+5)}=\frac{A_1}{s}+\frac{A_2}{s+2}+\frac{A_3}{(s+2)^2}+\frac{A_4}{s+5}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[s+3=(s+2)^2(s+5)A_1+s(s+2)(s+5)A_2+s(s+5)A_3+s(s+2^2)A_4\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[s+3=(A_1+A_2+A_4)s^3+(9A_1+7A_2+A_3+4A_4)s^2+(24A_1+10A_2+5A_3+4A_4)s+20A_1 \]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;This yields a four-by-four system of equations that can be solved for A1 through A4.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\begin{aligned}
A_1+A_2+A_4&amp;=0 \cr
9A_1+7A_2+A_3+4A_4 &amp;=0 \cr
24A_1+10A_2+5A_3+4A_4&amp;=1 \cr
20A_1&amp;=3
\end{aligned}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Or, in the matrix form&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\begin{bmatrix}
{1} &amp; {1} &amp; {0} &amp; {1} \cr
{9} &amp; {7} &amp; {1} &amp; {4} \cr
{24} &amp; {10} &amp; {5} &amp; {4} \cr
{20} &amp; {0} &amp; {0} &amp; {0}
\end{bmatrix}\begin{bmatrix}
{A_{1}} \cr
{A_{2}} \cr
{A_{3}} \cr
{A_{4}}
\end{bmatrix}=\begin{bmatrix}
{0} \cr
{0} \cr
{1} \cr
{3}
\end{bmatrix}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;We can combine the cover-up method to get the coefficients that is distinct then use cross multiplication to get the coefficients that corresponds to the repeated roots.&lt;/p&gt;

&lt;h3 id=&#34;complex-roots&#34;&gt;Complex Roots&lt;/h3&gt;

&lt;p&gt;Consider the fraction&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\begin{aligned}
F(s) &amp;=\frac{s+3}{(s+5)\left(s^{2}+4 s+5\right)}=\frac{s+3}{(s+5)(s+2-j)(s+2+j)} \cr
&amp;=\frac{A_{1}}{(s+5)}+\frac{A_{2}}{(s+2-j)}+\frac{A_{3}}{(s+2+j)}
\end{aligned}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;where&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[\begin{array}{l}
{A_{1}=(s+5) F(s)|_{s=-5}} \cr
{A_{2}=(s+2-j) F(s)|_{s=-2+j}} \cr
{A_{3}=(s+2+j) F(s)|_{s=-2+j}=A_{2}^{*}}
\end{array}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Another way to expand the fraction without resorting to complex numbers is to perform the expansion as follows.&lt;/p&gt;

&lt;p&gt;&lt;span  class=&#34;math&#34;&gt;\[F(s)=\frac{s+3}{(s+5)(s^{2}+4 s+5)}=\frac{A}{s+5}+\frac{B s+C}{s^{2}+4 s+5}\]&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Note that the numerator of the second term is no longer a constant, but is instead a first order polynomial. Use cross-multiplication to get &lt;span  class=&#34;math&#34;&gt;\(A\ B\ C\)&lt;/span&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>How is Linear Feedback Shift Register(LFSR) used on Cyclic Redundancy Check(CRC)</title>
      <link>https://xiahualiu.github.io/posts/2019-04-25-lfsr-crc/</link>
      <pubDate>Fri, 26 Apr 2019 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2019-04-25-lfsr-crc/</guid>
      <description>&lt;p&gt;Nowadays, cyclic redundancy check (CRC) is widely used on various fields, including data transmission or data integraty check, e.g UART or CAN bus. For many new hardware beginning learners, CRC appears to be a complexed mathematical blackbox which produces a serial of seemingly gibberish binary numbers. But it indeed is a very reliable mechanics which extracts the feature of the data and simple to understand and implement.&lt;/p&gt;
&lt;p&gt;First I want to introduce a thing to you, that is LFSR, Linear Feedback Shift Register. LFSR circuit looks just like below:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2019-4-25-LFSR-CRC/lfsr.png&#34; alt=&#34;A 4-bit LFSR&#34;&gt;&lt;/p&gt;
&lt;p&gt;If we put D3 D2 D1 D0 in a row, we can have a 4-bit value and every time when the clock edge occurs, the value is renewed by itself with the feedback channel. If only the g0 and g4 were open, LFSR itself transforms into a normal loop shift register.&lt;/p&gt;
&lt;p&gt;The intersting part is that we can acutally define a division calculation rule to describe this iterative process. I do not really understand how it works but it simply works anyway.&lt;/p&gt;
&lt;p&gt;In the case above, if the last value was $M(x)$ and the new value is $R(x)$. We define the polynomial $M(x)=d_3x^3+d_2x^2+d_1x+d_0$ and $d_3,d_2,d_1,d_0\in{1,0}$, $G(x)=g_4x^4+g_3x^3+g_2x^2+g_1x+g_0$ The $x$ in the polynomial has no value and can be ragarded as a symbol to indicate which $d_x$ digit is. And:&lt;/p&gt;
&lt;p&gt;$$
R(x)=M(x)\mod G(x)
$$&lt;/p&gt;
&lt;p&gt;How can it be divided? Let us put hands on a simple example:&lt;/p&gt;
&lt;p&gt;If the last ${d_3,d_2,d_1,d_0}={1,1,1,1}$ and the feedback gates ${g_4,g_3,g_2,g_1,g_0}={1,1,0,0,1}$. We can get new ${d_3,d_2,d_1,d_0}={1,1,1,0}$ by writing down the signal flow on the paper, and let us use the above rule:&lt;/p&gt;
&lt;p&gt;$$
R(x)=x \times (x^3+x^2+x+1)\mod(x^4+x^3+1)
$$&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2019-4-25-LFSR-CRC/cal1.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;The rule is simple, we only use the power of $x$ to times the divider and we get a result that has at most $x^3$. The substration procedure is acutally $\oplus$ which is also named XOR. We can now use binary digits to substitute the x. &lt;strong&gt;If you have any academic interest in the algebra part, it is called &lt;em&gt;Galois Field&lt;/em&gt; and we are currently use &lt;em&gt;GF(2)&lt;/em&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Let us continue on the calculation.&lt;/p&gt;
&lt;p&gt;Now we have $x^2+x+1$, which is ${d_3,d_2,d_1,d_0}={1,1,1,0}$ and the next several states are:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2019-4-25-LFSR-CRC/cal2.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;And by doing so, we get a serial of numbers that loop in circle which length is $x^4 -1$, the only number did not show is $0000$, you can imagine that $0000$ cannot drive these gates so it will always be $0000$. That serial numbers are tested to be a 4-bit pseudo-random number. the initial value is the seed of the random numbers, so we can use LFSR to create random number sequence very easily.&lt;/p&gt;
&lt;p&gt;But also, the gate values are not used without consideration, the gate polynomial has to be a primitive polynomial which means it cannot be a result of other two polynomials. You can refer to a primitive polynomial table to do so. (Google it, of course there is no link here.)&lt;/p&gt;
&lt;p&gt;But there is a very minutely chance that the modulo is all zeroes for example we make gates ${1,0,1,0}$ and the seed is ${0,1,0,1}$. That is how we do CRC.&lt;/p&gt;
&lt;p&gt;All the calculation illustrated above, we did not have an input, this equals to we input a zero every step. Assumed we have a serial of binary data ${1,0,1,1,0,1,0,0,0,&amp;hellip;}$, the length is 1024, and we push them in a 4-bit LFSR one by one, in the end we can get a modulo shorter than 5 bits. And here comes the tricky part, by adding this modulo to the end of the data (the modulo is acutally CRC data), the data now becomes 1028 bits, and also an exact division of the gate polynomial means eventually the LFSR will output all zeroes if we input this data serial.&lt;/p&gt;
&lt;p&gt;We see that LFSR has a random feature, that means if the data is changed somewhere in the serial, only 1 in 15 chance that we can divide it with LFSR exactly, and this is because we only use 4-bit LFSR, if we use a 32-bit LFSR instead, the error chance becomes extremely little.&lt;/p&gt;
&lt;p&gt;And we can also see that LFSR consumes very little gates and works very fast, we connect it to the shifter register of the transmitter and the receiver, so CRC process can work meanwhile the data is transmitted, so it is widely used in CRC.&lt;/p&gt;</description>
    </item>
    <item>
      <title>From SICP - Understand Event Driven Programming</title>
      <link>https://xiahualiu.github.io/posts/2019-04-04-event-driven/</link>
      <pubDate>Thu, 04 Apr 2019 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2019-04-04-event-driven/</guid>
      <description>&lt;h1 id=&#34;introduction&#34;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;I am recently working on the wizard book SICP (The Structure and Interpretation of Computer Programs) that was recommended by one of my friends who study computer science. To be honest, the book is not so simple and naive as it was firstly acknowledged as the introduction book of MIT CS major. It abstracts and reveals essential programming philosophy in a easiest way, by the vehicle that known as the programming language Scheme. At first I thought scheme was a painful language for normal programmers because I only used C/C++  language that is of imperative style. However after reading the book and finishing every exercise all the way down, I gradually learned how to maneuver it and really got it on the right way.&lt;/p&gt;
&lt;p&gt;In this post I used scheme as the language to illustrate what is event-driven programming, I once worked on a project that required to implement a simple protocal stack on a chip. However at that time I did not know about the event-driven paradigm so I make the processor to process the message packaging and unpackaging in a queue. In fact it worked pretty well (queue is also used in event-driven programming), however because lack of engineering experience, the whole program turned into a really intricate complex, with so many useless parts scattered everywhere. The whole project is difficult to maintain and debug.&lt;/p&gt;
&lt;p&gt;In Chapter 3, SICP gives a special example in scheme, showing students how to use scheme to implement a small circuit simulator just like verilog. However it did not go into details, just provides a rough sketch. And the codes are in a way that easy for adept programmer to read, not for new programmers like me.&lt;/p&gt;
&lt;p&gt;So I reiterate the code here, and describe the code segments in a human sequence (compared with SICP&#39;s only-god-know sequence).&lt;/p&gt;
&lt;h1 id=&#34;full-overview&#34;&gt;Full Overview&lt;/h1&gt;
&lt;p&gt;First of all, we only implement three basical gates (and or not) as primitives. We can imagine the circuit like the one below: In fact all the digital system can unfold into this three gates. So only 3 primitives is enough.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2019-4-4-Event-Driven/HA.png&#34; alt=&#34;Fig 1. A Half Adder Circuit&#34;&gt;&lt;/p&gt;
&lt;p&gt;We must know how to we make our program behave like the real circuit. The program must transmit the signal from a node to another node, and changed them according to the gates&amp;rsquo; different input output rules. What&#39;s more, we must know the delay of each gate and make every event happend in the time sequence. We will first go through main event-driven part and ignore the time line.&lt;/p&gt;
&lt;p&gt;The signals carried on circuit wires vary over time, when a signal changes, we know it causes a sequence of follow wires jumpping from 0 to 1 or 1 to 0 due to the logic gates rules. So we must invent a program mechanics to let a logic gate node able to catch a change on their input parameters and change their output, but how?&lt;/p&gt;
&lt;p&gt;The answer is add an extra intermedia to hold a state, and let it trigger the event. In this article, the &lt;strong&gt;wire&lt;/strong&gt; object takes this duty, we define wire as below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;get-signal&lt;/span&gt; wire) (&lt;span style=&#34;color:#a6e22e&#34;&gt;wire&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;get-signal&lt;/span&gt;))
(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;set-signal!&lt;/span&gt; wire new-value)
  ((&lt;span style=&#34;color:#a6e22e&#34;&gt;wire&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;set-signal!&lt;/span&gt;) new-value))
(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;add-action!&lt;/span&gt; wire action-procedure)
  ((&lt;span style=&#34;color:#a6e22e&#34;&gt;wire&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;add-action!&lt;/span&gt;) action-procedure))

(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;make-wire&lt;/span&gt;)
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;signal-value&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) (&lt;span style=&#34;color:#a6e22e&#34;&gt;action-procedures&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;()))
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;set-my-signal!&lt;/span&gt; new-value)
      (&lt;span style=&#34;color:#66d9ef&#34;&gt;if &lt;/span&gt;(not (= signal-value new-value))
          (&lt;span style=&#34;color:#66d9ef&#34;&gt;begin &lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;set! &lt;/span&gt;signal-value new-value)
                 (&lt;span style=&#34;color:#a6e22e&#34;&gt;call-each&lt;/span&gt; action-procedures))
          &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;not-changed&lt;/span&gt;))
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;accept-action-procedure!&lt;/span&gt; proc)
      (&lt;span style=&#34;color:#66d9ef&#34;&gt;set! &lt;/span&gt;action-procedures
            (cons proc action-procedures))
      (&lt;span style=&#34;color:#a6e22e&#34;&gt;proc&lt;/span&gt;))
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;dispatch&lt;/span&gt; m)
      (&lt;span style=&#34;color:#66d9ef&#34;&gt;cond &lt;/span&gt;((eq? m &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;get-signal&lt;/span&gt;) signal-value)
            ((eq? m &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;set-signal!&lt;/span&gt;) set-my-signal!)
            ((eq? m &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;add-action!&lt;/span&gt;) accept-action-procedure!)
            (&lt;span style=&#34;color:#66d9ef&#34;&gt;else &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Unknown operation on wires&amp;#34;&lt;/span&gt;))))
    dispatch))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can see that the wire holds a local variable &lt;code&gt;signal-value&lt;/code&gt; and a procedure list &lt;code&gt;action-procedures&lt;/code&gt;. Wire has three interfaces to interact with other part of the program. The interesting part is the &lt;code&gt;set-my-signal!&lt;/code&gt; call, which does not simply change the signal value, but also triggeres the procedures in the list.&lt;/p&gt;
&lt;p&gt;So think when the state of a wire is changed, it will call the procedure (these procedures are stored internal but defined as global) to change the state of adjacent wires, by calling their &lt;code&gt;set-signal!&lt;/code&gt; calls, and &lt;code&gt;set-signal!&lt;/code&gt; is defined in a particular way that tiggeres internal-stored procedures which affect the next wires and there becomes a chain reaction till processor reaches the output wires where no procedures are stored, all the wires are refreshed.&lt;/p&gt;
&lt;p&gt;What are the procedures in the list? They are called when the value changes, in this case, they are logic gates. We must define these procedures in a way the connected wires are bound together, because we cannot bind them inside the wire object due to local environment rules. We want to change the connected wires states when called, it is important to construct the procedure environment enclosed in global environment and only in this way the wires state can be changed when internal precedures are called.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;call-each&lt;/code&gt; calls these procedures, which are defined as global procedures (very important) and have no arguments.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;call-each&lt;/span&gt; procedures)
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;if &lt;/span&gt;(null? procedures)
      &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;done&lt;/span&gt;
      (&lt;span style=&#34;color:#66d9ef&#34;&gt;begin &lt;/span&gt;((car procedures))
             (&lt;span style=&#34;color:#a6e22e&#34;&gt;call-each&lt;/span&gt; (cdr procedures)))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;logic-gates&#34;&gt;Logic Gates&lt;/h1&gt;
&lt;p&gt;The three logic gates are defined below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;inverter&lt;/span&gt; input output)
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;invert-input&lt;/span&gt;)
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;new-value&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;logical-not&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;get-signal&lt;/span&gt; input))))
        (&lt;span style=&#34;color:#a6e22e&#34;&gt;set-signal!&lt;/span&gt; output new-value)))
  (&lt;span style=&#34;color:#a6e22e&#34;&gt;add-action!&lt;/span&gt; input invert-input) &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ok&lt;/span&gt;)

(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;logical-not&lt;/span&gt; s)
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;cond &lt;/span&gt;((= s &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
        ((= s &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
        (&lt;span style=&#34;color:#66d9ef&#34;&gt;else &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Invalid signal&amp;#34;&lt;/span&gt; s))))

(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;and-gate&lt;/span&gt; input1 input2 output)
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;and-input&lt;/span&gt;)
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;new-value&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;logical-and&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;get-signal&lt;/span&gt; input1) (&lt;span style=&#34;color:#a6e22e&#34;&gt;get-signal&lt;/span&gt; input2))))
      (&lt;span style=&#34;color:#a6e22e&#34;&gt;set-signal!&lt;/span&gt; output new-value)))
  (&lt;span style=&#34;color:#a6e22e&#34;&gt;add-action!&lt;/span&gt; input1 and-input)
  (&lt;span style=&#34;color:#a6e22e&#34;&gt;add-action!&lt;/span&gt; input2 and-input) &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ok&lt;/span&gt;)

(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;logical-and&lt;/span&gt; s1 s2)
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;cond &lt;/span&gt;((= (* s1 s2) &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
        ((&lt;span style=&#34;color:#66d9ef&#34;&gt;or &lt;/span&gt;(= (+ s1 s2) &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) (= (+ s1 s2) &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)) &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
        (&lt;span style=&#34;color:#66d9ef&#34;&gt;else &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Invalid signal&amp;#34;&lt;/span&gt; s1 s2))))

(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;or-gate&lt;/span&gt; input1 input2 output)
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;or-input&lt;/span&gt;)
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;new-value&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;logical-or&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;get-signal&lt;/span&gt; input1) (&lt;span style=&#34;color:#a6e22e&#34;&gt;get-signal&lt;/span&gt; input2))))
      (&lt;span style=&#34;color:#a6e22e&#34;&gt;set-signal!&lt;/span&gt; output new-value)))
  (&lt;span style=&#34;color:#a6e22e&#34;&gt;add-action!&lt;/span&gt; input1 or-input)
  (&lt;span style=&#34;color:#a6e22e&#34;&gt;add-action!&lt;/span&gt; input2 or-input) &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;ok&lt;/span&gt;)

(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;logical-or&lt;/span&gt; s1 s2)
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;cond &lt;/span&gt;((&lt;span style=&#34;color:#66d9ef&#34;&gt;and &lt;/span&gt;(= s1 &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) (= s2 &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
        ((&lt;span style=&#34;color:#66d9ef&#34;&gt;and &lt;/span&gt;(= s2 &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) (= s1 &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
        ((&lt;span style=&#34;color:#66d9ef&#34;&gt;and &lt;/span&gt;(= s1 &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) (= s2 &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)) &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
        ((&lt;span style=&#34;color:#66d9ef&#34;&gt;and &lt;/span&gt;(= s1 &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) (= s2 &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)) &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
        (&lt;span style=&#34;color:#66d9ef&#34;&gt;else &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Invalid Signal&amp;#34;&lt;/span&gt; s1 s2))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;These gates themselves are like injectors, they create the procedures and injected them into the input wires.&lt;/p&gt;
&lt;h1 id=&#34;probes&#34;&gt;Probes&lt;/h1&gt;
&lt;p&gt;We just finished the gates and the wires, and the simulation is ready to go, but we need a probe on the wires to tell us the change happended to what wire and from what state to another state.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;probe&lt;/span&gt; name wire)
  (&lt;span style=&#34;color:#a6e22e&#34;&gt;add-action!&lt;/span&gt; wire
               (&lt;span style=&#34;color:#66d9ef&#34;&gt;lambda &lt;/span&gt;()
                 (display name) (display &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;)
                 (display &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; New-value = &amp;#34;&lt;/span&gt;)
                 (display (&lt;span style=&#34;color:#a6e22e&#34;&gt;get-signal&lt;/span&gt; wire))
                 (&lt;span style=&#34;color:#a6e22e&#34;&gt;newline&lt;/span&gt;))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;go&#34;&gt;Go!&lt;/h1&gt;
&lt;p&gt;Using the gate primitives defined above, we can implement the &lt;code&gt;half-adder&lt;/code&gt; in picture above:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;half-adder&lt;/span&gt; A B S C)
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;D (&lt;span style=&#34;color:#a6e22e&#34;&gt;make-wire&lt;/span&gt;))
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;E (&lt;span style=&#34;color:#a6e22e&#34;&gt;make-wire&lt;/span&gt;))
  (&lt;span style=&#34;color:#a6e22e&#34;&gt;and-gate&lt;/span&gt; A B C)
  (&lt;span style=&#34;color:#a6e22e&#34;&gt;or-gate&lt;/span&gt; A B D)
  (&lt;span style=&#34;color:#a6e22e&#34;&gt;inverter&lt;/span&gt; C E)
  (&lt;span style=&#34;color:#a6e22e&#34;&gt;and-gate&lt;/span&gt; D E S))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;I use DrRacket and SCM to test the program, here is the result of DrRacket:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-racket&#34; data-lang=&#34;racket&#34;&gt;&amp;gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;define&lt;/span&gt; in1 (make-wire))
&amp;gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;define&lt;/span&gt; in2 (make-wire))
&amp;gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;define&lt;/span&gt; out1 (make-wire))
&amp;gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;define&lt;/span&gt; cout1 (make-wire))
&amp;gt; (probe &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;in1&lt;/span&gt; in1)
in1  New-value = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&amp;gt; (probe &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;in2&lt;/span&gt; in2)
in2  New-value = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&amp;gt; (probe &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;out1&lt;/span&gt; out1)
out1  New-value = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&amp;gt; (probe &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;cout1&lt;/span&gt; cout1)
cout1  New-value = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
&amp;gt; (half-adder in1 in2 out1 cout1)
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;ok&lt;/span&gt;
&amp;gt; (set-signal! in1 &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
out1  New-value = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
in1  New-value = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;done&lt;/span&gt;
&amp;gt; (set-signal! in2 &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
out1  New-value = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
cout1  New-value = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
in2  New-value = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;done&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;time-line&#34;&gt;Time Line&lt;/h1&gt;
&lt;p&gt;We finished the event-driven part. Now I believe you have a basical idea of the program architecture. Now move to another question, the difficulty raised, if we add a delay to all the gates, and want to see both state and time line of the change, how to make it?&lt;/p&gt;
&lt;p&gt;We need to import a new concept into our program, a time queue. By this case, it is &lt;strong&gt;The Agenda&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;the-agenda&#34;&gt;The Agenda&lt;/h2&gt;
&lt;p&gt;The agenda is actually a queue, every element in this queue contains a time stamp and the task.&lt;/p&gt;
&lt;p&gt;We can easily wrote down queue structure in scheme:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;;;;This file shows how to present queue in scheme (message-passing style)&lt;/span&gt;

(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;nil &lt;span style=&#34;color:#f92672&#34;&gt;&amp;#39;&lt;/span&gt;())

(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;empty-queue?&lt;/span&gt; queue)
  ((&lt;span style=&#34;color:#a6e22e&#34;&gt;queue&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;empty&lt;/span&gt;)))
(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;front-queue&lt;/span&gt; queue)
  ((&lt;span style=&#34;color:#a6e22e&#34;&gt;queue&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;front&lt;/span&gt;)))
(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;insert-queue!&lt;/span&gt; queue item)
  ((&lt;span style=&#34;color:#a6e22e&#34;&gt;queue&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;insert&lt;/span&gt;) item))
(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;delete-queue!&lt;/span&gt; queue)
  ((&lt;span style=&#34;color:#a6e22e&#34;&gt;queue&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;delete&lt;/span&gt;)))
(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;print-queue&lt;/span&gt; queue)
  ((&lt;span style=&#34;color:#a6e22e&#34;&gt;queue&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;print&lt;/span&gt;)))

(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;make-queue&lt;/span&gt;)
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;front-ptr&lt;/span&gt; nil)
        (&lt;span style=&#34;color:#a6e22e&#34;&gt;rear-ptr&lt;/span&gt; nil))
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;empty-queue?&lt;/span&gt;)
      (eq? front-ptr nil))
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;front-queue&lt;/span&gt;)
      (&lt;span style=&#34;color:#66d9ef&#34;&gt;if &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;empty-queue?&lt;/span&gt;)
          (&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ERROR front-queue called with an empty queue&amp;#34;&lt;/span&gt;)
          (car front-ptr)))
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;set-front-ptr!&lt;/span&gt; pair)
      (&lt;span style=&#34;color:#66d9ef&#34;&gt;set! &lt;/span&gt;front-ptr pair))
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;set-rear-ptr!&lt;/span&gt; pair)
      (&lt;span style=&#34;color:#66d9ef&#34;&gt;set! &lt;/span&gt;rear-ptr pair))
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;insert-queue!&lt;/span&gt; item)
      (&lt;span style=&#34;color:#66d9ef&#34;&gt;cond &lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;empty-queue?&lt;/span&gt;)
             (&lt;span style=&#34;color:#a6e22e&#34;&gt;set-front-ptr!&lt;/span&gt; (cons item nil))
             (&lt;span style=&#34;color:#a6e22e&#34;&gt;set-rear-ptr!&lt;/span&gt; front-ptr)
             front-ptr)
            (&lt;span style=&#34;color:#66d9ef&#34;&gt;else &lt;/span&gt;(set-cdr! rear-ptr (cons item nil))
                  (&lt;span style=&#34;color:#a6e22e&#34;&gt;set-rear-ptr!&lt;/span&gt; (cdr rear-ptr))
                  front-ptr)))
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;delete-queue!&lt;/span&gt;)
      (&lt;span style=&#34;color:#66d9ef&#34;&gt;cond &lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;empty-queue?&lt;/span&gt;)
             (&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;ERROR delete-queue called with an empty queue&amp;#34;&lt;/span&gt;))
            (&lt;span style=&#34;color:#66d9ef&#34;&gt;else &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;set-front-ptr!&lt;/span&gt; (cdr front-ptr))
                  front-ptr)))
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;print-queue&lt;/span&gt;)
      front-ptr)

    (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;dispatch&lt;/span&gt; m)
      (&lt;span style=&#34;color:#66d9ef&#34;&gt;cond &lt;/span&gt;((eq? m &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;empty&lt;/span&gt;) empty-queue?)
            ((eq? m &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;front&lt;/span&gt;) front-queue)
            ((eq? m &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;insert&lt;/span&gt;) insert-queue!)
            ((eq? m &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;delete&lt;/span&gt;) delete-queue!)
            ((eq? m &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;print&lt;/span&gt;) print-queue)
            (&lt;span style=&#34;color:#66d9ef&#34;&gt;else &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Unknown queue operation&amp;#34;&lt;/span&gt;))))
    dispatch))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;implementing-the-agenda&#34;&gt;Implementing the agenda&lt;/h3&gt;
&lt;p&gt;Agenda is a list of &lt;em&gt;time segments&lt;/em&gt;. Each time segment is a pair of time and a queue (holds the procedures to be run at that time).&lt;/p&gt;
&lt;p&gt;Recall the signal process of each node, nodes are registered with events, we can insert a small piece of code in each event to push a &lt;em&gt;time segment&lt;/em&gt; behind the agenda queue, so after all events terminate, by checking the agenda we know when these changes happends.&lt;/p&gt;
&lt;p&gt;The problem is when we implement the agenda, we only know the delay of gates. Apropos the delay sequence and the exact time of each event, we have to accumulate the former delays and this elicits a formal problem that we have to maintain a current time variable, and &lt;code&gt;set!&lt;/code&gt; it every time when we push a time segment in the agenda structure.&lt;/p&gt;
&lt;p&gt;First we implememt the agenda structure:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;make-agenda&lt;/span&gt;) (list &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;))
(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;current-time&lt;/span&gt; agenda) (car agenda))
(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;set-current-time!&lt;/span&gt; agenda time)
(set-car! agenda time))
(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;segments&lt;/span&gt; agenda) (cdr agenda))
(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;set-segments!&lt;/span&gt; agenda segments)
(set-cdr! agenda segments))
(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;first-segment&lt;/span&gt; agenda) (car (&lt;span style=&#34;color:#a6e22e&#34;&gt;segments&lt;/span&gt; agenda)))
(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;rest-segments&lt;/span&gt; agenda) (cdr (&lt;span style=&#34;color:#a6e22e&#34;&gt;segments&lt;/span&gt; agenda)))
(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;empty-agenda?&lt;/span&gt; agenda)
  (null? (&lt;span style=&#34;color:#a6e22e&#34;&gt;segments&lt;/span&gt; agenda)))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To add an action to an agenda, we first check if the agenda is empty. If so, we create a time segment for the action and install this in the agenda. Otherwise, we scan the agenda, examining the time of each segment. If we find a segment for our appointed time, we add the action to the associated queue. If we reach a time later than the one to which we are
appointed, we insert a new time segment into the agenda just before it. If we reach the end of the agenda, we must ceate a new time segment at the end.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-scheme&#34; data-lang=&#34;scheme&#34;&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;add-to-agenda!&lt;/span&gt; time action agenda)
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;belongs-before?&lt;/span&gt; segments)
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;or &lt;/span&gt;(null? segments)
        (&amp;lt; time (&lt;span style=&#34;color:#a6e22e&#34;&gt;segment-time&lt;/span&gt; (car segments)))))
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;make-new-time-segment&lt;/span&gt; time action)
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;q&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;make-queue&lt;/span&gt;)))
      (&lt;span style=&#34;color:#a6e22e&#34;&gt;insert-queue!&lt;/span&gt; q action)
      (&lt;span style=&#34;color:#a6e22e&#34;&gt;make-time-segment&lt;/span&gt; time q)))
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;add-to-segments!&lt;/span&gt; segments)
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;if &lt;/span&gt;(= (&lt;span style=&#34;color:#a6e22e&#34;&gt;segment-time&lt;/span&gt; (car segments)) time)
        (&lt;span style=&#34;color:#a6e22e&#34;&gt;insert-queue!&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;segment-queue&lt;/span&gt; (car segments))
                       action)
        (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;rest&lt;/span&gt; (cdr segments)))
          (&lt;span style=&#34;color:#66d9ef&#34;&gt;if &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;belongs-before?&lt;/span&gt; rest)
              (&lt;span style=&#34;color:#a6e22e&#34;&gt;set-cdr!&lt;/span&gt;
               segments
               (cons (&lt;span style=&#34;color:#a6e22e&#34;&gt;make-new-time-segment&lt;/span&gt; time action)
                     (cdr segments)))
              (&lt;span style=&#34;color:#a6e22e&#34;&gt;add-to-segments!&lt;/span&gt; rest)))))
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;segments&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;segments&lt;/span&gt; agenda)))
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;if &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;belongs-before?&lt;/span&gt; segments)
        (&lt;span style=&#34;color:#a6e22e&#34;&gt;set-segments!&lt;/span&gt;
         agenda
         (cons (&lt;span style=&#34;color:#a6e22e&#34;&gt;make-new-time-segment&lt;/span&gt; time action)
               segments))
        (&lt;span style=&#34;color:#a6e22e&#34;&gt;add-to-segments!&lt;/span&gt; segments))))

(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;remove-first-agenda-item!&lt;/span&gt; agenda)
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;q&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;segment-queue&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;first-segment&lt;/span&gt; agenda))))
    (&lt;span style=&#34;color:#a6e22e&#34;&gt;delete-queue!&lt;/span&gt; q)
    (&lt;span style=&#34;color:#66d9ef&#34;&gt;if &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;empty-queue?&lt;/span&gt; q)
        (&lt;span style=&#34;color:#a6e22e&#34;&gt;set-segments!&lt;/span&gt; agenda (&lt;span style=&#34;color:#a6e22e&#34;&gt;rest-segments&lt;/span&gt; agenda)))))

(&lt;span style=&#34;color:#66d9ef&#34;&gt;define &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;first-agenda-item&lt;/span&gt; agenda)
  (&lt;span style=&#34;color:#66d9ef&#34;&gt;if &lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;empty-agenda?&lt;/span&gt; agenda)
      (&lt;span style=&#34;color:#a6e22e&#34;&gt;error&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Agenda is empty: FIRST-AGENDA-ITEM&amp;#34;&lt;/span&gt;)
      (&lt;span style=&#34;color:#66d9ef&#34;&gt;let &lt;/span&gt;((&lt;span style=&#34;color:#a6e22e&#34;&gt;first-seg&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;first-segment&lt;/span&gt; agenda)))
        (&lt;span style=&#34;color:#a6e22e&#34;&gt;set-current-time!&lt;/span&gt; agenda
                           (&lt;span style=&#34;color:#a6e22e&#34;&gt;segment-time&lt;/span&gt; first-seg))
        (&lt;span style=&#34;color:#a6e22e&#34;&gt;front-queue&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;segment-queue&lt;/span&gt; first-seg)))))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>JOS Lab1 My Answers</title>
      <link>https://xiahualiu.github.io/posts/2019-02-23-jos-lab1/</link>
      <pubDate>Sat, 23 Feb 2019 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2019-02-23-jos-lab1/</guid>
      <description>&lt;p&gt;The &lt;a href=&#34;https://pdos.csail.mit.edu/6.828/2018/labs/lab1/&#34;&gt;xv6 lab1&lt;/a&gt; provides a extern kernel named JOS, it works in the same way as xv6. So student can step in it to explore the world of xv6.&lt;/p&gt;
&lt;h1 id=&#34;part-2-the-boot-loader&#34;&gt;Part 2: The Boot Loader&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;At what point does the processor start executing 32-bit code? What exactly causes the switch from 16- to 32-bit mode?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: After opening A20 Gate and loading GDT table that is prepared in &lt;code&gt;boot.S&lt;/code&gt;, we enable protected mode by moving a value with &lt;code&gt;$CR0_PE_ON&lt;/code&gt; bit to &lt;code&gt;CR0&lt;/code&gt; register. But the exact activation event happens during &lt;code&gt;ljmp&lt;/code&gt; instruction, while &lt;code&gt;CS&lt;/code&gt; and &lt;code&gt;IP&lt;/code&gt; registers both update and point to the beginning of 32-bit code (which is, however, at the next memory address). CPU works in 32-bit mode after that.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What is the last instruction of the boot loader executed, and what is the first instruction of the kernel it just loaded?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: The boot loader reads kernel in elf file format from disk, then copies each section into the corresponding location in memory. The last job of bootloader is calling the entry address of the kernel &lt;code&gt;*0x10018&lt;/code&gt;(the entry address is stored at the fixed address in memory because its fixed offset in elf file and is &lt;code&gt;0x0010000c&lt;/code&gt; in this case), transferring control to kernel. And the first instruction is: &lt;code&gt;movw $0x1234,0x472&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2019-2-23-JOS-lab1/1.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Where is the first instruction of the kernel?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: Said above, at &lt;code&gt;0x10000c&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;How does the boot loader decide how many sectors it must read in order to fetch the entire kernel from disk? Where does it find this information?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: The boot loader first reads elf header to get the starting address of program header table &lt;code&gt;ph=ELFHDR + ELFHDR-&amp;gt;e_phoff&lt;/code&gt;, then reads the number of entries in the program header table by &lt;code&gt;ELFHDR-&amp;gt;e_phnum&lt;/code&gt;, then adds it to &lt;code&gt;ph&lt;/code&gt; to acquire the end of the program header table &lt;code&gt;eph&lt;/code&gt;, then loops reading each segment.&lt;/p&gt;
&lt;h2 id=&#34;exercise-5&#34;&gt;Exercise 5&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Trace through the first few instructions of the boot loader again and identify the first instruction that would &amp;ldquo;break&amp;rdquo; or otherwise do the wrong thing if you were to get the boot loader&#39;s link address wrong. Then change the link address in boot/Makefrag to something wrong, run &lt;code&gt;make clean&lt;/code&gt;, recompile the lab with &lt;code&gt;make&lt;/code&gt;, and trace into the boot loader again to see what happens. Don&#39;t forget to change the link address back and &lt;code&gt;make clean&lt;/code&gt; again afterward!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: The boot loader&#39;s entry is at &lt;code&gt;0x7c00&lt;/code&gt; if it is changed to &lt;code&gt;0x7c01&lt;/code&gt; or else that are not aligned right, some &lt;code&gt;nop&lt;/code&gt; will be inserted at the top to slide processor to the aligned instructions.&lt;/p&gt;
&lt;p&gt;After that, the code is executed normally, however, when it comes to the first &lt;code&gt;ljmp&lt;/code&gt;, it crashes immediately. But the real problem happened way ahead, the crash is due to a loading GDT table failure (&lt;code&gt;lgdt&lt;/code&gt; did not complain).&lt;/p&gt;
&lt;p&gt;As we know, we changed the linker address however the load address of our program stays unchanged. The BIOS works blindly, it just reads 1st sector on disk (no matter what link address is) then jumps to &lt;code&gt;0x7c00&lt;/code&gt;. Thus the actual GDT table has still been put at the old place (GDT is always put at &lt;code&gt;0x7c4c&lt;/code&gt; in xv6 case), but into the bootloader, the &lt;code&gt;lgdt&lt;/code&gt; only accepts linker address, which is wrong. So what &lt;code&gt;lgdt&lt;/code&gt; actually installed was meaningless trash in memory after the modification.&lt;/p&gt;
&lt;p&gt;So when the &lt;code&gt;ljmp&lt;/code&gt; reads GDT, it gets trash value instead of real GDT entries. Then the program crashes.&lt;/p&gt;
&lt;h2 id=&#34;exercise-6&#34;&gt;Exercise 6&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;We can examine memory using GDB&#39;s &lt;code&gt;x&lt;/code&gt; command. The GDB manual has full details, but for now, it is enough to know that the command &lt;code&gt;x/Nx ADDR&lt;/code&gt; prints N words of memory at ADDR. (Note that both &lt;code&gt;x&lt;/code&gt;s in the command are lowercase.) Warning: The size of a word is not a universal standard. In GNU assembly, a word is two bytes (the &lt;code&gt;w&lt;/code&gt; in xorw, which stands for word, means 2 bytes).
Reset the machine (exit QEMU/GDB and start them again). Examine the 8 words of memory at &lt;code&gt;0x00100000&lt;/code&gt; at the point the BIOS enters the boot loader, and then again at the point the boot loader enters the kernel. Why are they different? What is there at the second breakpoints? (You do not really need to use QEMU to answer this question. Just think.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: During the time from the CPU changed into protected mode and to the bootloader starts, &lt;code&gt;0x100000&lt;/code&gt; and higher addresses are of full zeroes.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2019-2-23-JOS-lab1/2.png&#34; alt=&#34;2&#34;&gt;&lt;/p&gt;
&lt;p&gt;The reason is simple, we haven&#39;t mapped the kernel into memory yet at that time.&lt;/p&gt;
&lt;h1 id=&#34;part-3-kernel&#34;&gt;Part 3: Kernel&lt;/h1&gt;
&lt;h2 id=&#34;exercise-7&#34;&gt;Exercise 7&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Use QEMU and GDB to trace into the JOS kernel and stop at the movl %eax, %cr0. Examine memory at 0x00100000 and at 0xf0100000. Now, single step over that instruction using the stepi GDB command. Again, examine memory at 0x00100000 and at 0xf0100000. Make sure you understand what just happened.
What is the first instruction after the new mapping is established that would fail to work properly if the mapping weren&#39;t in place? Comment out the movl %eax, %cr0 in kern/entry.S, trace into it, and see if you were right.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2019-2-23-JOS-lab1/3.png&#34; alt=&#34;3&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: After &lt;code&gt;movl %eax %cr0&lt;/code&gt;, Memory at &lt;code&gt;0x0010000&lt;/code&gt; was copied to &lt;code&gt;0xf010000&lt;/code&gt;. But the real fact is that these pages are mapped to the same physical memory page.&lt;/p&gt;
&lt;p&gt;If the mapping failed, the jump up to the &lt;code&gt;KERNBASE&lt;/code&gt; would definitely fail.&lt;/p&gt;
&lt;p&gt;We can see that in picture. The program jumped to a null memory, then crashed.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2019-2-23-JOS-lab1/4.png&#34; alt=&#34;4&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;exercise-8&#34;&gt;Exercise 8&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;We have omitted a small fragment of code - the code necessary to print octal numbers using patterns of the form &amp;ldquo;%o&amp;rdquo;. Find and fill in this code fragment.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: Original file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;...

&lt;span style=&#34;color:#75715e&#34;&gt;// (unsigned) octal
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;o&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// Replace this with your code.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        putch(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;X&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;, putdat);
        putch(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;X&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;, putdat);
        putch(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;X&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;, putdat);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;

...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;New file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;...

&lt;span style=&#34;color:#75715e&#34;&gt;// (unsigned) octal
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;o&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
    &lt;span style=&#34;color:#75715e&#34;&gt;// My code
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; getuint(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ap,lflag);
        base &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; number;

...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Be able to answer the following questions:&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;Explain the interface between &lt;code&gt;printf.c&lt;/code&gt; and &lt;code&gt;console.c&lt;/code&gt;. Specifically, what function does &lt;code&gt;console.c&lt;/code&gt; export? How is this function used by printf.c?
&lt;strong&gt;Answer&lt;/strong&gt;: &lt;code&gt;console.c&lt;/code&gt; exports high-level I/O by providing three functions, &lt;code&gt;cputchar&lt;/code&gt; &lt;code&gt;getchar&lt;/code&gt; &lt;code&gt;iscons&lt;/code&gt;.
The &lt;code&gt;cputchar&lt;/code&gt; function is used for &lt;code&gt;printf.c&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;Explain the following from &lt;code&gt;console.c&lt;/code&gt;:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (crt_pos &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; CRT_SIZE) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i;
    memmove(crt_buf, crt_buf &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; CRT_COLS, (CRT_SIZE &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; CRT_COLS) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(uint16_t));
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; CRT_SIZE &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; CRT_COLS; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; CRT_SIZE; i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;)
        crt_buf[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0700&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;;
    crt_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; CRT_COLS;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Prevent screen buffer overflow
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (crt_pos &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; CRT_SIZE) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i;
    &lt;span style=&#34;color:#75715e&#34;&gt;// Move all CRT content a column up, vacating the bottom column
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    memmove(crt_buf, crt_buf &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; CRT_COLS, (CRT_SIZE &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; CRT_COLS) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(uint16_t));
    &lt;span style=&#34;color:#75715e&#34;&gt;// Loop printing the bottom line with print attribute: &amp;#39;white on black&amp;#39;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; CRT_SIZE &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; CRT_COLS; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; CRT_SIZE; i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;)
        crt_buf[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0700&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;;
    crt_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; CRT_COLS;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;For the following questions you might wish to consult the notes for Lecture 2. These notes cover GCC&#39;s calling convention on the x86.
Trace the execution of the following code step-by-step:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;In the call to cprintf(), to what does &lt;code&gt;fmt&lt;/code&gt; point? To what does &lt;code&gt;ap&lt;/code&gt; point?&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;;
cprintf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;x %d, y %x, z %d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, x, y, z);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;I add this code in &lt;code&gt;init.c&lt;/code&gt;, right after the first &lt;code&gt;cprintf&lt;/code&gt;, seen below:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;i386_init&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;extern&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; edata[], end[];

	&lt;span style=&#34;color:#75715e&#34;&gt;// Before doing anything else, complete the ELF loading process.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// Clear the uninitialized global data (BSS) section of our program.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// This ensures that all static/global variables start out zero.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	memset(edata, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, end &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; edata);

	&lt;span style=&#34;color:#75715e&#34;&gt;// Initialize the console.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#75715e&#34;&gt;// Can&amp;#39;t call cprintf until after we do this!
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	cons_init();

	cprintf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;6828 decimal is %o octal!&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;6828&lt;/span&gt;);

	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, y &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;;
	cprintf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;x %d, y %x, z %d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, x, y, z);

	&lt;span style=&#34;color:#75715e&#34;&gt;// Test the stack backtrace function (lab 1 only)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	test_backtrace(&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;);

	&lt;span style=&#34;color:#75715e&#34;&gt;// Drop into the kernel monitor.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
		monitor(NULL);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2019-2-23-JOS-lab1/5.png&#34; alt=&#34;5&#34;&gt;&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;fmt&lt;/code&gt; points to a memory that is in &lt;code&gt;.rodata&lt;/code&gt; section. And the content is the format string &lt;code&gt;x %d, y %x, z %d\n\0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2019-2-23-JOS-lab1/6.png&#34; alt=&#34;6&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2019-2-23-JOS-lab1/7.png&#34; alt=&#34;7&#34;&gt;&lt;/p&gt;
&lt;p&gt;I disassembled the kernel and found out that &lt;code&gt;ap&lt;/code&gt; pointed to the args that had been pushed to stack before calling &lt;code&gt;vcprintf&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------------+
| 00 00 00 04 |
+-------------+
| 00 00 00 03 |
+-------------+
| 00 00 00 01 |
+-------------+ &amp;lt;--- ap
| f0 10 1a 92 |
+-------------+ &amp;lt;--- fmt
| f0 10 00 fa |
+-------------+ 
|             |
+-------------+
|             | 
     STACK
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;List (in order of execution) each call to &lt;code&gt;cons_putc&lt;/code&gt;, &lt;code&gt;va_arg&lt;/code&gt;, and &lt;code&gt;vcprintf&lt;/code&gt;. For &lt;code&gt;cons_putc&lt;/code&gt;, list its argument as well. For &lt;code&gt;va_arg&lt;/code&gt;, list what &lt;code&gt;ap&lt;/code&gt; points to before and after the call. For &lt;code&gt;vcprintf&lt;/code&gt; list the values of its two arguments.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: List: After print &amp;ldquo;x &amp;ldquo;, &lt;code&gt;getint&lt;/code&gt; was called, in which &lt;code&gt;va_arg&lt;/code&gt; was called. Before the calling &lt;code&gt;ap = (va_list) 0xf010ffd4 &amp;quot;\001&amp;quot;&lt;/code&gt;, after the calling &lt;code&gt;ap = (va_list) 0xf010ffd8 &amp;quot;\003&amp;quot;&lt;/code&gt;. Then &lt;code&gt;cons_putc(c=49)&lt;/code&gt; was called, output changed to &amp;ldquo;x 1&amp;rdquo;. Then &lt;code&gt;cons_putc(c=44)&lt;/code&gt; was called, output changed to &amp;ldquo;x 1,&amp;quot;. Then &lt;code&gt;cons_putc(c=32)&lt;/code&gt; was called, output changed to &amp;ldquo;x 1, &amp;ldquo;. Then &lt;code&gt;cons_putc(c=121)&lt;/code&gt; was called, output changed to &amp;ldquo;x 1, y&amp;rdquo;&amp;hellip; It worked in this sequence till finishing printing.&lt;/p&gt;
&lt;p&gt;For two arguments of &lt;code&gt;vcprintf&lt;/code&gt; see picture above.&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;Run the following code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00646c72&lt;/span&gt;;
    cprintf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;H%x Wo%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;57616&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;i);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;What is the output? Explain how this output is arrived at in the step-by-step manner of the previous exercise.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Output&lt;/strong&gt;: He110 World!&lt;/p&gt;
&lt;p&gt;Decimal 57616 equals hexadecimal number 0xe110, so the first number was &amp;ldquo;e110&amp;rdquo;. And because i386 use little-endian, &lt;code&gt;0x00646c7c&lt;/code&gt; in little-endian byte order was&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0xf010ffec&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0x72&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x6c&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x64&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We can translate it into string: &lt;code&gt;rld/0&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;In the following code, what is going to be printed after &amp;lsquo;y=&amp;rsquo;? (note: the answer is not a specific value.) Why does this happen?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    cprintf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;x=%d y=%d&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Because we use &lt;code&gt;va_list&lt;/code&gt; pointer &lt;code&gt;ap&lt;/code&gt; to run down stack to acquire args that were pushed beforehand in the order from right to left in &lt;code&gt;cprintf&lt;/code&gt;. When &amp;lsquo;3&amp;rsquo; was read by &lt;code&gt;getint&lt;/code&gt; function, &lt;code&gt;va_arg&lt;/code&gt; moves pointer &lt;code&gt;ap&lt;/code&gt; upwards for the next arg, whereas we do not have another arg, instead it is an &lt;code&gt;ret&lt;/code&gt; address for &lt;code&gt;call &amp;lt;i386_init&amp;gt;&lt;/code&gt;, so the next &lt;code&gt;%d&lt;/code&gt; prints an address value.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;+-------------+
| 00 00 00 00 |
+-------------+
| f0 10 ff ec |
+-------------+ &amp;lt;--- ap (y=0xf010ffec)
| 00 00 00 03 |
+-------------+ &amp;lt;--- ap (x=3)
| f0 10 1a ce |
+-------------+ &amp;lt;--- fmt
| f0 10 01 2a |
+-------------+
|             | 
     STACK
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To confirm my speculation, I replaced the second &lt;code&gt;y=%d&lt;/code&gt; with &lt;code&gt;y=%x&lt;/code&gt;, and here it goes:&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2019-2-23-JOS-lab1/8.png&#34; alt=&#34;8&#34;&gt;&lt;/p&gt;
&lt;p&gt;Just like above.&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;Let&#39;s say that GCC changed its calling convention so that it pushed arguments on the stack in declaration order, so that the last argument is pushed last. How would you have to change cprintf or its interface so that it would still be possible to pass it a variable number of arguments?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: We can make &lt;code&gt;va_list&lt;/code&gt; pointer &lt;code&gt;ap&lt;/code&gt; points to the highest arg on stack before entering &lt;code&gt;vcprintf&lt;/code&gt;, then modify &lt;code&gt;va_arg&lt;/code&gt; to decrease &lt;code&gt;ap&lt;/code&gt; instead of increase it.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Challenge&lt;/strong&gt; Enhance the console to allow text to be printed in different colors. The traditional way to do this is to make it interpret ANSI escape sequences embedded in the text strings printed to the console, but you may use any mechanism you like. There is plenty of information on the 6.828 reference page and elsewhere on the web on programming the VGA display hardware. If you&#39;re feeling really adventurous, you could try switching the VGA hardware into a graphics mode and making the console draw text onto the graphical frame buffer.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: &lt;em&gt;Too complex, to be solved.&lt;/em&gt;&lt;/p&gt;
&lt;h1 id=&#34;the-stack&#34;&gt;The Stack&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exercise 9&lt;/strong&gt;. Determine where the kernel initializes its stack, and exactly where in memory its stack is located. How does the kernel reserve space for its stack? And at which &amp;ldquo;end&amp;rdquo; of this reserved area is the stack pointer initialized to point to?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: In file &amp;ldquo;entry.S&amp;rdquo;,&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86_asm&#34; data-lang=&#34;x86_asm&#34;&gt;	# Set the stack pointer
	movl	$(bootstacktop),%esp
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;$(bootstacktop)&lt;/code&gt; is defined the end of &amp;ldquo;entry.S&amp;rdquo;, it is &lt;code&gt;KSTKSIZE&lt;/code&gt; away from the beginning of &lt;code&gt;.data&lt;/code&gt; section.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86_asm&#34; data-lang=&#34;x86_asm&#34;&gt;.data
###################################################################
# boot stack
###################################################################
	.p2align	PGSHIFT		# force page alignment
	.globl		bootstack
bootstack:
	.space		KSTKSIZE
	.globl		bootstacktop   
bootstacktop:
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Exercise 10&lt;/strong&gt;. To become familiar with the C calling conventions on the x86, find the address of the test_backtrace function in obj/kern/kernel.asm, set a breakpoint there, and examine what happens each time it gets called after the kernel starts. How many 32-bit words does each recursive nesting level of test_backtrace push on the stack, and what are those words?
Note that, for this exercise to work properly, you should be using the patched version of QEMU available on the tools page or on Athena. Otherwise, you&#39;ll have to manually translate all breakpoint and memory addresses to linear addresses.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;: Every level of nesting, push 8 words on stack.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2019-2-23-JOS-lab1/9.png&#34; alt=&#34;9&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>xv6 Basics - Page Tables</title>
      <link>https://xiahualiu.github.io/posts/2019-02-06-xv6-paging-table/</link>
      <pubDate>Wed, 06 Feb 2019 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2019-02-06-xv6-paging-table/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Paging tables are the mechanism through which the operating system controls what memory address means.&lt;/strong&gt; They allow xv6 to multiplex the address spaces of different processes onto a single physical memory, and to protect the memories of different processes. The level of indirection provided by page tables allows many neat tricks. xv6 uses page tables primarily to multiplex address spaces and to protect memory.&lt;/p&gt;
&lt;p&gt;It also uses a few simple page-table tricks:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mapping the same memory (the kernel) in several address spaces.&lt;/li&gt;
&lt;li&gt;Mapping the same memory more than once in one address space. (Each user page is also mapped into the kernel&#39;s physical view of memory)&lt;/li&gt;
&lt;li&gt;Guarding a user stack with an ummapped page.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;paging-hardware&#34;&gt;Paging hardware&lt;/h1&gt;
&lt;p&gt;As a reminder, x86 instructions (both user and kernel) manipulate virtual addresses. The mechine&#39;s RAM, or physical memory, is indexed with physical addresses.&lt;/p&gt;
&lt;p&gt;The x86 page table hardware connects these two kinds of addresses, by mapping each virtual address to a physical address.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   10      10          12          |     PPN     | Offset |  
|-------|---------|----------|            ^
|  Dir  |  Table  |  Offset  |        20  |          12
|-------|----|----|----------|     |------|------|-------|
    |        |--------------------&amp;gt;|     PPN     | Flags |
    |                              |-------------|-------|
    |         20       10          |             |       |
    |     |---------|-------|      |-------------|-------|
    |     |         |       |      |             |       |
    |     |---------|-------|      |-------------|-------|
    |----&amp;gt;|   PPN   | Flags |-------&amp;gt;     Page Table
          |---------|-------|         2^10(1024) entries
          |         |       |              (PTEs)
          |---------|-------|
 |CR3|---&amp;gt;   Page Directory
           2^10(1024) entries
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;According to CSAPP, xv6 uses paging harware that support 2-level paging.&lt;/p&gt;
&lt;p&gt;We use first top 10 bits to index page directory, and fetch the 20 bits PPN to index the Page table, and use the second 10 bits to index PPN in page table.&lt;/p&gt;
&lt;p&gt;An x86 page table is logically an array of 2^20 (1,048,576) page table entries. Thus a page table gives table gives the operating system control over virtual-to-physical address translations at the granularity of aligned chunks of 4096 (2^12) bytes. Such a chunk is called a page.&lt;/p&gt;
&lt;p&gt;Each PTE contains &lt;strong&gt;flag bits&lt;/strong&gt; that tell the paging hardware how the associated virtual address is allowed to be used:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;|31                    |12   |8   |6  |5  |4   |3   |2  |1  |0  |
|----------------------|-----|----|---|---|----|----|---|---|---|
| Physical Page Number | AVL |    | D | A | CD | WT | U | W | P |
                          |         |   |   |    |    |    |   |---- P - Present
                          |         |   |   |    |    |    |-------- W - Writable
                          |         |   |   |    |    |------------- U - User
                          |         |   |   |    |----------------- WT - 1=Write-through, 0=Write-back
                          |         |   |   |---------------------- CD - Cache Disabled
                          |         |   |--------------------------- A - Accessed
                          |         |------------------------------- D - Dirty (0 in page directory)
                          |--------------------------------------- AVL - Available for system use

Page table and page directory entries are identical except for the D bits
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PTE_P&lt;/code&gt; indicates whether the PTE is present: if it is not set, a reference to the page causes a fault.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PTE_W&lt;/code&gt; controls whether instructions are allows to issue writes to the page; if not set, only reads and instructions fetches are allowed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PTE_U&lt;/code&gt; controls whether the user programs are allowed to use the page; if clear, only kernel is allowed to use the page.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The flags and all other page hardware related structures are defined in &lt;code&gt;mmu.h&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&#34;process-address-space&#34;&gt;Process address space&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://xiahua.blog/2019/01/29/2019-1-29-paging/&#34;&gt;The &lt;code&gt;entry.S&lt;/code&gt; provided a primal memory layout for the kernel&lt;/a&gt;. The two entries we created map virtual address &lt;code&gt;0:0x400000&lt;/code&gt; to physical address &lt;code&gt;0:0x400000&lt;/code&gt; as well as &lt;code&gt;KERNBASE:KERNBASE+0x400000&lt;/code&gt; to &lt;code&gt;0:0x400000&lt;/code&gt;. It is quite elaborately designed because the bootloader can only get access to physical addresses, whereas the kernel only uses virtual addresses. To prevent the &lt;code&gt;entry.S&lt;/code&gt; program breaking down, we assigned two different virtual address pages to the same physical address page. So the &lt;code&gt;jmp&lt;/code&gt; need to be an indirect jump.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;memory_layout.png&#34; alt=&#34;Figure 2-2. Layout of the virtual address space of a process and the layout of the physical address space. Note that if a machine has more than 2 Gbyte of physical memory, xv6 can use only the memory that fits between KERNBASE and 0xFE00000.&#34;&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define KERNBASE 0x80000000&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;But once we start the process, a more elaborate plan for describing process address space is required. And this turns to be the standard memory layout of the xv6 system. As we can see in the Figure 2-2.&lt;/p&gt;
&lt;h2 id=&#34;0kernbase&#34;&gt;0:KERNBASE&lt;/h2&gt;
&lt;p&gt;This area which addressed up to 2 gigabytes is reserved for the user process. That means one process can use 2 gigabytes of memory for the most. The structure of this area is familiar to the most programmers, including user text, user data, user stack, etc. The user programs use
them to do tasks on computer.&lt;/p&gt;
&lt;p&gt;This area is not mapped to physical memory at first because the entries are dynamically created, which means only when the program needs to use memory, the corresponding entries are created by kernel and linking the virtual pages with vacant physical pages. At first, there is no process being, so there is no entry in this area.&lt;/p&gt;
&lt;h2 id=&#34;kernbase0xffffffff&#34;&gt;KERNBASE:0xFFFFFFFF&lt;/h2&gt;
&lt;p&gt;Above &lt;code&gt;KERNBASE&lt;/code&gt; sits the kernel. And in this area, entries are all created with a simple mapping rule, which shown in &lt;code&gt;memlayout.h&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define V2P_WO(x) ((x) - KERNBASE)    &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// same as V2P, but without casts
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;That means, in this area, virtual pages and physical pages are 1:1 mapped except for an offset &lt;code&gt;KERNBASE&lt;/code&gt;. Why?&lt;/p&gt;
&lt;p&gt;The advantage of this is that the kernel can manipulate the physical memory easily. The kernal can see the whole world including all processes&amp;rsquo; page tables.&lt;/p&gt;
&lt;p&gt;Xv6 does not set the PTE_U flag in the PTEs above KERNBASE, so only the kernel can use them.&lt;/p&gt;
&lt;p&gt;Having every process’s page table contain mappings for both user memory and the entire kernel is convenient when switching from user code to kernel code during system calls and interrupts: such switches do not require page table switches. For the most part the kernel does not have its own page table; it is almost always borrowing some process’s page table.&lt;/p&gt;
&lt;p&gt;To review, xv6 ensures that each process can use only its own memory. And, each process sees its memory as having contiguous virtual addresses starting at zero, while the process’s physical memory can be non-contiguous. xv6 implements the first by setting the PTE_U bit only on PTEs of virtual addresses that refer to the process’s own memory. It implements the second using the ability of page tables to translate successive virtual addresses to whatever physical pages happen to be allocated to the process.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PHYSTOP&lt;/code&gt; in the physical memory show the maximum address of the physical address. However, the memory-mapped I/O devices occupy the addresses from &lt;code&gt;0xFE000000&lt;/code&gt; to &lt;code&gt;0xFFFFFFFF&lt;/code&gt;. Memory in between &lt;code&gt;PHYSTOP&lt;/code&gt; and &lt;code&gt;0xFE000000&lt;/code&gt; does not exist, and cannot be accessed.&lt;/p&gt;
&lt;h1 id=&#34;code-comments&#34;&gt;Code comments&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; calls &lt;code&gt;kvmalloc&lt;/code&gt; to create and switch to a page table with the mappings above &lt;code&gt;KERNBASE&lt;/code&gt; required for the kernel to run.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Do remember the &lt;code&gt;%esp&lt;/code&gt; pointer is well prepared right a moment ago. In &lt;code&gt;entry.S&lt;/code&gt; we allocated a per-process kernel stack (4096 bytes) in the kernel. So the next call will store address in the kernel stack, just like an process that just has been trapped in the kernel.&lt;/p&gt;
&lt;p&gt;Jump into &lt;code&gt;kvmalloc&lt;/code&gt;: &lt;code&gt;vm.c.138:145&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Allocate one page table for the machine for the kernel address
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// space for scheduler processes.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;kvmalloc&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)
{
  kpgdir &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; setupkvm();
  switchkvm();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;kpgdir&lt;/code&gt; is the directory of kernel program pages. It is defined above in &lt;code&gt;vm.c&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; uint pde_t;
pde_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;kpgdir;  &lt;span style=&#34;color:#75715e&#34;&gt;// for use in scheduler()
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As far we don&#39;t know what is a &lt;code&gt;scheduler&lt;/code&gt;, but we just know &lt;code&gt;kpgdir&lt;/code&gt; is an entry pointer and  it is global in kernel.&lt;/p&gt;
&lt;p&gt;Jump into &lt;code&gt;setupkvm&lt;/code&gt;, where the most work is done.&lt;code&gt;vm.c.117:136&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Set up kernel part of a page table.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;pde_t&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;setupkvm&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)
{
  pde_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pgdir;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; kmap &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;k;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;((pgdir &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (pde_t&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)kalloc()) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
  memset(pgdir, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, PGSIZE);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (P2V(PHYSTOP) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)DEVSPACE)
    panic(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;PHYSTOP too high&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(k &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; kmap; k &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;kmap[NELEM(kmap)]; k&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(mappages(pgdir, k&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;virt, k&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;phys_end &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; k&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;phys_start,
                (uint)k&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;phys_start, k&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;perm) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
      freevm(pgdir);
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; pgdir;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;first we allocate a 4096 bytes page in physical memory, and clear it totally.&lt;/p&gt;
&lt;p&gt;Then xv6 uses a static &lt;code&gt;struct kmap&lt;/code&gt; array to represent the layout of the kernel virtual pages: &lt;code&gt;vm.c.103:115&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// This table defines the kernel&amp;#39;s mappings, which are present in
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// every process&amp;#39;s page table.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; kmap {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;virt;
  uint phys_start;
  uint phys_end;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; perm;
} kmap[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
 { (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)KERNBASE, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,             EXTMEM,    PTE_W}, &lt;span style=&#34;color:#75715e&#34;&gt;// I/O space
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; { (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)KERNLINK, V2P(KERNLINK), V2P(data), &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;},     &lt;span style=&#34;color:#75715e&#34;&gt;// kern text+rodata
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; { (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)data,     V2P(data),     PHYSTOP,   PTE_W}, &lt;span style=&#34;color:#75715e&#34;&gt;// kern data+memory
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt; { (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)DEVSPACE, DEVSPACE,      &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,         PTE_W}, &lt;span style=&#34;color:#75715e&#34;&gt;// more devices
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The four entries in &lt;code&gt;kmap[]&lt;/code&gt; correspond to the 4 areas  above &lt;code&gt;KERNBASE&lt;/code&gt; in Figure 2.2.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mappages&lt;/code&gt; installs the translations that are described in &lt;code&gt;kmap&lt;/code&gt; array in page directory. &lt;code&gt;vm.c.57:80&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Create PTEs for virtual addresses starting at va that refer to
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// physical addresses starting at pa. va and size might not
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// be page-aligned.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;mappages&lt;/span&gt;(pde_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pgdir, &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;va, uint size, uint pa, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; perm)
{
  &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;a, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;last;
  pte_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pte;

  a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)PGROUNDDOWN((uint)va);
  last &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)PGROUNDDOWN(((uint)va) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; size &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(;;){
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;((pte &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; walkpgdir(pgdir, a, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pte &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; PTE_P)
      panic(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;remap&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pte &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pa &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; perm &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; PTE_P;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; last)
      &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
    a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PGSIZE;
    pa &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PGSIZE;
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In &lt;code&gt;mappages&lt;/code&gt;, we use &lt;code&gt;walkpgdir&lt;/code&gt; function to find the right page of given virtual address (needs to be rounded down to page borders). &lt;code&gt;vm.c.32:55&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Return the address of the PTE in page table pgdir
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// that corresponds to virtual address va.  If alloc!=0,
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// create any required page table pages.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; pte_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;walkpgdir&lt;/span&gt;(pde_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pgdir, &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;va, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; alloc)
{
  pde_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pde;
  pte_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pgtab;

  pde &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;pgdir[PDX(va)];  &lt;span style=&#34;color:#75715e&#34;&gt;// Get first 10 bits of va, and index page directory entry
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pde &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; PTE_P){ &lt;span style=&#34;color:#75715e&#34;&gt;// If the page directory entry present
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    pgtab &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (pte_t&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)P2V(PTE_ADDR(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pde)); &lt;span style=&#34;color:#75715e&#34;&gt;// Get the first 20 bits of *pde, and index page table
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;alloc &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; (pgtab &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (pte_t&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)kalloc()) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
      &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#75715e&#34;&gt;// Make sure all those PTE_P bits are zero.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    memset(pgtab, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, PGSIZE);
    &lt;span style=&#34;color:#75715e&#34;&gt;// The permissions here are overly generous, but they can
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// be further restricted by the permissions in the page table
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// entries, if necessary.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;pde &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; V2P(pgtab) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; PTE_P &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; PTE_W &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; PTE_U;
  }
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;pgtab[PTX(va)];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The interesting part is in &lt;code&gt;walkpgdir&lt;/code&gt;, it mimics the actions of the x86 paging hardware as it looks up the PTE for a virtual address. walkpgdir uses the upper 10 bits of the virtual address to find the page directory entry. If the page directory entry isn’t present, then the required page table page hasn’t yet been allocated; if the &lt;code&gt;alloc&lt;/code&gt; argument is set, walkpgdir allocates it and puts its physical address in the page directory. Finally it uses the next 10 bits of the virtual address to find the address of the PTE in the page table page.&lt;/p&gt;
&lt;h1 id=&#34;physical-memory-allocation&#34;&gt;Physical memory allocation&lt;/h1&gt;
&lt;p&gt;We said &lt;code&gt;kalloc&lt;/code&gt; again and again. When the xv6 works, we need to allocate and free physical memory dynamically.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The kernel must allocate and free physical memory at run-time for page tables, process user memory, kernel stacks, and pipe buffers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The way &lt;code&gt;kalloc&lt;/code&gt; manages memory does not involve with a lot of optimization here. There is a list of all the physical memory pages and &lt;code&gt;kalloc&lt;/code&gt; keeps track of them.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;There is a bootstrap problem: all of physical memory must be mapped in order for the allocator to initialize the free list, but creating a page table with those mappings involves allocating page-table pages. xv6 solves this problem by using a separate page allocator during entry, which allocates memory just after the end of the kernel’s data segment. This allocator does not support freeing and is limited by the 4 MB mapping in the &lt;code&gt;entrypgdir&lt;/code&gt;, but that is sufficient to allocate the first kernel page table.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;code-physical-memory-allocator&#34;&gt;Code: Physical memory allocator&lt;/h2&gt;
&lt;p&gt;This part is a little difficult to understand, xv6 use a &lt;em&gt;free list&lt;/em&gt; to implement allocation, which is the simplest way. &lt;code&gt;kalloc.c.79:95&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Allocate one 4096-byte page of physical memory.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Returns a pointer that the kernel can use.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Returns 0 if the memory cannot be allocated.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;kalloc&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)
{
  &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; run &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;r;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(kmem.use_lock)
    acquire(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;kmem.lock);
  r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; kmem.freelist;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(r)
    kmem.freelist &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;next;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(kmem.use_lock)
    release(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;kmem.lock);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)r;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Free list strategy does not have the best allocation performance, however it is the simplest way.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The function main calls &lt;code&gt;kinit1&lt;/code&gt; and &lt;code&gt;kinit2&lt;/code&gt; to initialize the allocator. The reason for having two calls is that for much of main one cannot use locks or memory above 4 megabytes. The call to &lt;code&gt;kinit1&lt;/code&gt; sets up for lock-less allocation in the first 4 megabytes, and the call to kinit2 enables locking and arranges for more memory to be allocatable. main ought to determine how much physical memory is available, but this turns out to be difficult on the x86. Instead it assumes that the machine has 224 megabytes (PHYSTOP) of physical memory, and uses all the memory between the end of the kernel and &lt;code&gt;PHYSTOP&lt;/code&gt; as the initial pool of free memory. &lt;code&gt;kinit1&lt;/code&gt; and &lt;code&gt;kinit2&lt;/code&gt; call &lt;code&gt;freerange&lt;/code&gt; to add memory to the free list via per-page calls to &lt;code&gt;kfree&lt;/code&gt;. A PTE can only refer to a physical address that is aligned on a 4096-byte boundary (is a multiple of 4096), so &lt;code&gt;freerange&lt;/code&gt; uses &lt;code&gt;PGROUNDUP&lt;/code&gt; to ensure that it frees only aligned physical addresses. The allocator starts with no memory; these calls to &lt;code&gt;kfree&lt;/code&gt; give it some to manage.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;kalloc.c.26:44&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Initialization happens in two phases.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 1. main() calls kinit1() while still using entrypgdir to place just
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// the pages mapped by entrypgdir on free list.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 2. main() calls kinit2() with the rest of the physical pages
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// after installing a full page table that maps them on all cores.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;kinit1&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;vstart, &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;vend)
{
  initlock(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;kmem.lock, &lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;kmem&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
  kmem.use_lock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
  freerange(vstart, vend);
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;kinit2&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;vstart, &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;vend)
{
  freerange(vstart, vend);
  kmem.use_lock &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The function &lt;code&gt;kfree&lt;/code&gt; begins by setting every byte in the memory being freed
to the value 1. This will cause code that uses memory after freeing it (uses ‘‘dangling
references’’) to read garbage instead of the old valid contents; hopefully that will cause
such code to break faster. &lt;code&gt;kalloc.c.54:77&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//PAGEBREAK: 21
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Free the page of physical memory pointed at by v,
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// which normally should have been returned by a
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// call to kalloc().  (The exception is when
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// initializing the allocator; see kinit above.)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;kfree&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;v)
{
  &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; run &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;r;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;((uint)v &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; PGSIZE &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; v &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; end &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; V2P(v) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PHYSTOP)
    panic(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;kfree&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);

  &lt;span style=&#34;color:#75715e&#34;&gt;// Fill with junk to catch dangling refs.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  memset(v, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, PGSIZE);

  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(kmem.use_lock)
    acquire(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;kmem.lock);
  r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; run&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)v;
  r&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; kmem.freelist;
  kmem.freelist &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(kmem.use_lock)
    release(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;kmem.lock);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;user-address-space&#34;&gt;User address space&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;user.png&#34; alt=&#34;Figure 2-3. Memory layout of a user process with its initial stack.&#34;&gt;&lt;/p&gt;
&lt;p&gt;The program text and data segment start at virtual address 0 and end with a guard page. The guard page is not mapped so when the stack runs out, the hardware will throw an exception.&lt;/p&gt;
&lt;p&gt;The initial content of stack is created by &lt;code&gt;exec&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&#34;code-sbrk&#34;&gt;Code: sbrk&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;sbrk&lt;/code&gt; is the system call for a process to shrink or grow its memory. The system call is implemented by the function &lt;code&gt;growproc&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is postive, &lt;code&gt;growproc&lt;/code&gt; allocates one or more physical pages and maps them at the top of the process’s address space. If &lt;code&gt;n&lt;/code&gt; is negative, &lt;code&gt;growproc&lt;/code&gt; unmaps one or more pages from the process’s address space and frees the corresponding physical pages. To make these changes, xv6 modifies the process’s page table. The process’s page table is stored in memory, and so the kernel can update the table with ordinary assignment statements, which is what &lt;code&gt;allocuvm&lt;/code&gt; and &lt;code&gt;deallocuvm&lt;/code&gt; do.&lt;/p&gt;
&lt;p&gt;The x86 hardware caches page table entries in a Translation Lookaside Buffer (TLB), and when xv6 changes the page tables, it must invalidate the cached entries. If it didn’t invalidate the cached entries, then at some point later the TLB might use an old mapping, pointing to a physical page that in the mean time has been allocated to another process, and as a result, a process might be able to scribble on some other process’s memory. Xv6 invalidates stale cached entries, by reloading &lt;code&gt;cr3&lt;/code&gt;, the register that holds the address of the current page table.&lt;/p&gt;
&lt;h1 id=&#34;code-exec&#34;&gt;Code: exec&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;exec&lt;/code&gt; allocates a new page table with no user mappings with &lt;code&gt;setupkvm&lt;/code&gt;, allocates memory for each ELF segment with &lt;code&gt;allocuvm&lt;/code&gt;, and loads each segment into
memory with &lt;code&gt;loaduvm&lt;/code&gt;. &lt;code&gt;allocuvm&lt;/code&gt; checks that the virtual addresses requested is
below &lt;code&gt;KERNBASE&lt;/code&gt;. &lt;code&gt;loaduvm&lt;/code&gt; uses &lt;code&gt;walkpgdir&lt;/code&gt; to find the physical address of the allocated memory at which to write each page of the ELF segment, and &lt;code&gt;readi&lt;/code&gt; to read
from the file.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;During the preparation of the new memory image, if exec detects an error like an invalid program segment, it jumps to the label bad, frees the new image, and returns –1. Exec must wait to free the old image until it is sure that the system call will succeed: if the old image is gone, the system call cannot return –1 to it. The only error cases in exec happen during the creation of the image. Once the image is complete, exec can install the new image (6701) and free the old one (6702). Finally, exec returns 0.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;real-world&#34;&gt;Real World&lt;/h1&gt;
&lt;p&gt;The following content come directly from xv6 textbook, which is worth reading.&lt;/p&gt;
&lt;p&gt;Like most operating systems, xv6 uses the paging hardware for memory protection and mapping. Most operating systems use x86’s 64-bit paging hardware (which has 3 levels of translation). 64-bit address spaces allow for a less restrictive memory layout than xv6’s; for example, it would be easy to remove xv6’s limit of 2 gigabytes for physical memory. Most operating systems make far more sophisticated use of paging than xv6; for example, xv6 lacks demand paging from disk, copy-on-write fork, shared memory, lazily-allocated pages, and automatically extending stacks. The x86 supports address translation using segmentation (see Appendix B), but xv6 uses segments only for the common trick of implementing per-cpu variables such as proc that are at a fixed address but have different values on different CPUs (see seginit). Implementations of per-CPU (or per-thread) storage on non-segment architectures would dedicate a register to holding a pointer to the per-CPU data area, but the x86 has so few general registers that the extra effort required to use segmentation is worthwhile.&lt;/p&gt;
&lt;p&gt;Xv6 maps the kernel in the address space of each user process but sets it up so that the kernel part of the address space is inaccessible when the processor is in user mode. This setup is convenient because after a process switches from user space to kernel space, the kernel can easily access user memory by reading memory locations directly. It is probably better for security, however, to have a separate page table for the kernel and switch to that page table when entering the kernel from user mode, so that the kernel and user processes are more separated from each other. This design, for example, would help mitigating side-channels that are exposed by the Meltdown vulnerability and that allow a user process to read arbitrary kernel memory.&lt;/p&gt;
&lt;p&gt;On machines with lots of memory it might make sense to use the x86’s 4-megabytes ‘‘super pages.’’ Small pages make sense when physical memory is small, to allow allocation and page-out to disk with fine granularity. For example, if a program uses only 8 kilobytes of memory, giving it a 4 megabytes physical page is wasteful. Larger pages make sense on machines with lots of RAM, and may reduce overhead for page-table manipulation. Xv6 uses super pages in one place: the initial page table. The array initialization sets two of the 1024 PDEs, at indices zero and 512 (&lt;code&gt;KERNBASE&amp;gt;&amp;gt;PDXSHIFT&lt;/code&gt;), leaving the other PDEs zero. Xv6 sets the PTE_PS bit in these two PDEs to mark them as super pages. The kernel also tells the paging hardware to allow super pages by setting the &lt;code&gt;CR_PSE&lt;/code&gt; bit (Page Size Extension) in &lt;code&gt;%cr4&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Xv6 should determine the actual RAM configuration, instead of assuming 224 MB. On the x86, there are at least three common algorithms: the first is to probe the physical address space looking for regions that behave like memory, preserving the values written to them; the second is to read the number of kilobytes of memory out of a known 16-bit location in the PC’s non-volatile RAM; and the third is to look in BIOS memory for a memory layout table left as part of the multiprocessor tables. Reading the memory layout table is complicated.&lt;/p&gt;
&lt;p&gt;Memory allocation was a hot topic a long time ago, the basic problems being efficient use of limited memory and preparing for unknown future requests; see Knuth. Today people care more about speed than space-efficiency. In addition, a more elaborate kernel would likely allocate many different sizes of small blocks, rather than (as in xv6) just 4096-byte blocks; a real kernel allocator would need to handle small allocations as well as large ones.&lt;/p&gt;</description>
    </item>
    <item>
      <title>xv6 Chapter 4 - Creating the First Process</title>
      <link>https://xiahualiu.github.io/posts/2019-02-03-xv6-first-process/</link>
      <pubDate>Sun, 03 Feb 2019 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2019-02-03-xv6-first-process/</guid>
      <description>&lt;p&gt;There goes the main part of xv6. Xv6 souce code provided a really clear view of each component of the kernel. All parts are shown below: &lt;code&gt;main.c:14-38&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;In this chapter, we will go through the sub-function &lt;code&gt;userinit&lt;/code&gt;, in which we initialize the memory for a user process, and create the first process.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Bootstrap processor starts running C code here.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Allocate a real stack and switch to it, first
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// doing some setup required for memory allocator to work.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)
{
  kinit1(end, P2V(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;)); &lt;span style=&#34;color:#75715e&#34;&gt;// phys page allocator
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  kvmalloc();      &lt;span style=&#34;color:#75715e&#34;&gt;// kernel page table
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  mpinit();        &lt;span style=&#34;color:#75715e&#34;&gt;// detect other processors
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  lapicinit();     &lt;span style=&#34;color:#75715e&#34;&gt;// interrupt controller
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  seginit();       &lt;span style=&#34;color:#75715e&#34;&gt;// segment descriptors
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  picinit();       &lt;span style=&#34;color:#75715e&#34;&gt;// disable pic
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  ioapicinit();    &lt;span style=&#34;color:#75715e&#34;&gt;// another interrupt controller
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  consoleinit();   &lt;span style=&#34;color:#75715e&#34;&gt;// console hardware
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  uartinit();      &lt;span style=&#34;color:#75715e&#34;&gt;// serial port
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  pinit();         &lt;span style=&#34;color:#75715e&#34;&gt;// process table
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  tvinit();        &lt;span style=&#34;color:#75715e&#34;&gt;// trap vectors
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  binit();         &lt;span style=&#34;color:#75715e&#34;&gt;// buffer cache
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  fileinit();      &lt;span style=&#34;color:#75715e&#34;&gt;// file table
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  ideinit();       &lt;span style=&#34;color:#75715e&#34;&gt;// disk 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  startothers();   &lt;span style=&#34;color:#75715e&#34;&gt;// start other processors
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  kinit2(P2V(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1024&lt;/span&gt;), P2V(PHYSTOP)); &lt;span style=&#34;color:#75715e&#34;&gt;// must come after startothers()
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  userinit();      &lt;span style=&#34;color:#75715e&#34;&gt;// first user process
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  mpmain();        &lt;span style=&#34;color:#75715e&#34;&gt;// finish this processor&amp;#39;s setup
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;userinit&lt;/code&gt;&#39;s first action is to call &lt;code&gt;allocproc&lt;/code&gt;. Go to the definition of it, we can see &lt;code&gt;allocproc&lt;/code&gt; do several things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;allocating a slot (&lt;code&gt;struct proc&lt;/code&gt;) in process table. &lt;code&gt;allocproc&lt;/code&gt; scans the proc table for a slot with state &lt;code&gt;UNUSED&lt;/code&gt;. &lt;code&gt;proc.c:69-83&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Look in the process table for an UNUSED proc.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// If found, change state to EMBRYO and initialize
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// state required to run in the kernel.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Otherwise return 0.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; proc&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;allocproc&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)
{
  &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; proc &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;sp;

  acquire(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ptable.lock);

  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(p &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ptable.proc; p &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ptable.proc[NPROC]; p&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(p&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;state &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; UNUSED)
      &lt;span style=&#34;color:#66d9ef&#34;&gt;goto&lt;/span&gt; found;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;initializing the parts of process&#39;s state required for its kernel thread to execute. It sets the state to &lt;code&gt;EMBRYO&lt;/code&gt; to mark it as used and give the process a unique pid. &lt;code&gt;proc.c:88-92&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;found:
  p&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;state &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; EMBRYO;
  p&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;pid &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nextpid&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;;

  release(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ptable.lock);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;Next, it allocate a kernel stack for the process&#39;s kernel thread. If failed, labeled the &lt;code&gt;struct proc&lt;/code&gt; with &lt;code&gt;UNUSED&lt;/code&gt;, return 0. &lt;code&gt;proc.c:94-99&lt;/code&gt; (kernel thread is the thread when a process is trapped in kernel).&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// Allocate kernel stack.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;((p&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;kstack &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; kalloc()) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;){
    p&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;state &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; UNUSED;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
  }
  sp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; p&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;kstack &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; KSTACKSIZE;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here we meet a new function called &lt;code&gt;kalloc&lt;/code&gt;. Go to its definition, &lt;code&gt;kalloc.c:79-95&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Allocate one 4096-byte page of physical memory.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Returns a pointer that the kernel can use.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Returns 0 if the memory cannot be allocated.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;kalloc&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)
{
  &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; run &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;r;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(kmem.use_lock)
    acquire(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;kmem.lock);
  r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; kmem.freelist;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(r)
    kmem.freelist &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;next;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(kmem.use_lock)
    release(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;kmem.lock);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)r;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;kalloc&lt;/code&gt; is used to allocate one 4096-byte page physical memory. We can infer from the above usage that &lt;code&gt;kalloc&lt;/code&gt; return a pointer that can point to a stack space.&lt;/p&gt;
&lt;p&gt;In &lt;code&gt;allocproc&lt;/code&gt;, we assign &lt;code&gt;sp&lt;/code&gt; at the top of the kernel stack.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;kernel_stack.png&#34; alt=&#34;Figure 1-4. A new kernel stack&#34;&gt;&lt;/p&gt;
&lt;p&gt;Next &lt;code&gt;allocproc&lt;/code&gt; use &lt;code&gt;sp&lt;/code&gt; to form the stack like the picture above, and assign the various pointer like &lt;code&gt;p-&amp;gt;tf&lt;/code&gt; &lt;code&gt;p-&amp;gt;context&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What is trapframe and context? Well, trapframe is used for the code to return from the kernel back to the process&#39;s user code. All the registers and the porgram counter value (in &lt;code&gt;%eip&lt;/code&gt;) are freezed before entering kernel and stored in trapframe through trap entry code. After exiting, all the registers are restored and the processor executes from the freezed program counter value. Then exit process is in &lt;code&gt;trapret&lt;/code&gt; function. &lt;code&gt;trapasm.S:23-32&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;The trapframe structure is defined in &lt;code&gt;x86.h:148-183&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Layout of the trap frame built on the stack by the
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// hardware and by trapasm.S, and passed to trap().
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; trapframe {
  &lt;span style=&#34;color:#75715e&#34;&gt;// registers as pushed by pusha
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  uint edi;
  uint esi;
  uint ebp;
  uint oesp;      &lt;span style=&#34;color:#75715e&#34;&gt;// useless &amp;amp; ignored
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  uint ebx;
  uint edx;
  uint ecx;
  uint eax;

  &lt;span style=&#34;color:#75715e&#34;&gt;// rest of trap frame
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  ushort gs;
  ushort padding1;
  ushort fs;
  ushort padding2;
  ushort es;
  ushort padding3;
  ushort ds;
  ushort padding4;
  uint trapno;

  &lt;span style=&#34;color:#75715e&#34;&gt;// below here defined by x86 hardware
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  uint err;
  uint eip;
  ushort cs;
  ushort padding5;
  uint eflags;

  &lt;span style=&#34;color:#75715e&#34;&gt;// below here only when crossing rings, such as from user to kernel
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  uint esp;
  ushort ss;
  ushort padding6;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The trapframe is built by hardware and by &lt;code&gt;trapasm.S&lt;/code&gt;: &lt;code&gt;trapasm.S:5-21&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;alltraps:
  # Build trap frame.
  pushl %ds
  pushl %es
  pushl %fs
  pushl %gs
  pushal
  
  # Set up data segments.
  movw $(SEG_KDATA&amp;lt;&amp;lt;3), %ax
  movw %ax, %ds
  movw %ax, %es

  # Call trap(tf), where tf=%esp
  pushl %esp
  call trap
  addl $4, %esp
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;trapret&lt;/code&gt; is also defined in &lt;code&gt;trapasm.S:23-32&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;  # Return falls through to trapret...
.globl trapret
trapret:
  popal
  popl %gs
  popl %fs
  popl %es
  popl %ds
  addl $0x8, %esp  # trapno and errcode
  iret
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The context works similar with trapframe, but it is used by context control system. The kernel switches processor from a process to another, so we also need to store the context frame into kernel stack for switching.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;allocproc&lt;/code&gt; function is called not only in &lt;code&gt;userinit&lt;/code&gt;, but also every time when a new process is forked. So it is delicately designed for both two conditions. It sets the context frame&#39;s &lt;code&gt;%eip&lt;/code&gt; value right at &lt;code&gt;forkret&lt;/code&gt;, so when the processor switches to this process, &lt;code&gt;forkret&lt;/code&gt; will be executed. Unlike &lt;code&gt;trapret&lt;/code&gt;, &lt;code&gt;forkret&lt;/code&gt; only does a simple thing, returning to whatever on the bottom of the kernel stack. At that time, the context frame has already poped, what at the stack bottom is the &lt;code&gt;trapret&lt;/code&gt; entrance. So the processor assumes the process just return from kernel, &lt;code&gt;trapret&lt;/code&gt; then restores the trapframe.&lt;/p&gt;
&lt;p&gt;However when the process was first allocated, we will deliberately set trapframe&#39;s &lt;code&gt;%eip&lt;/code&gt; to 0x0, so when &lt;code&gt;trapret&lt;/code&gt; returns, the user code will be executed at 0x0. &lt;code&gt;proc.c:101-106&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// Leave room for trap frame.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  sp &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;tf;
  p&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;tf &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; trapframe&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)sp;

  &lt;span style=&#34;color:#75715e&#34;&gt;// Set up new context to start executing at forkret,
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// which returns to trapret.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  sp &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;;
  &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;(uint&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)sp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (uint)trapret;

  sp &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;context;
  p&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;context &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; context&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)sp;
  memset(p&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;context, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;context);
  p&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;context&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;eip &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (uint)forkret;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; p;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When the &lt;code&gt;allocproc&lt;/code&gt; finish, we called &lt;code&gt;setupkvm&lt;/code&gt; to prepare the memory page for our first process code, and manipulate the trapframe to let it return right to the beginning of the user code. (&lt;code&gt;allocproc&lt;/code&gt; only modified the value of context and &lt;code&gt;forkret&lt;/code&gt; part) We will discuss &lt;code&gt;setupkvm&lt;/code&gt; in the near future, but at high level it creates a address space as the Figure 1-2.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;address_space.png&#34; alt=&#34;Figure 1-2. Layout of a virtual address space&#34;&gt;&lt;/p&gt;
&lt;p&gt;The initial contents of the first process’s user-space memory are the compiled form of &lt;code&gt;initcode.S&lt;/code&gt;; as part of the kernel build process, the linker embeds that binary in the kernel and defines two special symbols, &lt;code&gt;_binary_initcode_start&lt;/code&gt; and &lt;code&gt;_binary_initcode_size&lt;/code&gt;, indicating the location and size of the binary. Userinit copies that binary into the new process’s memory by calling inituvm, which allocates one page of physical memory, maps virtual address zero to that memory, and copies the binary to that page.&lt;/p&gt;
&lt;p&gt;Then userinit sets up the trap frame with the initial user mode state: the %cs register contains a segment selector for the &lt;code&gt;SEG_UCODE&lt;/code&gt; segment running at privilege level &lt;code&gt;DPL_USER&lt;/code&gt; (i.e., user mode rather than kernel mode), and similarly &lt;code&gt;%ds&lt;/code&gt;, &lt;code&gt;%es&lt;/code&gt;, and &lt;code&gt;%ss&lt;/code&gt; use &lt;code&gt;SEG_UDATA&lt;/code&gt; with privilege &lt;code&gt;DPL_USER&lt;/code&gt;. The &lt;code&gt;%eflags&lt;/code&gt; &lt;code&gt;FL_IF&lt;/code&gt; bit is set to allow hardware interrupts; we will re-examine this in Chapter 3.&lt;/p&gt;
&lt;p&gt;The stack pointer &lt;code&gt;%esp&lt;/code&gt; is set to the process’s largest valid virtual address, &lt;code&gt;p-&amp;gt;sz&lt;/code&gt;. The instruction pointer is set to the entry point for the initcode, address 0. The function userinit sets &lt;code&gt;p-&amp;gt;name&lt;/code&gt; to initcode mainly for debugging. Setting &lt;code&gt;p-&amp;gt;cwd&lt;/code&gt; sets the process’s current working directory; we will examine namei in detail in Chapter 6.&lt;/p&gt;
&lt;p&gt;Once the process is initialized, userinit marks it available for scheduling by setting &lt;code&gt;p-&amp;gt;state&lt;/code&gt; to &lt;code&gt;RUNNABLE&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>xv6 Chapter 3 - Turning on Paging</title>
      <link>https://xiahualiu.github.io/posts/2019-01-29-paging/</link>
      <pubDate>Tue, 29 Jan 2019 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2019-01-29-paging/</guid>
      <description>&lt;p&gt;In the last post, we discussed about the C code part of the boot loader, namely &lt;code&gt;bootmain.c&lt;/code&gt;. It read 4096 bytes data from the beginning of the disk second sector into the physical address &lt;code&gt;0x10000&lt;/code&gt; then parsed the elf file header by a &lt;code&gt;struct elf&lt;/code&gt;, read specified fields of &lt;code&gt;struct elf&lt;/code&gt; in order to validate elf file and acquire information about the program table. After that our boot loader fetched every corresponding elf body segment (e.g. .text .data) defined by each entry in the program header table and placed them in the written physical address &lt;code&gt;p_addr&lt;/code&gt; By the end of boot loader it called &lt;code&gt;p-&amp;gt;entry&lt;/code&gt; which is the entry of the elf file, proceeding to the next program, which is &lt;code&gt;main&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The most difficult part of the boot loader is knowing how to parse the elf file structure. I assumed the reader was familiar with the virtual memory layout for a typical executable program, including what &lt;code&gt;.text&lt;/code&gt; &lt;code&gt;.data&lt;/code&gt; &lt;code&gt;.bss&lt;/code&gt; etc. are and where they locate at. If you cannot really catch that please refer to &lt;em&gt;CSAPP&lt;/em&gt; or other books. Back to the topic, an elf contains useful information that is necessary for an elf loader so our boot loader has actually performed a simple loading process in few lines.&lt;/p&gt;
&lt;p&gt;Here to remind you of the action sequence of the boot, we did not directly come from the very beginning to our boot loader program, because the machine need a tiny program (512 bytes), which was automatically imported from first sector on the disk since powered-up, that fact means the BIOS probably has the similar boot loader like bootmain.c, however this sneaky boot loader is stored in the mother-board’s rom other than disks and we cannot touch this pre-prepared boot loader.&lt;/p&gt;
&lt;p&gt;When the BIOS boot loader finished its duty, it gave the power to our 512-byte boot program, our tiny boot program contains code that tweaked our cpu settings and the boot loader. In a word the solidified BIOS boot loader loaded our boot program, there are two boot programs in different places and work in sequence. Make sure you are clear before continue.&lt;/p&gt;
&lt;h1 id=&#34;abstract&#34;&gt;Abstract&lt;/h1&gt;
&lt;p&gt;In this chapter, the kernel has already been in the memory, but where is it? The kernel has been compiled and linked so that it expects to find itself at virtual addresses starting at &lt;code&gt;0x80100000&lt;/code&gt;. Thus, function call instructions must mention destination addresses that look like &lt;code&gt;0x801xxxxx&lt;/code&gt;; you can see examples in &lt;code&gt;kernel.asm&lt;/code&gt;. This address is configured in &lt;code&gt;kernel.ld&lt;/code&gt; (9311). &lt;code&gt;0x80100000&lt;/code&gt; is a relatively high address, towards the end of the 32-bit address space;  further chapters will explain the reasons for this choice. There may not be any physical memory at such a high address. Once the kernel starts executing, it will set up the paging hardware to map virtual addresses starting at &lt;code&gt;0x80100000&lt;/code&gt; to physical addresses starting at &lt;code&gt;0x00100000&lt;/code&gt;; the kernel assumes that there is physical memory at this lower address. At this point in the boot process, however, paging is not enabled. Instead, kernel.ld specifies that the ELF p_addr start at &lt;code&gt;0x00100000&lt;/code&gt;, which causes the boot loader to copy the kernel to the low physical addresses to which the paging hardware will eventually point.&lt;/p&gt;
&lt;p&gt;That is quite a big load of words, simply speaking:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The kernel’s entry is placed at physical address &lt;code&gt;0x00100000&lt;/code&gt;, because address &lt;code&gt;0xa00000&lt;/code&gt; to &lt;code&gt;0x100000&lt;/code&gt; is reserved by IO devices. (Plus we assigned address &lt;code&gt;0x0&lt;/code&gt; to &lt;code&gt;0x7c00&lt;/code&gt; used for stack in &lt;code&gt;bootasm.S&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;The kernel entry cannot be called directly since paging hardware is not enabled yet, and kernel uses virtual address for its functions. You can enter the kernel by &lt;code&gt;jmp&lt;/code&gt; instruction but once we were in the kernel, all functions, variables cannot be found.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Conclusion&lt;/strong&gt;: We need a transition program to set up the virtual map for the kernel. It is linked with the &lt;code&gt;main.c&lt;/code&gt; program, and where &lt;code&gt;p-&amp;gt;entry&lt;/code&gt; fell.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;turn-on-paging&#34;&gt;Turn on paging&lt;/h1&gt;
&lt;p&gt;We need to do 3 things to turn on paging:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Set the size for the virtual memory page, which also regarded as page size. By convention, it should be either 4K bytes or 4M bytes. Here we chose 4M bytes.&lt;/li&gt;
&lt;li&gt;We need to create the page table entries (PTE) for every page, currently we only need the one for &lt;code&gt;0x80100000&lt;/code&gt; (We must sure that the elf is smaller than 4M) and 0x0 the address where the &lt;code&gt;%eip&lt;/code&gt; is pointing at now. With 4M page, that number is 512 and 0 respectively.&lt;/li&gt;
&lt;li&gt;Set the entry for page table directory in &lt;code&gt;%cr3&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Turn on paging, by setting a specified bit in &lt;code&gt;%cr0&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The kernel’s physical address (&lt;code&gt;p_addr&lt;/code&gt;) is used for our boot loader, it tells to allocate the first program segment at physical address &lt;code&gt;0x10000&lt;/code&gt;. However, from the kernel’s perspective, it assumes itself locates at &lt;code&gt;v_addr&lt;/code&gt; &lt;code&gt;0x80100000&lt;/code&gt;. So we need to cast the virtual address &lt;code&gt;0x80000000&lt;/code&gt; to the physical address &lt;code&gt;0x0&lt;/code&gt;, thus entry 512 has the base address &lt;code&gt;0x0&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here is a simple illustration of how mmu interprets virtual address:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Read &lt;code&gt;v_addr&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Calculate the index of PTE implicitly, because we chose 4M page size so the value of the segment register is &lt;code&gt;v_addr/4M&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Fetch page table entry 512. The address was calculated by step 2.&lt;/li&gt;
&lt;li&gt;Check whether the page is missing, and validate the operation (i.e writing to a read-only page is illegal).&lt;/li&gt;
&lt;li&gt;Add up offset and the base address of the page, return the result physical address to cpu. (In some processor like later the Core i7, there are several levels of PTE so we need more steps to get the physical address.)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;In the transition program, we also created the entry 0 for our current program, it points to &lt;code&gt;0x0&lt;/code&gt;, where we are now and the same address as entry 512 does, otherwise the program will crash after we turn on the paging function in &lt;code&gt;%cr0&lt;/code&gt;, because cpu cannot find the next instruction.&lt;/p&gt;
&lt;p&gt;When we finished, we needed an indirect jump (fill the &lt;code&gt;%eip&lt;/code&gt; by hand), since the assembler would otherwise generate the PC-related version of jump, and the result address is a low address, which is invalid in virtual address system.&lt;/p&gt;
&lt;h1 id=&#34;code-notes&#34;&gt;Code notes&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;entry.S&lt;/code&gt; was linked with &lt;code&gt;main.c&lt;/code&gt;, so the elf contained them both. Let&#39;s first read the header notes of &lt;code&gt;entry.S&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;entry.S:1-3&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;# The xv6 kernel starts executing in this file. This file is linked with
# the kernel C code, so it can refer to kernel symbols such as main().
# The boot block (bootasm.S and bootmain.c) jumps to entry below.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;See? And there is the &lt;code&gt;_start&lt;/code&gt; convention: &lt;code&gt;entry.S:37-41&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;# By convention, the _start symbol specifies the ELF entry point.
# Since we havent set up virtual memory yet, our entry point is
# the physical address of entry.
.globl _start
_start = V2P_WO(entry)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;_start&lt;/code&gt; labeled the first function of the elf when executed, because &lt;code&gt;entry.S&lt;/code&gt; and &lt;code&gt;main.c&lt;/code&gt; were linked together, They shared the same entry point. The linker we used assumed all the segments locate at virtual addresses starting from &lt;code&gt;0x80100000&lt;/code&gt; which includes &lt;code&gt;entry&lt;/code&gt;. That is why we need to use macro &lt;code&gt;V2P_WO()&lt;/code&gt; to change &lt;code&gt;entry&lt;/code&gt; address. Otherwise, in the last step: &lt;code&gt;entry()&lt;/code&gt; cannot be executed, since the  function pointer &lt;code&gt;p-&amp;gt;entry&lt;/code&gt; points to a high virtual address, and at that time we have not turned on paging yet.&lt;/p&gt;
&lt;p&gt;After called &lt;code&gt;p-&amp;gt;entry&lt;/code&gt;, we came here: &lt;code&gt;entry.S:43-56&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;# Entering xv6 on boot processor, with paging off.
.globl entry
entry:
  # Turn on page size extension for 4Mbyte pages
  movl    %cr4, %eax
  orl     $(CR4_PSE), %eax
  movl    %eax, %cr4
  # Set page directory
  movl    $(V2P_WO(entrypgdir)), %eax
  movl    %eax, %cr3
  # Turn on paging.
  movl    %cr0, %eax
  orl     $(CR0_PG|CR0_WP), %eax
  movl    %eax, %cr0
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A series of operations to turn on paging. Please note that &lt;code&gt;entrypgdir&lt;/code&gt; must be physical address, it is required by MMU and the linker created the virtual version. Since different CPUs have different paging config registers, so I do not want to explain in details about &lt;code&gt;%cr0&lt;/code&gt; and &lt;code&gt;%cr3&lt;/code&gt; &lt;code&gt;%cr4&lt;/code&gt; registers. When you really need to write a OS, you have to refer to the corresponding processor manual. Different generations of CPU differ from each other on paging registers.&lt;/p&gt;
&lt;p&gt;However, please know the &lt;code&gt;entrypgdir&lt;/code&gt; structure is defined in &lt;code&gt;main.c:97-108&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// The boot page table used in entry.S and entryother.S.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Page directories (and page tables) must start on page boundaries,
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// hence the __aligned__ attribute.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// PTE_PS in a page directory entry enables 4Mbyte pages.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
__attribute__((__aligned__(PGSIZE)))
pde_t entrypgdir[NPDENTRIES] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
  &lt;span style=&#34;color:#75715e&#34;&gt;// Map VA&amp;#39;s [0, 4MB) to PA&amp;#39;s [0, 4MB)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; PTE_P &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; PTE_W &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; PTE_PS,
  &lt;span style=&#34;color:#75715e&#34;&gt;// Map VA&amp;#39;s [KERNBASE, KERNBASE+4MB) to PA&amp;#39;s [0, 4MB)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  [KERNBASE&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PDXSHIFT] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; PTE_P &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; PTE_W &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; PTE_PS,
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As I said above, the page table contains two entries, one for &lt;code&gt;0x0&lt;/code&gt; and one for &lt;code&gt;0x80000000&lt;/code&gt; and the page table is strictly aligned, it is a global variable, so it can be found in the elf&#39;s &lt;code&gt;.data&lt;/code&gt; segment.&lt;/p&gt;
&lt;p&gt;Next, prepare for calling &lt;code&gt;main()&lt;/code&gt;: &lt;code&gt;entry.S:58-68&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;  # Set up the stack pointer.
  movl $(stack + KSTACKSIZE), %esp

  # Jump to main(), and switch to executing at
  # high addresses. The indirect call is needed because
  # the assembler produces a PC-relative instruction
  # for a direct jump.
  mov $main, %eax
  jmp *%eax

.comm stack, KSTACKSIZE
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When it comes to call a function, always remember to &lt;strong&gt;make sure the stack is available now&lt;/strong&gt;, we have changed address configuration so we want to change stack pointer.&lt;/p&gt;
&lt;p&gt;The final line has a strange command &lt;code&gt;.comm&lt;/code&gt;. Here is its usage:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt; .comm name, size, alignment
 # The .comm directive allocates storage in the data section. 
 # The storage is referenced by the identifier name. Size is 
 # measured in bytes and must be a positive integer. Name 
 # cannot be predefined. Alignment is optional. If alignment 
 # is specified, the address of name is aligned to a multiple 
 # of alignment.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;.comm stack, KSTACKSIZE&lt;/code&gt; allocated a storage &lt;code&gt;stack&lt;/code&gt; of size &lt;code&gt;KSTACKSIZE&lt;/code&gt; in &lt;code&gt;.data&lt;/code&gt; segment and can be linked by others (just like global variables), &lt;code&gt;KSTACKSIZE&lt;/code&gt; are defined in &lt;code&gt;param.h:2&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define KSTACKSIZE 4096  &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// size of per-process kernel stack
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Per-process kernel stack allows multiple processes trapped in the kernel at the same time. These stacks seem to be isolated, kernel knows which stack is for which process when switches to different processes.&lt;/p&gt;
&lt;p&gt;In the end, we use an indirect jump to transfer the processor to &lt;code&gt;main&lt;/code&gt; in &lt;code&gt;main.c&lt;/code&gt;.&lt;/p&gt;
&lt;h1 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;In this chapter, we talked about the process of turning on paging in xv6, the code implementation can be found in entry.S file. The code is pretty simple but has a lot important things in how to handle details of the P2V transition including indirect jump, and the PTE 0.&lt;/p&gt;
&lt;p&gt;In the next post we will discuss the details of the creating the first process in xv6.&lt;/p&gt;</description>
    </item>
    <item>
      <title>xv6 Chapter 1 - Bootstrap</title>
      <link>https://xiahualiu.github.io/posts/2019-01-26-xv6-boot1/</link>
      <pubDate>Sat, 26 Jan 2019 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2019-01-26-xv6-boot1/</guid>
      <description>&lt;p&gt;The xv6 note collection is based on the textbook and source code provided by MIT class code 6.828,which also called the &lt;em&gt;xv6 a Unix-like operating system&lt;/em&gt;. All the materials including codes and scripts are under &lt;a href=&#34;https://mit-license.org/&#34;&gt;the MIT License&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This post is the first chapter in the collection, we will go through the basic knowledge of Intel 8088 processor and do the bootstrap work for xv6 kernel step by step.&lt;/p&gt;
&lt;p&gt;Xv6 provided official textbook &lt;a href=&#34;https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf&#34;&gt;xv6 book&lt;/a&gt; online to illustrate what the codes are trying to do. The text version of code can be downloaded here &lt;a href=&#34;https://pdos.csail.mit.edu/6.828/2018/xv6/xv6-rev11.pdf&#34;&gt;xv6 source&lt;/a&gt;.&lt;/p&gt;
&lt;h1 id=&#34;after-powering-up&#34;&gt;After powering up&lt;/h1&gt;
&lt;p&gt;After you powered up your processor, a small program would automatically executed. The program was not designed by us, instead it was burned in the rom. And it performed a very simple action, transferring the data on first sector of disk to the main memory address &lt;code&gt;0x7c00&lt;/code&gt; and jumped to that location. In order not to get confused about the boot loader in next chapter, we called the ex-factory boot loader &lt;em&gt;BIOS boot loader&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;After that, processor turned to our program, namely &lt;code&gt;bootasm.S&lt;/code&gt;. All the operations will performed in &lt;code&gt;bootasm.S&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Disable the BIOS interrupts&lt;/li&gt;
&lt;li&gt;Clear all segment registers including DS, ES, SS except CS, it can only be modified by &lt;code&gt;ljmp&lt;/code&gt; instruction.&lt;/li&gt;
&lt;li&gt;Open A20 Gate, make the 21st address line valid, or the 21st bit of address register will always be 0, the address is not consecutive.(It is also required by protected mode)&lt;/li&gt;
&lt;li&gt;Create GDT, here we choose GDT to be flat, the address is not changed and 1 to 1 mapped.&lt;/li&gt;
&lt;li&gt;Transform CPU from &lt;code&gt;Real Mode&lt;/code&gt; to &lt;code&gt;Protected Mode&lt;/code&gt;, enabling 32-bit addressing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We will go through them one by one in the following.&lt;/p&gt;
&lt;p&gt;First we need to know what BIOS had done before our program &lt;code&gt;bootasm.S:3-6&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;# Start the first CPU: switch to 32-bit protected mode, jump into C.
# The BIOS loads this code from the first sector of the hard disk into
# memory at physical address 0x7c00 and starts executing in real mode
# with %cs=0 %ip=7c00.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We know that our program entry is at &lt;code&gt;0x7c00&lt;/code&gt;, and &lt;code&gt;%cs&lt;/code&gt; had been cleared . In the initial real mode, the CPU can only address in 16 bit mode.&lt;/p&gt;
&lt;h2 id=&#34;disable-bios-interrupts&#34;&gt;Disable BIOS interrupts&lt;/h2&gt;
&lt;p&gt;Let us focus on &lt;code&gt;bootasm.S:13&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;  cli                         # Disable interrupts
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is a convention for the programmer to disable BIOS interrupts, because in this period, the interrupt handlers are not available, so when an interrupt occurs, it will cause undefined behaviors.&lt;/p&gt;
&lt;p&gt;Please be advised about &lt;code&gt;.code16&lt;/code&gt;, it means until the next related symbols, the assembler will only generate 16-bit format machine code.&lt;/p&gt;
&lt;h2 id=&#34;clear-segment-registers&#34;&gt;Clear segment registers&lt;/h2&gt;
&lt;p&gt;Go to &lt;code&gt;bootasm.S:15-19&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;  # Zero data segment registers DS, ES, and SS.
  xorw    %ax,%ax             # Set %ax to zero
  movw    %ax,%ds             # -&amp;gt; Data Segment
  movw    %ax,%es             # -&amp;gt; Extra Segment
  movw    %ax,%ss             # -&amp;gt; Stack Segment
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These segment registers are all of 16-bit width, besides there is another segment register named &lt;code&gt;CS&lt;/code&gt;, it cannot be modified by &lt;code&gt;mov&lt;/code&gt; or other math and logic instructions. The default value for &lt;code&gt;CS&lt;/code&gt; is zero, so there is no need to clear &lt;code&gt;CS&lt;/code&gt; register. We will discuss &lt;code&gt;CS&lt;/code&gt; later in the article.&lt;/p&gt;
&lt;p&gt;The three registers contains different types of addresses and they are chosen implicitly by processor. For example, when the instruction being executed consists instruction address, like &lt;code&gt;jmp foo&lt;/code&gt; processor will automatically fetch the value from &lt;code&gt;%cs&lt;/code&gt; which is the address of &lt;code&gt;foo&lt;/code&gt;. If the processor met &lt;code&gt;push %ax&lt;/code&gt;, it will automatically choose &lt;code&gt;%ss&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%ds&lt;/code&gt; Data Segment Register.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%ss&lt;/code&gt; Stack Segment Register.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%cs&lt;/code&gt; Code Segment Register.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%es&lt;/code&gt; Extra Segment Register. Only used for duplicating and depositing value from other segment register.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The reason why called segment register is that, Intel processors use a special method to address variables in which the corresponding segment register is shifted to left 4 bits (equals x16) then added with a 16-bit offset register. This method allows the processor to do a 20-bit addressing with two 16-bit registers, however, it also caused another problem, putting forward the origin of A20 Gate.&lt;/p&gt;
&lt;h2 id=&#34;open-the-a20-gate&#34;&gt;Open the A20 Gate&lt;/h2&gt;
&lt;p&gt;As I said above, the final address that cpu fetches is calculated like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;final_address&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(seg_reg&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;offset_reg;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;What if we input &lt;code&gt;seg_reg=0xFFFF, offset_reg=0xFFFF&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;The result is &lt;code&gt;final_address=0x10FFEF&lt;/code&gt; which actually is a 21-bit value. Back to the days when Intel 8086 only had 20 address lines, the 21st bit was ignored.&lt;/p&gt;
&lt;p&gt;But after that Intel released processor with more than 20 address lines, however, Intel still wanted to make them backward compatible, so the 21st address line was ignored by default. IBM used a small tricks to solve this problem, it assigned a unused pin named A20 in the 8042 controller (PS/2 controller) to be the switch of 21st address line, that was, the origin of A20 Gate.&lt;/p&gt;
&lt;p&gt;What if we do not open the A20 Gate? Well, if we had an address like &lt;code&gt;0xFFFFFFFF&lt;/code&gt; which is longer than 20 bits, the 21st bit would always be 0, thus the memory space is not consecutive, we are only accessible to 0~1MB, 2~3MB, 4~5MB memory addresses. That was a definitely catastrophy for programmer. I have not try it, who knows lol.&lt;/p&gt;
&lt;p&gt;How to open A20 gate? The approach is simple, we just let the 2nd pin of 8042 controller output 1. But the operations are pretty complex, first we must know the mechanics of 8042 I/O.&lt;/p&gt;
&lt;p&gt;The related instructions can be found here &lt;code&gt;bootasm.S:21-37&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;  # Physical address line A20 is tied to zero so that the first PCs 
  # with 2 MB would run software that assumed 1 MB.  Undo that.
seta20.1:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.1

  movb    $0xd1,%al               # 0xd1 -&amp;gt; port 0x64
  outb    %al,$0x64

seta20.2:
  inb     $0x64,%al               # Wait for not busy
  testb   $0x2,%al
  jnz     seta20.2

  movb    $0xdf,%al               # 0xdf -&amp;gt; port 0x60
  outb    %al,$0x60
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Intel CPU controls 8042 through I/O ports. As we know, cpu is not only made of cores, there are also many peripheral controllers on chip like ethernet, usb, PCI, etc. The processor addresses them from &lt;code&gt;0x0&lt;/code&gt; to &lt;code&gt;0xFF&lt;/code&gt;. As for 8042, its I/O number is &lt;code&gt;0x60&lt;/code&gt; and &lt;code&gt;0x64&lt;/code&gt;.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;IO Port&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Access Type&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Purpose&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x60&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R/W&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Data Port&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Status Register&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;W&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Command Register&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;0x64&lt;/code&gt; port connects to different registers for different access types, which is pretty common in embedded system.&lt;/p&gt;
&lt;p&gt;The opening A20 gate contains following operations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wait for not busy, by checking the status register. Loop while busy.&lt;/li&gt;
&lt;li&gt;Send command to 0x64, indicating an incoming output.&lt;/li&gt;
&lt;li&gt;Wait for not busy, by checking the status register. Loop while busy.&lt;/li&gt;
&lt;li&gt;Send data to 0x60, output 1 on 2nd pin.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Details on &lt;a href=&#34;https://wiki.osdev.org/%228042%22_PS/2_Controller&#34;&gt;8042 Controller&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;From now on, we can make 21-bit addressing (up to 2MB). It is slightly better than 20-bit version (up to 1MB) however we want 32-bit addressing (up to 4GB) in the end.&lt;/p&gt;
&lt;h2 id=&#34;turn-on-32-bit-addressing&#34;&gt;Turn on 32-bit addressing&lt;/h2&gt;
&lt;p&gt;By default, when CPU is powered up, it ran in Real Mode, where we can only do 21-bit address. We can change it into Protected Mode, in which 32-bit addressing is available.&lt;/p&gt;
&lt;p&gt;But to transform cpu into Protected Mode, we must create a table called GDT. Every entry in GDT contains:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a 32-bit base address field&lt;/li&gt;
&lt;li&gt;a 20-bit limit field&lt;/li&gt;
&lt;li&gt;a 12-bit flag field&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What a GDT entry does? First, CPU no longer used segment registers to addressing anymore, instead, the segment registers are used as an index in GDT, each value from (0-65535) maps an entry in the table.&lt;/p&gt;
&lt;p&gt;CPU will fetch the 32-bit base address in the entry and add it with another register named &lt;code&gt;%eip&lt;/code&gt; which is familiar by most programmers. The result is a 32-bit address.&lt;/p&gt;
&lt;p&gt;Another advantage of using GDT is the high security, GDT is considered as the cpu&#39;s hardware mechanics to isolate the executable code from data if we set the flags in the flag field, it labels what memory is executable and cannot be modified, and what memory (i.e data) cannot be executed. It prevent the overflow attack from a hardware level.&lt;/p&gt;
&lt;p&gt;In x86 asm, GDT is loaded by &lt;code&gt;ldgt&lt;/code&gt; instruction, and GDT is defined in  &lt;code&gt;bootasm.S:78-87&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;# Bootstrap GDT
.p2align 2                                # force 4 byte alignment
gdt:
  SEG_NULLASM                             # null seg
  SEG_ASM(STA_X|STA_R, 0x0, 0xffffffff)   # code seg
  SEG_ASM(STA_W, 0x0, 0xffffffff)         # data seg

gdtdesc:
  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1
  .long   gdt                             # address gdt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We fill three entries in GDT, they are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Null segment, this segment has no real function, but usually reserved for debug purpose.&lt;/li&gt;
&lt;li&gt;Code segment, labeled by the 12-bit flag. Base address is &lt;code&gt;0x00&lt;/code&gt;, maximum offset is &lt;code&gt;0xffffffff&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Data segment, labeled by the 12-bit flag. Base address is &lt;code&gt;0x00&lt;/code&gt;, maximum offset is &lt;code&gt;0xffffffff&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Per cpu data segment, I do not know nothing about it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Want to know more about GDT, please refer to &lt;a href=&#34;https://wiki.osdev.org/Global_Descriptor_Table&#34;&gt;Global Descriptor Table - OSDev Wiki&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;In the end, move 1 to &lt;code&gt;%cr0&lt;/code&gt; to open Protected Mode, we need to reload &lt;code&gt;%cs&lt;/code&gt; and &lt;code&gt;%eip&lt;/code&gt; registers. The only way to modify &lt;code&gt;%cs&lt;/code&gt; is by &lt;code&gt;ljmp&lt;/code&gt; to the other place, here we jumped to &lt;code&gt;start32&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Next, reload DS, ES, SS. &lt;code&gt;bootasm.S:54-62&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;start32:
  # Set up the protected-mode data segment registers
  movw    $(SEG_KDATA&amp;lt;&amp;lt;3), %ax    # Our data segment selector
  movw    %ax, %ds                # -&amp;gt; DS: Data Segment
  movw    %ax, %es                # -&amp;gt; ES: Extra Segment
  movw    %ax, %ss                # -&amp;gt; SS: Stack Segment
  movw    $0, %ax                 # Zero segments not ready for use
  movw    %ax, %fs                # -&amp;gt; FS
  movw    %ax, %gs                # -&amp;gt; GS
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here we successfully bootstrap our xv6 system, including turning on A20 gate, open Protected Mode. After these, we need to transfer the processor to &lt;code&gt;bootmain.c&lt;/code&gt; which is our boot loader program.&lt;/p&gt;
&lt;p&gt;Before we proceed, we need to check the &lt;code&gt;%esp&lt;/code&gt;, because we cannot have the stack pointer points to &lt;code&gt;0x0&lt;/code&gt; before calling, the stack grow from up to down, &lt;code&gt;0x0&lt;/code&gt; means everything pushed into the stack will be lost. Since our boot program starts at &lt;code&gt;0x7c00&lt;/code&gt;, we assigned &lt;code&gt;%esp&lt;/code&gt; to &lt;code&gt;0x7c00&lt;/code&gt;, it is ok because we do not need a lot space on stack, and it is proper to use space from &lt;code&gt;0x0000&lt;/code&gt; to &lt;code&gt;0x7c00&lt;/code&gt;. &lt;code&gt;bootasm.S:64-66&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-x86asm&#34; data-lang=&#34;x86asm&#34;&gt;  # Set up the stack pointer and call into C.
  movl    $start, %esp
  call    bootmain
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;review&#34;&gt;Review&lt;/h1&gt;
&lt;p&gt;We discussed about the hardware preparation for xv6, including:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Disable BIOS interrupts.&lt;/li&gt;
&lt;li&gt;Clear segment registers.&lt;/li&gt;
&lt;li&gt;Open A20 Gate.&lt;/li&gt;
&lt;li&gt;Create GDT.&lt;/li&gt;
&lt;li&gt;Transform CPU into Protected Mode&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;In the next chapter, we proceed to the boot loader program, and please know it is different from the BIOS one.&lt;/p&gt;</description>
    </item>
    <item>
      <title>xv6 Chapter 2 - Boot Loader</title>
      <link>https://xiahualiu.github.io/posts/2019-01-26-xv6-boot2/</link>
      <pubDate>Sat, 26 Jan 2019 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2019-01-26-xv6-boot2/</guid>
      <description>&lt;p&gt;This post is based on materials from MIT class code 6.828, namely xv6. In the &lt;a href=&#34;https://xiahua.blog/2019/01/25/2019-1-26-xv6-Boot1/&#34;&gt;last section&lt;/a&gt; we talked about the bootstrap for xv6, and after that we need to load the kernel into memory.&lt;/p&gt;
&lt;p&gt;Because the BIOS boot loader only loaded 512 bytes program on disk sector 1, we still need more program, to be read from disk, thus, we need a boot loader to call for this duty.&lt;/p&gt;
&lt;h1 id=&#34;what-is-a-boot-loader&#34;&gt;What is a boot loader&lt;/h1&gt;
&lt;p&gt;Boot loader do a simply task, transporting code from some place to main memory. In xv6, the boot loader read full elf of the kernel, then parsed the file, allocate different segments at different place in the memory. First thing, we need to know the elf file format that boot loader carried.&lt;/p&gt;
&lt;p&gt;Elf file consists a lot information that is not run by processor, including machine information, system information, and code segments. We can also check for this information to validate the elf file, whether it is executable.&lt;/p&gt;
&lt;h1 id=&#34;elf-file-structure&#34;&gt;ELF file structure&lt;/h1&gt;
&lt;p&gt;Elf files can be divided into two types, linkable elf files and executable elf files. They are of similar structure, except the second section, program header is optional in linkable elf and is necessary in executable elf.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;     Executable ELF
-----------------------
|     ELF header      |
-----------------------
|   Program header    | &amp;lt;-- *Optional in linkable ELF
|        table        |     *Necessary in executable ELF
-----------------------
|        .text        |
-----------------------
|        .data        |
-----------------------
|// .bss/.stab/etc. //|
-----------------------
|   Segment header    |
|        table        |
-----------------------
note: Program header table is called 
      Section header table in a linkable elf.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;ELF header&lt;/strong&gt; stores the information about this elf file, it starts at offset 0 in elf.
| Position (32 bit) | Value                                                 |
| :&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- | :&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;- |
| 0-3               | &lt;strong&gt;Magic number - 0x7F&lt;/strong&gt;, then &amp;lsquo;ELF&amp;rsquo; in ASCII          |
| 4                 | 1 = 32 bit, 2 = 64 bit                                |
| 5                 | 1 = little endian, 2 = big endian                     |
| 6                 | ELF Version                                           |
| 7                 | OS ABI - usually 0 for System V                       |
| 8-15              | Unused/padding                                        |
| 16-17             | 1 = relocatable, 2 = executable, 3 = shared, 4 = core |
| 18-19             | Instruction set - see table below                     |
| 20-23             | ELF Version                                           |
| 24-27             | Program entry position                                |
| 28-31             | Program header table position                         |
| 32-35             | Section header table position                         |
| 36-39             | Flags - architecture dependent; &lt;strong&gt;see note below&lt;/strong&gt;    |
| 40-41             | Header size                                           |
| 42-43             | &lt;strong&gt;Size of an entry in the program header table&lt;/strong&gt;      |
| 44-45             | &lt;strong&gt;Number of entries in the program header table&lt;/strong&gt;     |
| 46-47             | Size of an entry in the section header table          |
| 48-49             | Number of entries in the section header table         |
| 50-51             | Index in section header table with the section names  |&lt;/p&gt;
&lt;p&gt;Bold words are used later in the program, please take attention to them.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Architecture&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;No Specific&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Sparc&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;x86&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;MIPS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;PowerPC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0x14&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;ARM&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0x28&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SuperH&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0x2A&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;IA-64&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0x32&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;x86-64&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0x3E&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;AArch64&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0xB7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Program table is following ELF header, for each entry, the format below:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Position&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Value&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;0-3&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Type of segment (see below)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;4-7&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The offset in the file that the data for this segment can be found (p_offset)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;8-11&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Where you should start to put this segment in virtual memory (p_vaddr)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;12-15&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Undefined for the System V ABI&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;16-19&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Size of the segment in the file (p_filesz)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;20-23&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Size of the segment in memory (p_memsz)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;24-27&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Flags (see below)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;28-31&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;The required alignment for this section (must be a power of 2)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Segment types:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0 = null - ignore the entry;&lt;/li&gt;
&lt;li&gt;1 = load - clear p_memsz bytes at p_vaddr to 0, then copy p_filesz bytes from p_offset to p_vaddr;&lt;/li&gt;
&lt;li&gt;2 = dynamic - requires dynamic linking;&lt;/li&gt;
&lt;li&gt;3 = interp - contains a file path to an executable to use as an interpreter for the following segment;&lt;/li&gt;
&lt;li&gt;4 = note section.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;There are more numbers for segment types, but most of them are related with operation system and processor architecture, mainstream segment types are above ones.&lt;/p&gt;
&lt;p&gt;Flags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 = executable,&lt;/li&gt;
&lt;li&gt;2 = writable,&lt;/li&gt;
&lt;li&gt;4 = readable.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For our boot loader program, we care &lt;code&gt;.data&lt;/code&gt; and &lt;code&gt;.text&lt;/code&gt; segments most in elf file, so how to locate them in a elf file is the biggest problem for us.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://wiki.osdev.org/images/f/fe/Elfdiagram.png&#34; alt=&#34;ELF re-mapping&#34;&gt;&lt;/p&gt;
&lt;p&gt;The boot loader need first to read value from ELF header and get the information about program header table. We can see in the bytes definition of elf header that bytes &lt;strong&gt;42-45&lt;/strong&gt; is the size of program header table, so we search for every entry in the program header table, then get the information about every segment including offset and size. The final move is reading from the disk at specific offset and size and copy the segment into memory.&lt;/p&gt;
&lt;p&gt;Let us focusing on the codes.&lt;/p&gt;
&lt;h1 id=&#34;bootmainc-code-notes&#34;&gt;bootmain.c code notes&lt;/h1&gt;
&lt;p&gt;It is a good habit to start at reading the code header notes. &lt;code&gt;bootmain.c:1-6&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Boot loader.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Part of the boot sector, along with bootasm.S, which calls bootmain().
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// bootasm.S has put the processor into protected 32-bit mode.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// bootmain() loads an ELF kernel image from the disk starting at
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// sector 1 and then jumps to the kernel entry routine.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;elf 指针被强制指向了 &lt;code&gt;0x10000&lt;/code&gt; 地址，这是因为我们接下来要将 elf 文件整个放到 &lt;code&gt;0x10000&lt;/code&gt; 地址起始的后面的空间内。代码定位 &lt;code&gt;bootmain.c:20-28&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; elfhdr &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;elf;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; proghdr &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ph, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;eph;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;entry)(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;);
  uchar&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; va;

  elf &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; elfhdr&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#ae81ff&#34;&gt;0x10000&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// scratch space
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  
  &lt;span style=&#34;color:#75715e&#34;&gt;// Read 1st page off disk
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  readseg((uchar&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)elf, &lt;span style=&#34;color:#ae81ff&#34;&gt;4096&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;These structs are defined in header file &lt;code&gt;elf.h&lt;/code&gt;. The destination address is &lt;code&gt;0x10000&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There are two sub-functions that manage reading from disk, &lt;code&gt;readseg&lt;/code&gt; and &lt;code&gt;readsect&lt;/code&gt;. &lt;code&gt;bootmain.c:76-96&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Read &amp;#39;count&amp;#39; bytes at &amp;#39;offset&amp;#39; from kernel into virtual address &amp;#39;va&amp;#39;.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Might copy more than asked.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;readseg&lt;/span&gt;(uchar&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; va, uint count, uint offset)
{
  uchar&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; eva;

  eva &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; va &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; count;

  &lt;span style=&#34;color:#75715e&#34;&gt;// Round down to sector boundary.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  va &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; offset &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; SECTSIZE;

  &lt;span style=&#34;color:#75715e&#34;&gt;// Translate from bytes to sectors; kernel starts at sector 1.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  offset &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (offset &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; SECTSIZE) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;

  &lt;span style=&#34;color:#75715e&#34;&gt;// If this is too slow, we could read lots of sectors at a time.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// We&amp;#39;d write more to memory than asked, but it doesn&amp;#39;t matter --
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// we load in increasing order.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(; va &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; eva; va &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SECTSIZE, offset&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;)
    readsect(va, offset);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;readsect()&lt;/code&gt; is an low-level function, it reads a sector of given sector number. &lt;code&gt;SECTSIZE/4&lt;/code&gt; is because the asm &lt;code&gt;insl&lt;/code&gt; reads data in double words (4 bytes).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;waitdisk&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)
{
  &lt;span style=&#34;color:#75715e&#34;&gt;// Wait for disk ready.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;((inb(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x1F7&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xC0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x40&lt;/span&gt;)
    ;
}

&lt;span style=&#34;color:#75715e&#34;&gt;// Read a single sector at offset into dst.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;readsect&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dst, uint offset)
{
  &lt;span style=&#34;color:#75715e&#34;&gt;// Issue command.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  waitdisk();
  outb(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x1F2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);   &lt;span style=&#34;color:#75715e&#34;&gt;// count = 1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  outb(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x1F3&lt;/span&gt;, offset);
  outb(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x1F4&lt;/span&gt;, offset &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;);
  outb(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x1F5&lt;/span&gt;, offset &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;);
  outb(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x1F6&lt;/span&gt;, (offset &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xE0&lt;/span&gt;);
  outb(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x1F7&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x20&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// cmd 0x20 - read sectors
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
  &lt;span style=&#34;color:#75715e&#34;&gt;// Read data.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  waitdisk();
  insl(&lt;span style=&#34;color:#ae81ff&#34;&gt;0x1F0&lt;/span&gt;, dst, SECTSIZE&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Because the mechanics of hard disk, we can only get access to a full sector once. When we want to get data from specified offset, we need to read all the sectors that contains the data. That means we have to read more data than we need, and the redundant data is trash data we need to sweep away.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Round down the offset to the sector beginning.&lt;/li&gt;
&lt;li&gt;Read until the end of the final sector.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first elf header data comes from the beginning sector 2, so there will not be any round down, but after the first read,  there is no guarantee about segments always meet the boundaries of disk sectors.&lt;/p&gt;
&lt;p&gt;Magic number lies in the fixed offset in an elf, so we can check Magic number to validate the elf. &lt;code&gt;bootmain.c:30-32&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// Is this an ELF executable?
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(elf&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;magic &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ELF_MAGIC)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// let bootasm.S handle error
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;return&lt;/code&gt;? where does processor go? Actually it returns to &lt;code&gt;bootasm.S&lt;/code&gt; and execute the error handler, which will transmit an error to the virtual machine we are using through an special I/O port.&lt;/p&gt;
&lt;p&gt;Now we have checked the elf, next we start carrying things into memory. &lt;code&gt;bootmain.c:34-42&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// Load each program segment (ignores ph flags).
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;  ph &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; proghdr&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)((uchar&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)elf &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; elf&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;phoff);
  eph &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ph &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; elf&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;phnum;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(; ph &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; eph; ph&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;) {
    va &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (uchar&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)(ph&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;va &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xFFFFFF&lt;/span&gt;);
    readseg(va, ph&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;filesz, ph&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;offset);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(ph&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;memsz &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; ph&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;filesz)
      stosb(va &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; ph&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;filesz, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, ph&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;memsz &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; ph&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;filesz);
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The first 4096 bytes was loaded, we assumed both the elf header and program header table are in the 4096 bytes. Next we checked the Magic number, then we searched for every entry in the program table and copy segments into memory.&lt;/p&gt;
&lt;p&gt;Here we used &lt;code&gt;stosb&lt;/code&gt; function to padding the segment, in fact, to clear the accompanying trash code between sectors and the code. &lt;code&gt;x86.h:42-49&lt;/code&gt;：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;inline&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// store some(cnt) bytes(data) to addr(addr)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;stosb(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;addr, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; data, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; cnt)
{
  &lt;span style=&#34;color:#66d9ef&#34;&gt;asm&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;cld; rep stosb&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
               &lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;=D&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; (addr), &lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;=c&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; (cnt) &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
               &lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; (addr), &lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; (cnt), &lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;a&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt; (data) &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
               &lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;memory&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;cc&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the end, we cast entry into a function pointer and call the function, all done!&lt;/p&gt;
&lt;h1 id=&#34;read-world&#34;&gt;Read World&lt;/h1&gt;
&lt;p&gt;The boot loader described in this chapter compiles to around 470 bytes of machine code, depending on the optimizations used when compiling the C code. In order to fit in that small amount of space, the xv6 boot loader makes a major simplifying assumption, that the kernel has been written to the boot disk contiguously starting at sector 1. More commonly, kernels are stored in ordinary file system, where they may not be contiguous, or are loaded over a network. These complications require the boot loader to be able to drive a variety of disk and network controllers and understand various file system and network protocols. In other words, the boot loader itself must be a small operation system. Since such complicated boot loader certainly won&#39;t fit in 512 bytes, most PC operating systems use a two-step boot process.&lt;/p&gt;
&lt;p&gt;First, a simple boot loader like the one in this appendix loads a full-featured boot loader from a known disk location, often relying on the less space-constrained BIOS for disk access rather than trying to drive the disk itself. The full loader, relieved of the 512-byte limit, can implement the complexity needed to locate, load, and execute the desired kernel. Modern PCs avoid many of the above complexities, because they support the Unified Extensible Firmware Interface (UEFI), which allows PC to read a larger boot loader from the disk (and start in protected and 32-bit mode).&lt;/p&gt;
&lt;p&gt;The Chapter 1 and Chapter 2 is written as if the only thing that happens between power on and the execution of boot loader is that the BIOS loads the boot sector. In fact the BIOS does a huge amount of initialization in order to make the complex hardware of a modern computer look like a traditional standard PC. The BIOS is really a small operating system embedded in the hardware, which is present after the computer has booted.&lt;/p&gt;
&lt;h1 id=&#34;exercises--answer&#34;&gt;Exercises &amp;amp; Answer&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Due to sector granularity, the call to &lt;code&gt;readseg&lt;/code&gt; in the text is equivalent to &lt;code&gt;readseg((uchar*)0x100000, 0xb500, 0x1000)&lt;/code&gt;. In practice, this sloppy behavior turns out not to be a problem. Why doesn&#39;t the sloppy readsect cause problems?&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Very easy if you carefully read the code, &lt;code&gt;readseg&lt;/code&gt; performs a offset round down before reading, so the actual offset transferred to &lt;code&gt;readsect&lt;/code&gt; is always aligned to the border of sectors.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Suppose you wanted &lt;code&gt;bootmain()&lt;/code&gt; to load the kernel at 0x20000 instead of 0x100000, and you did so by modifying &lt;code&gt;bootmain()&lt;/code&gt; to add 0x100000 to the va of each ELF section. Something would go wrong. What?&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;This question is tricky. It won&#39;t cause any problems until we call &lt;code&gt;p-&amp;gt;entry&lt;/code&gt;. The entry in memory has been move backwards by 0x100000, whereas the &lt;code&gt;p-&amp;gt;entry&lt;/code&gt; points to the original va.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;It seems potentially dangerous for the boot loader to copy the ELF header to memory at the arbitray location 0x10000. Why doesn&#39;t it call &lt;code&gt;malloc&lt;/code&gt; to obtain the memory it needs?&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;This question is stupid. &lt;code&gt;malloc&lt;/code&gt; need system call &lt;code&gt;sbrk()&lt;/code&gt; to implement. We cannot use &lt;code&gt;malloc&lt;/code&gt; because we haven&#39;t imported the kernel yet.&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    <item>
      <title>RB-Tree - Reading STL Source Code</title>
      <link>https://xiahualiu.github.io/posts/2018-08-28-rb-tree/</link>
      <pubDate>Tue, 28 Aug 2018 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2018-08-28-rb-tree/</guid>
      <description>&lt;p&gt;红黑树的数据结构已经被研究了多年，最为最广泛应用的数据结构之一，因为其具有优良的特性，即自平衡性，所以无论在最坏或者是最好的输出中，红黑树的高度都十分稳定（&lt;strong&gt;红黑树可以能确保树的最长路径不大于两倍的最短路径的长度&lt;/strong&gt;）。&lt;/p&gt;
&lt;p&gt;但是相对的，红黑树的操作也较为复杂，本文将会从 &lt;strong&gt;2-3 树出发&lt;/strong&gt;，介绍 2-3 树到红黑树的演化，最后介绍目前 STL 模型中的红黑树模型实现，详细介绍红黑树的发展历程（红黑树算法还在不断地完善中，本文只是简要地叙述模型）。&lt;/p&gt;
&lt;p&gt;另外本文在未来还会补充 AA 树等其他的红黑树变种，但是更新看心情咯（当场去世）。AVL 树的内容我也会等未来慢慢添加进去的，不过 AVL 树没有红黑树应用广泛，而且实现方法其实和红黑树基本一样，所以就简单叙述了。&lt;/p&gt;
&lt;p&gt;首先说明一下，树和哈希表的对比，哈希表的读取插入性能强于树，但是哈希表在面对持续输入未知数据的情况下，无法做到每个键值都是唯一的，而且哈希表需要更大的空间来存放，所以树在针对动态数据的情况下，还是十分重要的。而对于已知的静态数据来说，通过不同的算法实现哈希表还是更为高效的。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;二叉树的缺点&lt;/h2&gt;
&lt;p&gt;为什么我们不使用二叉树作为各种容器的数据结构呢，因为二叉树的稳定性比较差。我们知道，二叉树的高度其实是没有保证的，也就是说，如果在遇到连续顺序输入的情况下，二叉树的高度会非常的高，这样查找的时间效率会近似于 O(N)，达不到使用的要求。&lt;/p&gt;
&lt;p&gt;所以，人们在一开始就思考，我们可以通过一些小小的变换使得二叉树成为平衡的树嘛，于是就产生了 AVL 树。AVL 树和红黑树类似，也是一种自平衡二叉树，实现过程也与红黑树类似，但是由于 AVL 树对于平衡的要求比较严格，所以在自平衡的过程中，旋转的次数比较多，虽然 AVL 树和红黑树的算法复杂度一样，但是统计出的性能不如红黑树。&lt;/p&gt;
&lt;h2 id=&#34;2-3-&#34;&gt;2-3 查找树&lt;/h2&gt;
&lt;p&gt;我们使得一个标准的二叉查找树同时具有二叉节点和三叉节点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-8-28-RB-tree/2-3-1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;2-3 查找树的查找行为，是与二叉树类似的，但是又有些不同，因为具有了三叉节点，所以查找的时候有可能遇到 3 节点或者 2 节点，需要根据情况判断：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-8-28-RB-tree/2-3-2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;具体的 2-3 树的插入，删除，替换细节不做过多介绍，但是在看下面的内容之前，最好还是先了解一下 2-3 树的变换过程：
&lt;a href=&#34;https://en.wikipedia.org/wiki/2%E2%80%933_tree#Operations&#34;&gt;2-3 Tree Operation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;很简单，容易理解，2 节点插入就变为 3 节点，3 节点插入就变成 4 节点，然后转变成为三个 2 节点，其中的父节点和上层节点结合。通过仔细观察，这两种变换过程都保证了一个细节，也就是不管怎么插入，2-3 树都是平衡的，红黑树正是利用了这种性质，我们接下来会介绍红黑树的结构。&lt;/p&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;红黑树定义&lt;/h2&gt;
&lt;p&gt;既然大家都有一样的性质，为什么不用 2-3 树而偏要用红黑树呢？通过之前的描述我们就能看出来，2-3 树具有两种节点，我们需要维护两种同类型的节点，再插入时需要在两种节点间进行类型转换，实现这些过程需要大量的代码，而且效率也不高。我们希望利用更少的代码和开销来实现这种功能，这就是红黑树。&lt;/p&gt;
&lt;p&gt;红黑树的基本思想是只利用标准的二叉查找树，和一些额外的信息（颜色）来表示 2-3 树。树中的链接被分为两类，一类是红链接，另外一类是黑链接。被红链接链接的两个节点相当于是一个三节点。红链接满足以下条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;红链接均为左链接&lt;/li&gt;
&lt;li&gt;没有任何一个节点同时和两条红链接相连&lt;/li&gt;
&lt;li&gt;树是完美平衡的，任意 NULL 链接通往根节点的路径上，黑链接的数量为定值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;heading-2&#34;&gt;红黑树的实现&lt;/h2&gt;
&lt;p&gt;这里红黑树的实现参考了 STL 函数库：&lt;/p&gt;
&lt;h3 id=&#34;rb-tree-node&#34;&gt;RB-Tree Node&lt;/h3&gt;
&lt;p&gt;红黑树分为红黑两种颜色，在我们之前的描述中，被红色链接链接的子节点为红色节点，被黑色链接链接的节点为黑色节点。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; __rb_tree_color_type;
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; __rb_tree_color_type __rb_tree_red &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; false;
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; __rb_tree_color_type __rb_tree_red &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; true;

&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__rb_tree_node_base&lt;/span&gt;
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; __rb_tree_color_type color_type;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; __rb_tree_node_base&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; base_ptr;

	color_type color; &lt;span style=&#34;color:#75715e&#34;&gt;// Color of the node, RED or BLACK
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	base_ptr parent; &lt;span style=&#34;color:#75715e&#34;&gt;// Child node can trace back to Root
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	base_ptr left; &lt;span style=&#34;color:#75715e&#34;&gt;// Left child ptr
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;	base_ptr right; &lt;span style=&#34;color:#75715e&#34;&gt;// Right child ptr
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; base_ptr &lt;span style=&#34;color:#a6e22e&#34;&gt;minimum&lt;/span&gt;(base_ptr x)
	{   &lt;span style=&#34;color:#75715e&#34;&gt;// Find the smallest value 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;		&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (x&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;left &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;left; 
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x;
	}

	&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; base_ptr &lt;span style=&#34;color:#a6e22e&#34;&gt;maximum&lt;/span&gt;(base_ptr x)
	{
		&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (x&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;right &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;right;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; x;
	}
};

&lt;span style=&#34;color:#66d9ef&#34;&gt;template&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Value&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;__rb_tree_node&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;public&lt;/span&gt; __rb_tree_node_base 
{
	&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; __rb_tree_node&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Value&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; link_type;
	Value value_field;
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>FPGA EEPROM Communication</title>
      <link>https://xiahualiu.github.io/posts/2018-08-09-fpga-eeprom/</link>
      <pubDate>Thu, 09 Aug 2018 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2018-08-09-fpga-eeprom/</guid>
      <description>&lt;p&gt;本文将会就 FPGA 的 I2C 总线实现进行实践，在测试的时候，我们使用了一个假象的 EEPROM 对象来进行测试，验证我们设计的合理性。&lt;/p&gt;
&lt;h2 id=&#34;i2c-&#34;&gt;I2C 总线物理层与链路层&lt;/h2&gt;
&lt;p&gt;I2C 为两线双工总线，两根线分别为 SCL 和 SDA。空闲时 SCL 和 SDA 均为高电平。启动信号由 SCL 处于高电平，SDA 拉低开始。从这个时间后主机输出时钟 SCL，在 SCL 处于低电平状态下进行 SDA 改变，SCL 高电平情况下 SDA 数据被锁定，给丛机读取，最后 SCL 在高电平情况下拉高 SDA 完成传输。&lt;/p&gt;
&lt;p&gt;每传输 8 个位，也就是一个字节后，下一个位的时钟期间，将SDA 释放，成为高电平，接收方将其拉低，应答完毕。&lt;/p&gt;
&lt;h2 id=&#34;eeprom-&#34;&gt;EEPROM 测试模型&lt;/h2&gt;
&lt;p&gt;测试使用的 EEPROM 模型是使用 FPGA 实现的理想化简化行为模型，仅仅供测试使用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* This file is made by EggyCat to implement AT24C02 */&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;`timescale&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;ns&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;ns
&lt;span style=&#34;color:#75715e&#34;&gt;`define&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; timeslice 100&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; EEPROM(scl, sda);
&lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; scl;
&lt;span style=&#34;color:#66d9ef&#34;&gt;inout&lt;/span&gt; sda;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; out_flag;

&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] memory[&lt;span style=&#34;color:#ae81ff&#34;&gt;2047&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] address;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] memory_buf;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] sda_buf;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] shift;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] addr_byte;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] ctrl_byte;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] State;

&lt;span style=&#34;color:#66d9ef&#34;&gt;integer&lt;/span&gt; i;

&lt;span style=&#34;color:#66d9ef&#34;&gt;parameter&lt;/span&gt; r7&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10101111&lt;/span&gt;, w7&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10101110&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//memory page 7
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;parameter&lt;/span&gt; r6&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10101101&lt;/span&gt;, w6&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10101100&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//memory page 6
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;parameter&lt;/span&gt; r5&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10101011&lt;/span&gt;, w5&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10101010&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//memory page 5
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;parameter&lt;/span&gt; r4&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10101001&lt;/span&gt;, w4&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10101000&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//memory page 4
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;parameter&lt;/span&gt; r3&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10100111&lt;/span&gt;, w3&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10100110&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//memory page 3
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;parameter&lt;/span&gt; r2&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10100101&lt;/span&gt;, w2&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10100100&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//memory page 2
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;parameter&lt;/span&gt; r1&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10100011&lt;/span&gt;, w1&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10100010&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//memory page 1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;parameter&lt;/span&gt; r0&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10100001&lt;/span&gt;, w0&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10100000&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//memory page 0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; sda&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(out_flag&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;sda_buf[&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&amp;#39;bz; &lt;span style=&#34;color:#75715e&#34;&gt;//sda whether output
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;initial&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
    addr_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    out_flag&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    sda_buf&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    State&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b00&lt;/span&gt;;
    memory_buf&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    address&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    shift&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2047&lt;/span&gt;;i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
        memory[i]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;always&lt;/span&gt; @(&lt;span style=&#34;color:#66d9ef&#34;&gt;negedge&lt;/span&gt; sda)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(scl&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
            State&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;State&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b01&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;//ModelSim6.0版本以上认为z到1是负跳变沿
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(State&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b11&lt;/span&gt;)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;disable&lt;/span&gt; write_to_eeprom;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;always&lt;/span&gt; @(&lt;span style=&#34;color:#66d9ef&#34;&gt;posedge&lt;/span&gt; sda)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(scl&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
        stop_W_R; &lt;span style=&#34;color:#75715e&#34;&gt;//传输完毕
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;casex&lt;/span&gt;(State)
                &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b01&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; 
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    read_in;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;w7 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;w6 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;w5 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;w4 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;w3 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;w2 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;w1 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;w0)
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                        State&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10&lt;/span&gt;;
                        write_to_eeprom;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
						  &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
							State&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b00&lt;/span&gt;;
					 &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
                &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b11&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
                read_from_eeprom;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
                State&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b00&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;endcase&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;task&lt;/span&gt; stop_W_R;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt; 
        State&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b00&lt;/span&gt;;
        addr_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        out_flag&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        sda_buf&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endtask&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;task&lt;/span&gt; read_in;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
        shift_in(ctrl_byte);
        shift_in(addr_byte);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endtask&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;task&lt;/span&gt; write_to_eeprom;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
        shift_in(memory_buf);
        address&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;{ctrl_byte[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], addr_byte};
        memory[address]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;memory_buf;
        $display(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;eeprom---memory[%0h]=%0h&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, address, memory[address]);
        State&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b00&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endtask&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;task&lt;/span&gt; read_from_eeprom;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
        shift_in(ctrl_byte);
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;r7 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;r6 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;r5 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;r4 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;r3 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;r2 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;r1 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; ctrl_byte&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;r0)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                address&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;{ctrl_byte[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], addr_byte};
                sda_buf&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;memory[address];
                shift_out;
                State&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b00&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endtask&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;task&lt;/span&gt; shift_in;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]shift;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
            @(&lt;span style=&#34;color:#66d9ef&#34;&gt;posedge&lt;/span&gt; scl) shift[&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sda;
            @(&lt;span style=&#34;color:#66d9ef&#34;&gt;posedge&lt;/span&gt; scl) shift[&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sda;
            @(&lt;span style=&#34;color:#66d9ef&#34;&gt;posedge&lt;/span&gt; scl) shift[&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sda;
            @(&lt;span style=&#34;color:#66d9ef&#34;&gt;posedge&lt;/span&gt; scl) shift[&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sda;
            @(&lt;span style=&#34;color:#66d9ef&#34;&gt;posedge&lt;/span&gt; scl) shift[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sda;
            @(&lt;span style=&#34;color:#66d9ef&#34;&gt;posedge&lt;/span&gt; scl) shift[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sda;
            @(&lt;span style=&#34;color:#66d9ef&#34;&gt;posedge&lt;/span&gt; scl) shift[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sda;
            @(&lt;span style=&#34;color:#66d9ef&#34;&gt;posedge&lt;/span&gt; scl) shift[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sda;
            @(&lt;span style=&#34;color:#66d9ef&#34;&gt;negedge&lt;/span&gt; scl)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    #&lt;span style=&#34;color:#66d9ef&#34;&gt;`timeslice&lt;/span&gt;;
                    out_flag&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    sda_buf&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            @(&lt;span style=&#34;color:#66d9ef&#34;&gt;negedge&lt;/span&gt; scl)
                #&lt;span style=&#34;color:#66d9ef&#34;&gt;`timeslice&lt;/span&gt; out_flag&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endtask&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;task&lt;/span&gt; shift_out;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
        out_flag&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;;i&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;i&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt; 
                @(&lt;span style=&#34;color:#66d9ef&#34;&gt;negedge&lt;/span&gt; scl);
                #&lt;span style=&#34;color:#66d9ef&#34;&gt;`timeslice&lt;/span&gt;;
                sda_buf&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sda_buf&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
        @(&lt;span style=&#34;color:#66d9ef&#34;&gt;negedge&lt;/span&gt; scl) #&lt;span style=&#34;color:#66d9ef&#34;&gt;`timeslice&lt;/span&gt; sda_buf[&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
        @(&lt;span style=&#34;color:#66d9ef&#34;&gt;negedge&lt;/span&gt; scl) #&lt;span style=&#34;color:#66d9ef&#34;&gt;`timeslice&lt;/span&gt; out_flag&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endtask&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;heading&#34;&gt;模块分析&lt;/h2&gt;
&lt;p&gt;我们可以看到我们的 EEPROM 仿真模块是使用状态机来进行模拟的，&lt;code&gt;State&lt;/code&gt; 为状态值，状态机闲置状态时 &lt;code&gt;State=2&#39;b00&lt;/code&gt;，EEPROM处于被写状态为 &lt;code&gt;State=2&#39;b01&lt;/code&gt;，EEPROM处于被读状态为 &lt;code&gt;State=2&#39;b11&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;启动信号为 sda 的下降沿和 scl 处于高电平时，结束传输信号是 sda 处于上升沿且 scl 为高电平状态。在其他情况下，也就是 sda 处于上升沿且 scl 处于低电平状态时（因为 EEPROM 的第一个控制位一定为 1），我们就认定已经开始传输数据位了，这时触发 &lt;code&gt;read_in&lt;/code&gt; 任务，开始顺序在 scl 的上升沿读取 sda 的数据到控制字节和数据字节中。&lt;/p&gt;
&lt;p&gt;应答是通过一个连接标志 &lt;code&gt;out_flag&lt;/code&gt; 实现的，sda 会在 &lt;code&gt;out_flag==1&lt;/code&gt; 的情况下被连接在 sda_buf[7] 上面。应答是在最后的 scl 下降沿拉低 sda，我们在最后的下降沿将 sda_buf 置为 0，并将 &lt;code&gt;out_flag&lt;/code&gt; 置 1 连接即可，在下一个 scl 下降沿（此时应答结束）将 &lt;code&gt;out_flag&lt;/code&gt; 置 0，断开输出（sda 置为高阻）。&lt;/p&gt;
&lt;p&gt;读任务完成后，EEPROM 获取了外部的沟通信息，信息分为两类，一类是外部请求读某地址的数据，另一类是外部请求写某地址的数据。我们接下来分析请求是读还是写，使用 if 语句比较第一个字节（控制字节）的信息，如果是请求写数据，那么触发写操作任务；相反如果控制字节是读信息，那么触发读操作任务。&lt;/p&gt;
&lt;p&gt;写操作较为简单，因为不涉及应答，而读操作需要应答。&lt;/p&gt;
&lt;p&gt;在读任务中，我们首先将需要发送的输出放置在 sda_buf 中，然后连接 sda
和 sda_buf(&lt;code&gt;out_flag=1&lt;/code&gt;)，因为我们在之前 read_in 的最后 scl 下降沿没有改变数据，也就是在一开始连接的时候就相当于已经发送出去了一位数据。为了避免冒险，我们定义了 `timeslice 延迟，在这里也可以使用非阻塞的方法避免冒险。在发送完第 8 位后，断开连接释放总线，等待主机拉高 sda（主机接收器不应答）结束通信。&lt;/p&gt;
&lt;p&gt;在 Quartus Prime Lite 中编译提示，在 &lt;code&gt;task shift_in&lt;/code&gt; 里面不能产生多事件序列，综合失败。&lt;/p&gt;
&lt;h2 id=&#34;-eeprom-&#34;&gt;可综合的 EEPROM 读写器模型&lt;/h2&gt;
&lt;p&gt;程序实际上是一个嵌套的状态机，由主状态机和从状态机通过控制线启动的总线在不同的输入信号情况下构成不同功能的较复杂得到有限状态机（FSM）。&lt;/p&gt;
&lt;p&gt;两个状态机的模型，分别为控制时序电路和开关组合电路，开关组合电路控制总线的开闭，有节奏地打开或者闭合，这样 SDA 可以按照 I2C 数据总线的格式输入和输出，使得 SDA 和 SCL 一起完成 EEPROM 的读写操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-8-9-FPGA-EEPROM/struct.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;其状态机的状态转移图如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-8-9-FPGA-EEPROM/FSM.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;状态机的状态编码采用独热编码，减少实现状态机的组合逻辑数目，减少复杂性，提高系统的速度，通常用于高速状态机中（也有编码输出型状态机）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;`timescale&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;ns&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;ns

&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; EEPROM_WR(SDA, SCL, ACK, RESET, CLK, WR, RD, ADDR, DATA);
&lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; SCL;
&lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; ACK;
&lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; RESET;
&lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; CLK;
&lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; WR, RD;
&lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] ADDR;
&lt;span style=&#34;color:#66d9ef&#34;&gt;inout&lt;/span&gt; SDA;
&lt;span style=&#34;color:#66d9ef&#34;&gt;inout&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] DATA;

&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; ACK;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; SCL;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; WF, RF;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; FF;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] head_buf;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] stop_buf;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] sh8out_buf;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] sh8out_state;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] sh8in_state;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] head_state;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] stop_state;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] main_state;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] data_from_rm;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; link_sda;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; link_read;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; link_head;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; link_write;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; link_stop;
&lt;span style=&#34;color:#66d9ef&#34;&gt;wire&lt;/span&gt; sda1, sda2, sda3, sda4;

&lt;span style=&#34;color:#75715e&#34;&gt;/* Switch Signal */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; sda1&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(link_head)&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; head_buf[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; sda2&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(link_write)&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; sh8out_buf[&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; sda3&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(link_stop)&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; stop_buf[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; sda4&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(sda1&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;sda2&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;sda3);
&lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; SDA&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(link_sda)&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; sda4: &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&amp;#39;bz;
&lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; DATA&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(link_read)&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt; data_from_rm &lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&amp;#39;hzz;

&lt;span style=&#34;color:#75715e&#34;&gt;/* Main FSM State Definition */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;parameter&lt;/span&gt;
    IDLE        &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b00000000001&lt;/span&gt;,
    Ready       &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b00000000010&lt;/span&gt;,
    Write_start &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b00000000100&lt;/span&gt;,
    Ctrl_write  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b00000001000&lt;/span&gt;,
    Addr_write  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b00000010000&lt;/span&gt;,
    Data_write  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b00000100000&lt;/span&gt;,
    Read_start  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b00001000000&lt;/span&gt;,
    Ctrl_read   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b00010000000&lt;/span&gt;,
    Data_read   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b00100000000&lt;/span&gt;,
    Stop        &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b01000000000&lt;/span&gt;,
    Ackn        &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10000000000&lt;/span&gt;,

&lt;span style=&#34;color:#75715e&#34;&gt;/* Parallel to Serial Output State Definition */&lt;/span&gt;
    sh8out_bit7 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b000000001&lt;/span&gt;,
    sh8out_bit6 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b000000010&lt;/span&gt;,
    sh8out_bit5 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b000000100&lt;/span&gt;,
    sh8out_bit4 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b000001000&lt;/span&gt;,
    sh8out_bit3 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b000010000&lt;/span&gt;,
    sh8out_bit2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b000100000&lt;/span&gt;,
    sh8out_bit1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b001000000&lt;/span&gt;,
    sh8out_bit0 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b010000000&lt;/span&gt;,
    sh8out_end  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b100000000&lt;/span&gt;,

&lt;span style=&#34;color:#75715e&#34;&gt;/* Serial to Parallel Output State Definition */&lt;/span&gt;
    sh8in_begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0000000001&lt;/span&gt;,
    sh8in_bit7  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0000000010&lt;/span&gt;,
    sh8in_bit6  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0000000100&lt;/span&gt;,
    sh8in_bit5  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0000001000&lt;/span&gt;,
    sh8in_bit4  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0000010000&lt;/span&gt;,
    sh8in_bit3  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0000100000&lt;/span&gt;,
    sh8in_bit2  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0001000000&lt;/span&gt;,
    sh8in_bit1  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0010000000&lt;/span&gt;,
    sh8in_bit0  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0100000000&lt;/span&gt;,
    sh8in_end   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b1000000000&lt;/span&gt;,

&lt;span style=&#34;color:#75715e&#34;&gt;/* Start of Transmission */&lt;/span&gt;
    head_begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b01&lt;/span&gt;,
    head_bit   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10&lt;/span&gt;,

&lt;span style=&#34;color:#75715e&#34;&gt;/* End of Transmission */&lt;/span&gt;
    stop_begin &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b001&lt;/span&gt;,
    stop_bit   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b010&lt;/span&gt;,
    stop_end   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b100&lt;/span&gt;,

    YES &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b1&lt;/span&gt;,
    NO  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0&lt;/span&gt;;

&lt;span style=&#34;color:#75715e&#34;&gt;/* Generate SCL (CLK divided by 2) */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;always&lt;/span&gt; @(&lt;span style=&#34;color:#66d9ef&#34;&gt;negedge&lt;/span&gt; CLK)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(RESET)
        SCL&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
        SCL&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;SCL;

&lt;span style=&#34;color:#75715e&#34;&gt;/* Main FSM Status */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;always&lt;/span&gt; @(&lt;span style=&#34;color:#66d9ef&#34;&gt;posedge&lt;/span&gt; CLK)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(RESET) &lt;span style=&#34;color:#75715e&#34;&gt;// RESET
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
            link_read  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
            link_write &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
            link_head  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
            link_stop  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
            link_sda   &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
            ACK        &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            RF         &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            WF         &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            FF         &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
            main_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; IDLE;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;casex&lt;/span&gt;(main_state)
                IDLE:
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                        link_read  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                        link_write &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                        link_head  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                        link_stop  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                        link_sda   &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(WR)
                            &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                                WF&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                                main_state&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;Ready;
                            &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(RD)
                            &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                                RF&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                                main_state&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;Ready;
                            &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                            &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                                WF&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                                RF&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                                main_state&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;IDLE;
                            &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;

                Ready:
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                        link_read  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                        link_write &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                        link_head  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; YES;
                        link_stop  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                        link_sda   &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; YES;
                        head_buf[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10&lt;/span&gt;;
                        stop_buf[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b01&lt;/span&gt;;
                        head_state    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head_begin;
                        FF  &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                        ACK &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                        main_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Write_start;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;

                Write_start:
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(FF&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
                        shift_head;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                            sh8out_buf[&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;{&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0&lt;/span&gt;, ADDR[&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0&lt;/span&gt;};
                            link_head &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                            link_write &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; YES;
                            FF &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                            sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit6;
                            main_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Ctrl_write;
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;

                Ctrl_write:
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(FF&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
                        shift8_out;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                            FF &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(WF)
                                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                                    sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit7;
                                    sh8out_buf[&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DATA;
                                    main_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Data_write;
                                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
                            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(RF)
                                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                                    head_buf &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10&lt;/span&gt;;
                                    head_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head_begin;
                                    main_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Read_start;
                                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;

                Addr_write:
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(FF&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
                        shift8_out;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                            FF &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(WF)
                                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt; 
                                    sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit7;
                                    sh8out_buf[&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DATA;
                                    main_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Data_write;
                                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
                            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(RF)
                                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                                    head_buf &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b10&lt;/span&gt;;
                                    head_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head_begin;
                                    main_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Read_start;
                                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;

                Data_write:
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(FF&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
                        shift8_out;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                            stop_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stop_begin;
                            main_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Stop;
                            link_write &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                            FF &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
                
                Read_start:
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(FF&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
                        shift_head;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                            sh8out_buf &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0&lt;/span&gt;, ADDR[&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;], &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b1&lt;/span&gt;};
                            link_head &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                            link_sda &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; YES;
                            link_write &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; YES;
                            FF &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                            sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit6;
                            main_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Ctrl_read;
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;

                Data_read:
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(FF&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
                        shift8in;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                            link_stop &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; YES;
                            link_sda &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; YES;
                            stop_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stop_bit;
                            FF &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                            main_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Stop;
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
                
                Stop:
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(FF&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
                        shift_stop;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                            ACK &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                            FF &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                            main_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Ackn;
                        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;

                Ackn:
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                        ACK &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                        WF &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                        RF &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                        main_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; IDLE;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;

                &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; 
                    main_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; IDLE;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;endcase&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;/* Serial to Parallel Task */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;task&lt;/span&gt; shift8in;
&lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;casex&lt;/span&gt;(sh8in_state)
        sh8in_begin:
            sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit7;
        sh8in_bit7:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    data_from_rm[&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SDA;
                    sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit6;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit7;
        sh8in_bit6:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    data_from_rm[&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SDA;
                    sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit5;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit6;
        sh8in_bit5:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    data_from_rm[&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SDA;
                    sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit4;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit5;
        sh8in_bit4:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    data_from_rm[&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SDA;
                    sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit3;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit4;
        sh8in_bit3:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    data_from_rm[&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SDA;
                    sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit2;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit3;
        sh8in_bit2:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    data_from_rm[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SDA;
                    sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit1;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit2;
        sh8in_bit1:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    data_from_rm[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SDA;
                    sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit0;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit1;
        sh8in_bit0:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    data_from_rm[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; SDA;
                    sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_end;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit0;
        sh8in_end:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    link_read &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; YES;
                    FF &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit7;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_end;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                link_read &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                sh8in_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8in_bit7;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;endcase&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endtask&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;/* Parallel to Serial Task */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;task&lt;/span&gt; shift8_out;
&lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;casex&lt;/span&gt;(sh8out_state)
        sh8out_bit7:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    link_sda &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; YES;
                    link_write &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; YES;
                    sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit6;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit7;
        sh8out_bit6:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    link_sda &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; YES;
                    link_write &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; YES;
                    sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit5;
                    sh8out_buf &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_buf&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit6;
        sh8out_bit5:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit4;
                    sh8out_buf &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_buf&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit5;
        sh8out_bit4:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit3;
                    sh8out_buf &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_buf&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit4;
        sh8out_bit3:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit2;
                    sh8out_buf &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_buf&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit3;
        sh8out_bit2:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit1;
                    sh8out_buf &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_buf&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit2;
        sh8out_bit1:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit0;
                    sh8out_buf &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_buf&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit1;
        sh8out_bit0:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_end;
                    sh8out_buf &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_buf&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_bit0;
        sh8out_end:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    link_sda &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                    link_write &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                    FF &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                sh8out_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; sh8out_end;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;endcase&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endtask&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;/* Start of Transmission Task */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;task&lt;/span&gt; shift_head;
&lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;casex&lt;/span&gt;(head_state)
        head_begin:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    link_write &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
                    link_sda &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; YES;
                    link_head &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; YES;
                    head_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head_bit;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                head_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head_begin;
        head_bit:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    FF &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    head_buf &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head_buf &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    head_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head_bit;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                head_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; head_bit;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;endcase&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endtask&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;/* End of Transmission */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;task&lt;/span&gt; shift_stop;
&lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;casex&lt;/span&gt;(stop_state)
        stop_begin:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    link_sda &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; YES;
                    link_write &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                    link_stop &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; YES;
                    stop_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stop_bit;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                stop_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stop_begin;
        stop_bit:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    stop_buf &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stop_buf &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                    stop_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stop_end;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                stop_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stop_bit;
        stop_end:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;SCL)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
                    link_head &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                    link_stop &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                    link_sda &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NO;
                    FF &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
                stop_state &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stop_end;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;endcase&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endtask&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;heading-1&#34;&gt;读写器模型解析&lt;/h2&gt;
&lt;p&gt;在这个读写器模型中，我认为难点在于两个，一个是开关的控制，另外一个是状态机状态的转换过程。&lt;/p&gt;
&lt;p&gt;首先我们来讨论开关的控制。我们用了四个开关来控制 SDA 线的输入和输出，其中 &lt;code&gt;link_sda&lt;/code&gt; 为总的使能开关，控制着总线的释放还是占据，释放的时候，sda 处于高阻态，也就是处于读取状态。而剩余的三个开关 &lt;code&gt;link_head&lt;/code&gt;/&lt;code&gt;link_write&lt;/code&gt;/&lt;code&gt;link_stop&lt;/code&gt; 仅仅控制 sda 的移位寄存器连接关系，而这三个开关是互斥的，也就是同时 sda 所连接的寄存器只可能是 “启动信号”，“数据信号”，“停止信号” 中的一种寄存器中的最高位。&lt;/p&gt;
&lt;p&gt;之所以启动信号和停止信号都是两位的寄存器，是因为我们要通过 &lt;strong&gt;位移寄存器&lt;/strong&gt; 来产生跳边沿。而数据寄存器没有多于一位，我们在描述中&lt;code&gt;shift8_out&lt;/code&gt; 任务中，8 位的数据只位移了 7 次，第一次只连接寄存器，而不位移。&lt;/p&gt;
&lt;p&gt;在发送完启动信号之后的 &lt;code&gt;Write_start&lt;/code&gt; 状态中，我们的 &lt;code&gt;shift8_out&lt;/code&gt; 是从第 bit6 状态开始的，因为在这之前已经完成了开关，相当于已经发送了一位了。而在 &lt;code&gt;Addr_write&lt;/code&gt; 中，我们则是从 bit7 状态开始的，因为我们其实在这个时候空出了一个 SCL 的低电平总线没有占据，在这个时间内是应答信号的时间。&lt;/p&gt;
&lt;h2 id=&#34;-rtl-&#34;&gt;状态机分析和 RTL 网表&lt;/h2&gt;
&lt;p&gt;状态机的分析很清晰：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-8-9-FPGA-EEPROM/Serial_Check_main_state.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;相比之下，RTL 网表的分析就有些复杂了，因为我们设计的状态机用到了许多寄存器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-8-9-FPGA-EEPROM/RTL.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;至此，我们完成了对于 EEPROM 读写器的模型建立过程，在未来我们将会对于这个模型使用我们写好的 EEPROM 模块进行测试。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Some Verilog HDL Modules</title>
      <link>https://xiahualiu.github.io/posts/2018-08-08-verilog-example/</link>
      <pubDate>Wed, 08 Aug 2018 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2018-08-08-verilog-example/</guid>
      <description>&lt;p&gt;本文将会不定期更新一些常见的 Verilog HDL 模块实例供大家学习。如果对于数字电路不是很理解，或者对于语法不是很熟练，可以借鉴这里的例子，结合自己的项目进行模块开发。&lt;/p&gt;
&lt;p&gt;FPGA 设计模式分为组合逻辑设计和时序逻辑设计，我们将这两类分开讨论。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;组合逻辑&lt;/h2&gt;
&lt;h3 id=&#34;8-&#34;&gt;8 位带进位端的加法器设计实例&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; adder_8(cout, sum, a, b, cin);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; cout;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] sum;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; cin;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] a, b;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; {cout, sum} &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; b &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; cin;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;always&#34;&gt;指令译码电路设计实例（always）&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;`define&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; plus 3&amp;#39;d0&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;`define&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; minus 3&amp;#39;d1&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;`define&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; band 3&amp;#39;d2&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;`define&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; bor 3&amp;#39;d3&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;`define&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; unegate 3&amp;#39;d4&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; alu(out, opcode, a, b);
&lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] out;
&lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] opcode;
&lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] a, b;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] out;

&lt;span style=&#34;color:#66d9ef&#34;&gt;always&lt;/span&gt; @(opcode &lt;span style=&#34;color:#66d9ef&#34;&gt;or&lt;/span&gt; a &lt;span style=&#34;color:#66d9ef&#34;&gt;or&lt;/span&gt; b)
&lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt;(opcode)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;`plus&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; out&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;b;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;`minus&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; out&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;b;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;`band&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; out&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;b;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;`bor&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; out&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;b;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;`unegate&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; out&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;a;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; out&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&amp;#39;hx;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;task--always&#34;&gt;信号重组组合逻辑（task 和 always）&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; sort4(ra, rb, rc, rd, a, b, c, d);
&lt;span style=&#34;color:#66d9ef&#34;&gt;parameter&lt;/span&gt; t&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; [t:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] ra, rb, rc, rd;
&lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; [t:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] a, b, c, d;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; [t:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] ra, rb, rc, rd;

&lt;span style=&#34;color:#66d9ef&#34;&gt;always&lt;/span&gt; @(a &lt;span style=&#34;color:#66d9ef&#34;&gt;or&lt;/span&gt; b &lt;span style=&#34;color:#66d9ef&#34;&gt;or&lt;/span&gt; c &lt;span style=&#34;color:#66d9ef&#34;&gt;or&lt;/span&gt; d)
&lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; local &lt;span style=&#34;color:#75715e&#34;&gt;//因为块有局部变量，块必须有名字
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt;[t:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] va, vb, vc, vd;
    {va, vb, vc, vd}&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;{a, b, c, d};

    sort2(va,vc);
    sort2(vb,vd);
    sort2(va,vb);
    sort2(vc,vd);
    sort2(vb,vc);

    {ra, rb, rc, rd}&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;{va, vb, vc, vd};
&lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;task&lt;/span&gt; sort2;
&lt;span style=&#34;color:#66d9ef&#34;&gt;inout&lt;/span&gt; [t:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] x, y;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; [t:&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] tmp;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(x&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;y)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
        tmp&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;x;
        x&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;y;
        t&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;tmp;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endtask&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;heading-1&#34;&gt;比较器的设计实例（利用赋值语句设计组合逻辑）&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; compare(equal, a, b);
&lt;span style=&#34;color:#66d9ef&#34;&gt;parameter&lt;/span&gt; size&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; equal;
&lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; [size&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] a, b;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; equal&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(a&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;b)&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;3-8-&#34;&gt;3-8 译码器的实现（利用赋值语句设计组合逻辑）&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; decoder(out, in);
&lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] out;
&lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] in;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; out&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;in;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;heading-2&#34;&gt;多路器的设计实例&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;利用赋值设计组合逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; emux1(out, a, b, sel);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; out;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; a, b, sel;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; out&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;sel&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;a:b;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;利用 always case 设计组合逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; mux2(out, a, b, sel);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; out;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; a, b, sel;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; out;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;always&lt;/span&gt; @(a &lt;span style=&#34;color:#66d9ef&#34;&gt;or&lt;/span&gt; b &lt;span style=&#34;color:#66d9ef&#34;&gt;or&lt;/span&gt; sel)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;case&lt;/span&gt;(sel)
            &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; out&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a;
            &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; out&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;b;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;default&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; out&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &amp;#39;bx;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;endcase&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;利用 always if 设计组合逻辑&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; mux3(out, a, b, sel);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; out;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; a, b, sel;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; out;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;always&lt;/span&gt; @(a &lt;span style=&#34;color:#66d9ef&#34;&gt;or&lt;/span&gt; b &lt;span style=&#34;color:#66d9ef&#34;&gt;or&lt;/span&gt; sel)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(sel)
            out&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
            out&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;b;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;heading-3&#34;&gt;奇偶校验位生成器设计实例&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; parity(even_numbits, odd_numbits, input_bus);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; even_numbits, odd_numbits;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] input_bus;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; odd_numbits&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;input_bus;
    &lt;span style=&#34;color:#75715e&#34;&gt;//assign b=^a; equals assign b=a[0]^a[1]^a[2]^a[3]^a[4]^a[5]^a[6]^a[7];
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; even_numbits&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;odd_numbits;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;heading-4&#34;&gt;三态输出驱动器&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;设计方案1。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; trist1(out, in, enable);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; out;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; in, enable;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; out&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;enable&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;in:&amp;#39;bz;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;设计方案2。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; trist2(out, in, enable);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; out;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; in, enable;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;bufif1&lt;/span&gt; mubuf1(out, in, enable);
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;heading-5&#34;&gt;三态双向驱动器设计实例&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; bidir(tri_inout, out, in, en, b);
&lt;span style=&#34;color:#66d9ef&#34;&gt;inout&lt;/span&gt; tri_out;
&lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; out;
&lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; in, en, b;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; tri_inout&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;en&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;in:&amp;#39;bz;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; out&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tri_inout&lt;span style=&#34;color:#f92672&#34;&gt;^&lt;/span&gt;b;
    &lt;span style=&#34;color:#75715e&#34;&gt;//tri_inout 端口输出 in 信号，输入信号转交 out
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;heading-6&#34;&gt;时序逻辑电路设计实例&lt;/h2&gt;
&lt;h3 id=&#34;d-&#34;&gt;D 触发器设计实例&lt;/h3&gt;
&lt;p&gt;D 触发器目前正在逐渐替代已经淘汰的 JK 触发器，本设计以 D 触发器为设计对象。D 触发器在时钟上升沿同步输入输出。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; dff(q, data, clk);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; q;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; data, clk;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; q;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;always&lt;/span&gt; @(&lt;span style=&#34;color:#66d9ef&#34;&gt;posedge&lt;/span&gt; clk)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
        q&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;data;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;heading-7&#34;&gt;电平敏感型锁存器设计实例&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;设计方案1&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; latch1(q, data, clk);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; q;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; data, clk;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; q&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;clk&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;data:q;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;
&lt;li&gt;设计方案2&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; latch1(q, data, clk);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; q;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; data, clk;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; q; &lt;span style=&#34;color:#75715e&#34;&gt;//因为要用 always 块
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;always&lt;/span&gt; @(clk &lt;span style=&#34;color:#66d9ef&#34;&gt;or&lt;/span&gt; data)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(clk)
        q&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;data;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;heading-8&#34;&gt;带置位和复位端口的电平敏感型锁存器设计实例&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; latch2(q, data, clk, set, reset);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; q;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; data, clk, set, reset;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; q&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;reset&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;(set&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;(clk&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;data:q));
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;heading-9&#34;&gt;移位寄存器设计实例&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; shifter(din, clk, clr, dout);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; din, clk, clr;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] dout;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] dout;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;always&lt;/span&gt; @(posegde clk)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(clr)
            dout&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;&amp;#39;b0&lt;/span&gt;;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
            dout&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;dout&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
            dout[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;din;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;8--1&#34;&gt;8 位计数器的设计实例&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;设计实例1&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; counter1(out, cout, data, load, cin, clk);
&lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] out;
&lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; cout;
&lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] data;
&lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; load, cin, clk;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] out;

&lt;span style=&#34;color:#66d9ef&#34;&gt;always&lt;/span&gt; @(&lt;span style=&#34;color:#66d9ef&#34;&gt;posedge&lt;/span&gt; clk)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(load)
            out&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;data;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
            out&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;out&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;cin;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; cout&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;out)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cin;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;设计实例2&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; counter2(out, cout, data, load, cin, clk);
&lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] out;
&lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; cout;
&lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] data;
&lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; load, cin, clk;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] out;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; cout;
&lt;span style=&#34;color:#66d9ef&#34;&gt;reg&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] preout;

&lt;span style=&#34;color:#66d9ef&#34;&gt;always&lt;/span&gt; @(posegde clk)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
        out&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;preout;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;always&lt;/span&gt; @(out &lt;span style=&#34;color:#66d9ef&#34;&gt;or&lt;/span&gt; data &lt;span style=&#34;color:#66d9ef&#34;&gt;or&lt;/span&gt; load &lt;span style=&#34;color:#66d9ef&#34;&gt;or&lt;/span&gt; cin)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;begin&lt;/span&gt;
        {cout, preout}&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;out&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;cin;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(load)
            preout&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;data;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>Adder and Multiplier in FPGA</title>
      <link>https://xiahualiu.github.io/posts/2018-08-07-claa/</link>
      <pubDate>Tue, 07 Aug 2018 10:48:30 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2018-08-07-claa/</guid>
      <description>&lt;p&gt;本文将会就在 FPGA 中如何实现加法器与乘法器进行一个简单的介绍，并且在后面提供了一些优化的方法。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;加法器&lt;/h2&gt;
&lt;p&gt;加法器在《数字电路》课程中大家都有学过，在课程中提到两种加法电路，也即 &lt;strong&gt;半加器&lt;/strong&gt; 和 &lt;strong&gt;全加器&lt;/strong&gt;。半加器没有进位输入有进位输出，而全加器既具有进位输入也有进位输出。全加器的端口有 5 个，分别为 $X，Y，C_{i-1}，S，C_i$。$X$，$Y$ 是两个加数，$S_i$ 表示和，$C_{i-1}$ 为来自低位的进位，$C_i$ 为向高位的进位。从真值表中我们很容易写出以下的逻辑表达式：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;$X_i$&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;$Y_i$&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;$C_{i-1}$&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;$S_i$&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;$C_i$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;$$C_i=X_iY_i+Y_iC_{i-1}+X_iC_{i-1}$$&lt;/p&gt;
&lt;p&gt;$$S_i=X_i\overline{C_i}+Y_i\overline{C_i}+C_{i-1}\overline{C_i}+X_iY_iC_{i-1}$$&lt;/p&gt;
&lt;p&gt;令 $P_i=X_i\oplus Y_i \quad G=X_i \cdot Y_i$ ,我们可以将逻辑式化简为以下形式。（$S_i$ 的形式就是三连异或的展开式，请牢记）。&lt;/p&gt;
&lt;p&gt;$$S_i=P_i \oplus C_{i-1}$$&lt;/p&gt;
&lt;p&gt;$$ C_i=P_i \cdot C_{i-1} + G_i$$
对于卡诺图(Karnaugh Map)的化简得到逻辑表达式我们不做过多的介绍。&lt;/p&gt;
&lt;p&gt;由于具有进位输入和输出，我们所列出来的一位全加器，拥有了与更多全加器串行连接，组成多位加法器的功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-8-7-CLAA/Serial-Adder.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图我们可以看到，计算的过程是一个串行的过程，也就是最后的 $C_{out}$ 信号需要从一开始的 $C_{in}$ 一直传递到最后，经过了多少的门呢？我们可以将每个全加器拆开来看一下内部的结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-8-7-CLAA/Full-Adder.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;图中的红线就是计算中，进位信号所经过的路线，这个路线在模块中是最长的，一共是 9 个门电路，而由于数字电路的物理特性，存在两种延迟(Propagation Delay)，一种是门延迟(Gate Delay)，另一种是线延迟（Line Delay）在本例中忽略。一个模块的延迟取决于它的最长延迟路径。&lt;/p&gt;
&lt;p&gt;串行的加法器的缺点就可以看出来了，在逐渐增加位数的同时，进位信号的传递路线会越来越长，而运行速度会越来越慢。对于一个32bit 的串行加法器，有总延迟时间：(2n+1)T =(2×32+1)×T =65T，这是什么概念呢？举个例子，iPhone 5s的A7 SoC处理器采用28nm制造工艺，主频1.3GHz（0.66ns）。按照这个工艺水平，门延迟 T 设为 0.02ns，那么 32-bit 串行加法器的延迟时间为1.3ns ，时钟频率为 769MHz，远超 A7 处理器的主频延迟时间，更别说这个 32bit 的 RCA 只是一个加法运算器，更更别说，我们在计算过程中只考虑了门延迟，还有线延迟等各种延迟没有加入计算……&lt;/p&gt;
&lt;p&gt;那么，如何改进这种现象呢？&lt;/p&gt;
&lt;p&gt;我们可以采用并行的思想，串行加法器的过程是，计算出前一个值，再带入另一个相同的过程中，如果将其转换成是代码，串行加法就类似于类似于函数迭代的方式，我们将进位信号计算过程写成一个递推的公式，将其展开就可以看出来了。使用这种求进位的方式的加法器被称作 &lt;strong&gt;超前进位加法器（Carry-Look-Ahead-Adder，CLA）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为：
$$ C_i=P_i \cdot C_{i-1} + G_i$$&lt;/p&gt;
&lt;p&gt;所以：&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
C_{out} &amp;amp;=P_3 \cdot C_2 + G_3 \&lt;br&gt;
&amp;amp;=P_3 \cdot (P_2 \cdot C_1 +G_2)+G_3\&lt;br&gt;
&amp;amp;=G_3+P_3 \cdot G_2+P_3 \cdot P_2 \cdot G_1+P_3 \cdot P_2 \cdot P_1 \cdot G_0+ \&lt;br&gt;
&amp;amp;\ P_3 \cdot P_2 \cdot P_1 \cdot P_0 \cdot C_{in}
\end{align}
$$&lt;/p&gt;
&lt;p&gt;化简得到的最后一行中的系数（$P_3, G_3, P_2, G_2&amp;hellip;$）都可以通过简单的或门和与门计算得到。我们将求 $C_{out}$ 进位信号的电路更改为以下的结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-8-7-CLAA/CLAA.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看出，我们最长路径被简化成为了 3 个门，但是相应的我们使用了更多的电路逻辑门资源。根据相同的方法，我们可以设计出求 $C_2, C_1,C_0$ 进位信号的方法，而他们的计算路径都只有三个门，将完整的电路画出来之后，这个电路图的就是 72LS283 超前进位加法器元件的内部结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://gss1.bdstatic.com/9vo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=e34dec20b27eca80060831b5f04afcb8/d53f8794a4c27d1e834771c719d5ad6eddc4384b.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到求进位的方式与我们上文的相同，但是仅仅是 4 位加法器就需要如此多的资源，如果是 32 位并行加法器，那么所需的门资源将会是一个巨大的数量，所以我们不能够完全使用并行加法器，而是使用多层并行的方式，稍微增加一些延迟，也就是路径上门的数量，而减少大量的资源使用。在实现 16 位二进制超前进位加法电路可以先使用 4 个 4 位超前进位加法器，和另一个 4 位超前进位形成。&lt;/p&gt;
&lt;p&gt;我们定义 $PX_0=P_3 \cdot P_2 \cdot P_1 \cdot P_0 \quad GX_0=G_3+P_3 \cdot G_2+P_3 \cdot P_2 \cdot G_1+P_3 \cdot P_2 \cdot P_1 \cdot G_0$。&lt;/p&gt;
&lt;p&gt;则可以得到 $C_4=GX_0+PX_0 \cdot C_0$ (这里的 $C_4$ 就是 上文中 $C_{out}$；$C_0$ 就是上文中 $C_{in}$)。&lt;/p&gt;
&lt;p&gt;定义 $PX_1=P_7 \cdot P_6 \cdot P_5 \cdot P_4 \quad GX_1=G_7+P_7 \cdot G_6+P_7 \cdot P_6 \cdot G_5+P_7 \cdot P_6 \cdot P_5 \cdot G_4$&lt;/p&gt;
&lt;p&gt;可以得到：&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
C_8 &amp;amp;= GX_1+PX_1 \cdot C_4 \&lt;br&gt;
&amp;amp;= GX_1 + PX_1 \cdot (GX_0+PX_0 \cdot C_0)\&lt;br&gt;
&amp;amp;= GX_1 + PX_1 \cdot GX_0 + PX_1 \cdot PX_0 \cdot C_0
\end{align}
$$&lt;/p&gt;
&lt;p&gt;我们验证了仅仅使用 $PX_i$ 和 $GX_i$ 两个信号就可以迭代得到每隔 4 位的进位信号。而这两个信号的计算，可以在每个小的超前进位加法器中进行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-8-7-CLAA/16-bit.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这种方法使得本来只需要 3 次门延迟的计算增加到了 6 次门延迟，但是节约的资源是很多的。&lt;/p&gt;
&lt;h3 id=&#34;-verilog-&#34;&gt;加法器 Verilog 实现&lt;/h3&gt;
&lt;p&gt;在 FPGA 中，加法器的描述很简单，简单到了一条加法指令就可以。而究竟是使用何种的门级结构结构，综合器会根据选项自动挑选一种基本的结构，当然我们也可以在 FPGA 的库中进行挑选，实例化我们的加法电路。&lt;/p&gt;
&lt;p&gt;对于 4 位加法器的描述：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; b4_adder(X, Y, sum, C);
&lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] X, Y;
&lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] sum;
&lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; C;

&lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; {C, sum} &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; X &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Y;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;heading-1&#34;&gt;并行乘法器与进位节省乘法器&lt;/h2&gt;
&lt;p&gt;并行乘法器又被称作移位乘法器，该乘法器的计算过程类似于手工计算，一次计算二进制一位，然后错位并列相加，二进制乘法的基本规则如下：&lt;/p&gt;
&lt;p&gt;$$ 0 \times 0=0;\quad 1 \times 0=0;\quad 1 \times 1=1$$&lt;/p&gt;
&lt;p&gt;逻辑为与门逻辑。而计算的过程我们可以简单地通过一张图来展示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-8-7-CLAA/times.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;快速乘法器使用网格形式的叠带阵列结构，每一个乘法单元被称作 &lt;strong&gt;MU(Multiplier Unit)&lt;/strong&gt;, 如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-8-7-CLAA/multiplier.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们观察发现，在第一行，所有的 MU 单元可以不含有全加器，仅有与门结构，因为第一行的数无进位；同理，每一行第一个 MU 单元也可以仅使用与门结构。并且，这种结构的乘法器同样可以使用超前进位加法器，如图所示，我们改良了这种结构，新结构被称作进位节省乘法器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-8-7-CLAA/new_m.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;-verilog--1&#34;&gt;乘法器器 Verilog 实现&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-verilog&#34; data-lang=&#34;verilog&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;module&lt;/span&gt; b4_mult(X, Y, Z);
&lt;span style=&#34;color:#66d9ef&#34;&gt;input&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] X, Y;
&lt;span style=&#34;color:#66d9ef&#34;&gt;output&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] Z;

&lt;span style=&#34;color:#66d9ef&#34;&gt;assign&lt;/span&gt; Z &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; X &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; Y;
&lt;span style=&#34;color:#66d9ef&#34;&gt;endmodule&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;乘法器和加法器的实现是根据用户的选择和约束文件决定的，在某些情况下，综合器还会实现流水线结构，以满足用户对于运算速度的需求。本文只是简单介绍了两种加法器和两种乘法器的结构，在实际的使用中，还是需要根据实际的需求在 FPGA 库和 ASIC 库中选择合适的加法器和乘法器结构。&lt;/p&gt;
&lt;p&gt;Verilog 和 VHDL 只是描述性语言，也就是代码不能直接翻译成为电路结构，综合器会在库中寻找对应的模型，将代码实例化。这与其他的计算机语言有些不同，因为相同的内容可以被翻译成为不同的电路结构，而我们可以控制。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Sorting Algorithms</title>
      <link>https://xiahualiu.github.io/posts/2018-07-27-sorting/</link>
      <pubDate>Fri, 27 Jul 2018 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2018-07-27-sorting/</guid>
      <description>&lt;p&gt;本文的内容是总结数据结构与算法中常见的几种排序算法，算是程序员的基本功之一。首先会从几种简单的排序算法开始，最后会逐渐涉及较为复杂的排序算法。&lt;/p&gt;
&lt;p&gt;在本文中，我们首先要约定，我们要排序的元素个数为 N，元素在数组中并且数组以下标 0 开始放置元素。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;插入排序&lt;/h2&gt;
&lt;p&gt;最简单的排序算法实现，在循环的第 N 步，确保前 N 个元素是排序的，相当于每次循环从尾部增加一个元素，并将该元素放置到正确的位置上去。&lt;/p&gt;
&lt;p&gt;代码实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;InsertionSort&lt;/span&gt;(ElementType A[], &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; N) {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; j, P;

	ElementType Tmp;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (P &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; P &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; N; P&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;) {
		Tmp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[P];
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; P; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; A[j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; Tmp; j&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;)
			A[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
		A[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Tmp;
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;初始&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;34&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;8&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;64&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;51&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;32&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;21&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;移动的次数&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;p=1 后&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;34&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;51&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;21&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;p=2 后&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;34&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;51&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;21&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;p=3 后&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;34&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;51&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;21&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;p=4 后&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;34&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;51&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;21&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;p=5 后&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;21&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;34&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;51&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;64&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这种排序的方式代表了所有的简单排序，包括了选择排序和冒泡排序，它们的时间复杂度可以从代码上显而易见的看出来是 &lt;em&gt;O(N^2)&lt;/em&gt;。而至于为什么简单排序不能突破 N^2 时间界，有一个很有意思的数学证明。&lt;/p&gt;
&lt;p&gt;对于一个需要排序的数组 A，它之中存在一个逆序，当数组中 i&amp;lt;j, 并且 A[i]&amp;gt;A[j]。例如对于上面的表格，存在 9 个逆序，分别是 (34, 8), (34, 32), (34, 21), (64, 32), (64, 21), (51, 32), (51, 21) 以及 (32, 21)。对于每次的相邻元素的交换，都仅仅消除一个逆序，而保证其他的逆序不发生变化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;定理：对于 N 个互异数的数组的平均逆序数是 N(N-1)/4。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这条定理证明：如果一个数组逆序数为 N，将该数组从尾到头重新构造一个反序数组，其逆序数和 N 互补，和为总的元素两两组合的数量，即为 N(N-1)/2。所以平均逆序数为和的一半，也就是 N(N-1)/4。&lt;/p&gt;
&lt;p&gt;而因此，我们在简单排序算法中，每次元素交换只能减少一个逆序，平均需要的时间就是 N(N-1)/4 = Ω(N^2) 时间。&lt;/p&gt;
&lt;p&gt;所以根据我们理论推导，若是一个排序算法想要超过 N^2 的时间界，就必须每次交换超过一个逆序数，这就要求交换的两个对象尽可能远。&lt;/p&gt;
&lt;p&gt;在代码中，我们使用到了如下的一个技巧：&lt;strong&gt;在排序中避免使用交换&lt;/strong&gt;，交换是一个相对低效的方法，特别在连续相邻元素的交换中。我们可以先用一个临时变量储存起来需要插入的新值，然后从后向前比较与元素值的大小，若当前循环元素大于要插入的新值，则向后移一位，直到比较到小于新值的元素停止，并在该位置插入新值。&lt;/p&gt;
&lt;h2 id=&#34;shellsort&#34;&gt;希尔排序(Shellsort)&lt;/h2&gt;
&lt;p&gt;希尔排序又被称为缩小增量排序，每次交换的元素之间存在一个距离。在第 k 次循环中，比较元素的间隔为 &lt;em&gt;hk&lt;/em&gt;，我们保证对于任意 i，A[i]&amp;lt;=A[i+hk]，我们就称数组是 hk-排序的 (hk-sorted)。希尔排序的重要性质是，在接下来的循环中，尽管 h(k-1) 小于 hk，数组依旧能够保持 hk-排序的性质。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;初始&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;81&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;94&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;11&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;96&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;12&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;35&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;17&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;95&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;28&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;58&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;41&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;75&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;15&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5-排序后&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;35&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;17&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;28&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;41&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;75&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;15&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;96&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;58&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;81&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;94&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;95&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3-排序后&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;28&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;35&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;15&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;41&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;58&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;17&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;94&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;75&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;81&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;96&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;95&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1-排序后&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;15&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;17&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;28&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;35&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;41&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;58&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;75&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;81&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;94&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;95&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;96&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;希尔排序中对于 hk 的选择决定了其时间界的大小，而对于一个较为简单的选择，我们可以选择一开始的 h 为元素数量的一半，而每次循环的 hk 都是上一次的一半，实现的代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Shellsort&lt;/span&gt;(ElementType A[], &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; N) {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i, j, Increment;
	ElementType Tmp;

	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (Increment &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; N &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;; Increment &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; Increment &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Increment; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; N; i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;) {
			Tmp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[i];
			&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i; j &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Increment &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; A[j&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;Increment] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; Tmp; j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Increment)
					A[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; Increment];
			A[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Tmp;
		}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这次依旧使用了之前插入排序中使用的 &lt;strong&gt;避免交换&lt;/strong&gt; 的方法。代码类似于插入排序，只不过比较时加上了间隔 Increment 变量。每次 Increment 确定后，其实之后做的事情就是一个间隔 Increment 元素序列的插入排序。&lt;/p&gt;
&lt;h3 id=&#34;-hk&#34;&gt;如何选择 hk&lt;/h3&gt;
&lt;p&gt;想要更好地选择 hk 的值，可以使用 Hibbard 增量。Hibbard 增量的列为形如：1，3，7 &amp;hellip; 2^k-1 的序列，这些序列相邻之前没有公因子，而且有研究证明，使用 Hibbard 增量的最差情况运行时间为 &lt;em&gt;O(N^(3/2))&lt;/em&gt;。证明这个时间常量需要使用到堆垒数论中某些众为所知的结果，我们不在这里详细描述。&lt;/p&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;堆排序&lt;/h2&gt;
&lt;p&gt;在先前的章节（&lt;a href=&#34;https://eggycat.coding.me/2018/07/24/Priority_Queue/&#34;&gt;优先队列（堆）知识点&lt;/a&gt;）中介绍了几种常见的堆模型，我们知道堆中的 DeleteMin 排序时间边界为 &lt;em&gt;O(N*logN)&lt;/em&gt;（每次为 logN，共 N 次），而构造堆的时间花费最坏情况为 &lt;em&gt;O(N)&lt;/em&gt;。所以我们有总时间&lt;em&gt;O(N+N*logN)&lt;/em&gt;，也就是 &lt;em&gt;O(N*logN)&lt;/em&gt; 的时间边界，这样的边界是我们目前看到的最好的时间值，但是在实践中却低于 &lt;em&gt;Sedgewick&lt;/em&gt; 增量序列的希尔排序。&lt;/p&gt;
&lt;p&gt;但是使用二叉堆排序有一个问题，就是需要一个额外的数组用于构建二叉堆，这造成了空间上的花费。从排序后的二叉堆数组拷贝回原数组时时间为 &lt;em&gt;O(N)&lt;/em&gt;，不会显著影响运行时间。&lt;/p&gt;
&lt;p&gt;具体的实现过程就是先使用原数组的数据，构建一个二叉堆，在这个过程中，时间花费为 O(N)。然后逐步的 DeleteMax（之前二叉树是递增树，但是可以很简单的改成递减树），这个地方有一个小技巧，我们只用到二叉树的下滤操作，每次将二叉堆堆首元素与堆尾交换，然后对于堆头进行下滤操作，将二叉堆堆序性恢复，并且最大值被放置在了堆尾，缩减二叉堆的大小，我们就将最大值固定在了最后。逐步循环就得到了递增的排序。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define LeftChild(i) (2 * (i) + 1)&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PercDown&lt;/span&gt;(ElementType A[], &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; N) {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Child;
	ElementType Tmp;

	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (Tmp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[i]; LeftChild(i) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; N; i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Child) {
		Child &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; LeftChild(i);
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (Child &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; N &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; A[Child &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; A[Child])
			Child&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (Tmp &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; A[Child])
			A[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[Child];
		&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
			&lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
	}
	A[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Tmp;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Heapsort&lt;/span&gt;(ElementType A[], &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; N) {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i;

	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; N &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;/* Build Heap Question: WHY i=N/2 */&lt;/span&gt;
		PercDown(A, i, N);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; N &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;) { &lt;span style=&#34;color:#75715e&#34;&gt;/* DeleteMax */&lt;/span&gt;
		Swap(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;A[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;A[i]);
		PercDown(A, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, i);
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;heading-2&#34;&gt;堆排序的分析&lt;/h4&gt;
&lt;p&gt;堆排序第一阶段最多用到 2N 次比较，第二阶段最多用到 2[logi] 次比较。堆排序是一个非常稳定的算法：它平均使用的比较和最坏情形接近，只是略少。直到最近，也没有人能够指出堆序排序平均运行时间的非平凡界。&lt;/p&gt;
&lt;h2 id=&#34;heading-3&#34;&gt;归并排序&lt;/h2&gt;
&lt;p&gt;归并排序以 &lt;em&gt;O(N*logN)&lt;/em&gt; 最坏情形运行时间运行，但是比较的次数几乎是最优的。它是递归算法的一个很好的实例。&lt;/p&gt;
&lt;p&gt;我们首先假设我们拥有了两个已经排序完成的表 A B，因为这两个表是已经排序完成的，若将其两个表合并成为一个排序的表 C 可以简单地通过一趟比较完成，对于一开始两个指针 Aptr 和 Bptr 被分别放在两个表的开头，然后比较指向的数据大小，较小的值会被放入 C，然后将较小值指针 +1，继续排序，当两个输入表有一个被用完的时候，则将另外一个表的剩余内容直接拷贝入 C。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-7-27-Sorting/mergesort.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;合并两个已排序表的时间是线性的，因为最多进行了 N-1 次比较，每次比较都至少添加进一个元素，而最后的那一次添加可以直接添加两个元素进去。&lt;/p&gt;
&lt;p&gt;用递归表示归并排序：如果 N = 1，那么 A B 加起来就一个元素，直接将元素放置进 C 即可。否则，将前半部分和后半部分各自使用归并排序，并将结果使用合并算法合并。&lt;/p&gt;
&lt;p&gt;归并排序的原理并不难，理解起来也较为容易，但是在递归的时候很容易就陷入 &lt;strong&gt;尾递归&lt;/strong&gt; 的困境，我们下边的代码采用了一个共享的 &lt;code&gt;TmpArray&lt;/code&gt; 数组，数据归并的过程中的过程数据都会暂时储存在这里，暂存数组的大小和原数组大小一致就可以，在迭代的过程中，所有的 Merge 都使用同一个暂存数组。这样我们迭代的过程中没有临时数组变量的产生，也就减少了内存的消耗，但是这样也造成了一个缺点，我们每次迭代的时候，Merge 函数都要输入这个暂存数组的指针，这个指针需要在不同的迭代次数之间传递。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MSort&lt;/span&gt;(ElementType A[], ElementType TmpArray[], &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Left, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Right) {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Center;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (Left &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; Right) {
		Center &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (Left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Right) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
		MSort(A, TmpArray, Left, Center);
		MSort(A, TmpArray, Center &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, Right);
		Merge(A, TmpArray, Left, Center &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, Right);
	}
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Merge&lt;/span&gt;(ElementType A[], ElementType TmpArray[], &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Lpos, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Rpos, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; RightEnd) {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i, LeftEnd, NumElements, TmpPos;
	LeftEnd &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Rpos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
	TmpPos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Lpos;
	NumElements &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; RightEnd &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; Lpos &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;

	&lt;span style=&#34;color:#75715e&#34;&gt;/* Main Loop */&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (Lpos &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; LeftEnd&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;Rpos &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; RightEnd)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (A[Lpos] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[Rpos])
			TmpArray[TmpPos&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[Lpos&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;];
		&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
			TmpArray[TmpPos&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[Rpos&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;];

	&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (Lpos &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; LeftEnd)
		TmpArray[TmpPos&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[Lpos&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;];
	&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (RightEnd &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; RightEnd)
		TmpArray[TmpPos&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[Rpos&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;];

	&lt;span style=&#34;color:#75715e&#34;&gt;/* Copy back */&lt;/span&gt;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; NumElements; i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;, RightEnd&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;) {
		A[RightEnd] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Tmp[RightEnd];
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;heading-4&#34;&gt;归并排序的分析&lt;/h4&gt;
&lt;p&gt;通过分析归并排序，我们可以学习到分析递归程序的经典实例：我们必须根据运行的时间写出一个递归的关系。对于 N 个数归并的时间等于两个对半归并排序的时间加上复制的时间 O(N)。&lt;/p&gt;
&lt;p&gt;下面是公式的显示，公式用了 MathJax 这个 JS 插件，如果你是手机浏览的，可以通过长按公式修改 Math Setting-&amp;gt;Scale All Math 值缩放公式。&lt;/p&gt;
&lt;p&gt;$$ T(1)=1 $$&lt;/p&gt;
&lt;p&gt;$$ T(N)=2T(N/2)+N $$&lt;/p&gt;
&lt;p&gt;我们将等式两边同时除以 N。&lt;/p&gt;
&lt;p&gt;$$ \frac{T(N)}{N}=\frac{T(N/2)}{N/2}+1 $$&lt;/p&gt;
&lt;p&gt;该等式对于任意 N 均成立，所以我们带入 N/2, N/4&amp;hellip; ，并将它们左右式分别叠加。&lt;/p&gt;
&lt;p&gt;$$ \frac{T(N)}{N} + \frac{T(N/2)}{N/2} + &amp;hellip; =\frac{T(N/2)}{N/2}+ 1 + \frac{T(N/4)}{N/4} + 1 +&amp;hellip; $$&lt;/p&gt;
&lt;p&gt;消去左右都有的项，我们可以得到：&lt;/p&gt;
&lt;p&gt;$$ \frac{T(N)}{N}=\frac{T(1)}{1} + \log_2 N $$&lt;/p&gt;
&lt;p&gt;化简可以得到
$$T(N)=N\log_2N+N=O(N\log_{}N)$$&lt;/p&gt;
&lt;p&gt;虽然归并排序的运行时间是 &lt;em&gt;O(NlogN)&lt;/em&gt;，但是由于它需要一个和原本数据一样大的缓冲区作为数据暂存，所以在主存排序中很难应用。而且额外的拷贝操作也依赖于硬件的实现速度，在拷贝速度较慢的场合，将会大大拖慢排序速度。归并排序常常应用于外部排序当中，对于内部排序，人们还是会选择快速排序算法。&lt;/p&gt;
&lt;h2 id=&#34;heading-5&#34;&gt;快速排序&lt;/h2&gt;
&lt;p&gt;快速排序是目前在实践中已知的最快的排序算法。它的平均运行时间是 &lt;em&gt;O(NlogN)&lt;/em&gt;。该算法之所以特别快的原因是它具有非常精炼和高度优化的内部循环。&lt;/p&gt;
&lt;p&gt;快速排序是采用了类似于归并排序类似的分治算法。原理是在集合中寻找一个枢纽元，然后将集合分为大于枢纽元的部分和小于枢纽元的部分。然后将两部分继续使用快速排序，直到最后的集合中有一个或者无元素，直接返回。&lt;/p&gt;
&lt;h2 id=&#34;heading-6&#34;&gt;选取枢纽元&lt;/h2&gt;
&lt;h4 id=&#34;heading-7&#34;&gt;一种错误的做法&lt;/h4&gt;
&lt;p&gt;一种想当然的做法是将输入的第一个元素用于枢纽元。这对于输入是随机的情况下是可用的，但是大部分情况下，对于预排序的输入，这种只会让快速排序每次运行在最坏的状态下。&lt;/p&gt;
&lt;h4 id=&#34;heading-8&#34;&gt;安全的做法&lt;/h4&gt;
&lt;p&gt;安全的做法是随机选取枢纽元。一般来说这种策略是非常有效的，除非随机数生成器产生了问题。但是随机数的产生是昂贵的，根本减少不了算法其余部分的平均运行时间。&lt;/p&gt;
&lt;p&gt;事实上，完全随机的枢纽元的选择其实对于算法时间并没有什么帮助，因为最佳的选择是每一次都选中了正好能将数据分成两个数量相等的枢纽元，也就是集合的中值。但是选择中值的问题在于，我们无法获得中值位置，这需要大量的时间。所以我们采用了一种 &lt;strong&gt;三数中值分割法&lt;/strong&gt; 的方法，我们从集合头，集合中部，集合尾各取一个元素，并且使用这三个元素的中间值作为枢纽元。&lt;/p&gt;
&lt;h2 id=&#34;heading-9&#34;&gt;流程&lt;/h2&gt;
&lt;h4 id=&#34;heading-10&#34;&gt;集合分割&lt;/h4&gt;
&lt;p&gt;在选取完枢纽元后，需要对于集合进行分割，重新整理成为两部分，这里的思路是先将集合中的枢纽元放在末尾，并且一个指针从头到尾滑过小于枢纽元的元素，一个指针从尾到头滑过大于枢纽元的元素，直到两个指针停下来，这时交换两个指针的元素，最后指针跨过另外一个指针，结束，将枢纽元从末尾和其中一个指针交换即可。&lt;/p&gt;
&lt;p&gt;但是如果出现了等于枢纽元的元素，就要注意了，因为如果我们在此位置停下来，进行交换，其实是无意义的交换，但是这样有一个好处就是可以保证指针不会一次性滑过较多元素而导致两个最后划分的集合不均衡，所以我们的策略是遇到与枢纽元值相等的元素，依旧会停下指针，等待交换。&lt;/p&gt;
&lt;h4 id=&#34;heading-11&#34;&gt;小数组&lt;/h4&gt;
&lt;p&gt;在递归的过程中，会产生很多小的数组，对于很小的数组（N&amp;lt;20)，快速排序的效率甚至不如插入排序，这时因为快速排序采用了递归的方法。所以我们可以在快速排序中使用插入排序来处理小数组，而使用快速排序来处理大问题，这样不仅仅能够解决效率的问题，而且可以避免诸如三数中值分割法出现只有两个或一个元素的问题。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;ElementType &lt;span style=&#34;color:#a6e22e&#34;&gt;Median3&lt;/span&gt;(ElementType A[], &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Left, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Right) {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Center &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (Left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Right) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (A[Left] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; A[Center])
		Swap(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;A[Left], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;A[Center]);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (A[Left] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; A[Right])
		Swap(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;A[Left], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;A[Right]);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (A[Center] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; A[Right])
		Swap(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;A[Center], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;A[Right]);

	Swap(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;A[Center], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;A[Right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; A[Right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
}

&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define Cutoff(3)&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Qsort&lt;/span&gt;(ElementType A[], &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Left, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Right) {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; i, j;
	ElementType Pivot;

	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (Left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Cutoff &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Right) {
		Pivot &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Median3(A, Left, Right);
		i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Left; j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (;;) {
			&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (A[&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; Pivot) {}
			&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (A[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; Pivot) {}
			&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; j)
				Swap(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;A[i], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;A[j]);
			&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
				&lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
		}
		Swap(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;A[i], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;A[Right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]);

		Qsort(A, Left, i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
		Qsort(A, i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, Right);
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
		InsertSort(A &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Left, Right &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; Left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;heading-12&#34;&gt;对于大型结构的排序&lt;/h2&gt;
&lt;p&gt;对于大型结构的排序，首先因为结构的性质使得复制的操作很难以进行，我们可以使用一个序列指针的方法，将指向结构的指针放置在一个数字中并对指针排序即可。这种排序被称作 &lt;strong&gt;间接排序&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;heading-13&#34;&gt;桶式排序&lt;/h2&gt;
&lt;p&gt;桶式排序是一个很神奇的排序方法，因为他只需要线性的时间就可以对于数组进行排序。但是桶式排序的要求比较严格，被排序的元素必须是整数且是不大于 M 的，我们用另外一个大小为 M 初始化为 0 的数组，对于集合中任意一个元素，数组中都有一个下标与之对应，我们顺序记录元素在桶中不同位置的出现次数，譬如对于 3,8,2,4,5,1,3 序列使用一个 M=8 的数组，输入 3 则 M[3]++，输入 8，M[8]++。直到最后，按照值作为次数，打印出数组中的下标即可。桶式排序在较小的整数输入中效率很高。&lt;/p&gt;
&lt;p&gt;为什么桶式排序能够打破 &lt;em&gt;O(NlogN)&lt;/em&gt; 下界，其实很简单，因为桶式排序其实原理上使用的是一个 M-路选择器，和我们之前的两元比较不同，桶式排序一次性进行了 M 元比较，并最终确定了元素的位置。&lt;/p&gt;
&lt;h2 id=&#34;heading-14&#34;&gt;外部排序&lt;/h2&gt;
&lt;p&gt;我们先前的排序，都是指内部排序，也就是集合储存在内存中，不考虑数据的读取和写入的时间消耗，但实际上，如果我们要将位于硬盘上的数据排序，或者位于磁盘上的数据进行排序，读取时间和写入时间会成为排序算法的瓶颈。&lt;/p&gt;
&lt;h3 id=&#34;heading-15&#34;&gt;简单算法&lt;/h3&gt;
&lt;p&gt;简单的外部排序算法是使用归并排序中的 Merge 程序，我们需要用到两个磁带或者存储器件，设内存一次可以存储 M 个元素，我们就先从一个磁带中读取 M 个元素，使用内部排序将这些数据排序后，再把这些排过序的记录交替的写在两个磁盘上，这些排过序的记录叫做 &lt;strong&gt;顺串&lt;/strong&gt;。当我们获得顺串之后，使用归并排序中的合并操作，将顺串成对合并即可。&lt;/p&gt;
&lt;h3 id=&#34;heading-16&#34;&gt;多路合并&lt;/h3&gt;
&lt;p&gt;如果我们有好几个外部存储设备，这时候可以使用多路合并，也就是一次性对于多个顺串使用归并排序，将两路归并拓展到多路是很简单的，所以我们不做特别的描述。&lt;/p&gt;
&lt;h2 id=&#34;heading-17&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;对于一般的内部排序应用，我们的选择只有三种，插入排序，希尔排序，快速排序，它们的选择主要是根据输入的规模决定的。归并排序的效率较低，但是它却是外部排序的关键思想。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Priority Queue/Heap</title>
      <link>https://xiahualiu.github.io/posts/2018-07-24-priority_queue/</link>
      <pubDate>Tue, 24 Jul 2018 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2018-07-24-priority_queue/</guid>
      <description>&lt;p&gt;在本文中将会对于 &lt;strong&gt;优先队列（Priority Queue）&lt;/strong&gt; 的几种实现方式进行详细的叙述，优先队列在日常中的使用非常普遍，在学校里面的打印机打印文件的时候，应该对于文件的页数进行排序，首先打印页数最少的文件，最后处理页数最多的文件，虽然在队列中，文件提交的顺序并不是这样的。（但是现在的大多数打印机都不会这样做，譬如我们学校的打印机）。&lt;/p&gt;
&lt;p&gt;在系统中，操作系统调度程序必须决定在若干进程中运行哪个进程。一般情况下，一个进程只能被允许运行一个固定的时间片（在这里不考虑进程并行情况）。一种算法是使用队列，调度时一直从队首拿出作业进行，在队尾增加作业。但是更优的情况是，短的作业要尽可能快的结束，因为短的作业重要性和长的相同；有些情况下，即使作业很长，但是由于其具有优先级，也应该首先对其进行处理。&lt;/p&gt;
&lt;p&gt;本文将讨论以下的内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优先队列 ADT 的有效实现&lt;/li&gt;
&lt;li&gt;优先队列的使用&lt;/li&gt;
&lt;li&gt;优先队列的高级实现&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;我们将看到的这类数据结构属于计算机科学中最讲究的一种。
&amp;mdash;&lt;em&gt;《Data Structure and Algorithm Analysis in C》&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这也是为什么要为这一章单独记录的原因。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;模型&lt;/h2&gt;
&lt;p&gt;由于是队列，所以优先队列的模型与队列相同，&lt;strong&gt;入队（Enqueue）&lt;/strong&gt;，和 &lt;strong&gt;出队（Dequeue）&lt;/strong&gt;，但是与普通队列不同的是，这里的出队是踢出优先级最高的元素。在计算机科学中，优先级一般使用数字（0，1，2，3&amp;hellip;）表示，优先级越高的元素，其对应的数字就会越低。所以在模型的操作中，我们将出队称为 &lt;strong&gt;删除最小值（DeleteMin）&lt;/strong&gt;，入队称为 &lt;strong&gt;插入（Insert）&lt;/strong&gt;，但这两种操作的作用和原有的普通队列相同，只不过出队操作略有改变。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;软件工程界目前认为删除最小值并不是个很好的思路，不过出于历史原因我们继续使用这个函数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-7-24-Priority_Queue/module.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;一些简单的实现&lt;/h2&gt;
&lt;p&gt;最简单的实现是使用链表，在链表的表头以 &lt;em&gt;O(1)&lt;/em&gt; 执行插入操作，以 &lt;em&gt;O(n)&lt;/em&gt; 遍历链表以寻找最小元删除，另外一种办法是使链表一直保持排序状态，这会使插入操作成为 &lt;em&gt;O(n)&lt;/em&gt;，删除操作成为 &lt;em&gt;O(1)&lt;/em&gt;。但是在队列中，删除操作从来不会多于插入操作，所以前者的办法更好。&lt;/p&gt;
&lt;p&gt;另外的一种办法是使用二叉查找树，二叉树使得元素的插入和删除操作平均时间都是 &lt;em&gt;O(logN)&lt;/em&gt;。但是使用二叉查找树似乎有点过分，因为我们只需要很少的操作，而二叉树的功能过于强大，而且与指针有关。在这里我们使用了一种新的数据结构，它将不需要指针，并以最坏情况 &lt;em&gt;O(logN)&lt;/em&gt; 支持这两种操作。然后我们讨论如何合并它们，在合并的过程中，我们要使用到指针。&lt;/p&gt;
&lt;h2 id=&#34;heading-2&#34;&gt;二叉堆&lt;/h2&gt;
&lt;p&gt;它叫做 &lt;strong&gt;二叉堆（binary heap）&lt;/strong&gt;，它对于优先队列如此普遍，以至于只要提起 &lt;strong&gt;堆（heap）&lt;/strong&gt;，我们就认为是这种数据结构。&lt;/p&gt;
&lt;h3 id=&#34;heading-3&#34;&gt;结构性质&lt;/h3&gt;
&lt;p&gt;堆是一种完全被填满或者即将被填满的二叉树，即使底部可能有些没有填满，但是元素从顶到底依次填入二叉树的各个部位。由于其规律很显著，我们可以使用一个数组来表示它。如图，树中的数字对应着它们在数组内的位置。至于为什么根不是 0 位置，我们在下部分来讨论。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-7-24-Priority_Queue/binary_heap.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;显然，对于下标为 i 的元素，使用 i/2 可以访问其父节点，使用 2i 可以访问其左子树，使用 2i+1 索引可以访问其右子树，相比于指针，这样的访问方式更加快捷，缺点就是元素只能是连续分布的数组类型，树必须是满二叉树。堆的大小，等于我们声明数组时候的数组长度。&lt;/p&gt;
&lt;h3 id=&#34;heading-4&#34;&gt;创建二叉堆&lt;/h3&gt;
&lt;p&gt;我们使用如下的代码创建二叉堆：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define ElementType int&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define MinValue 0&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; HeapStruct {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Capacity;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; Size;
	ElementType &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;Elements;
}&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;PriorityQueue;

&lt;span style=&#34;color:#75715e&#34;&gt;//初始化堆
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;PriorityQueue &lt;span style=&#34;color:#a6e22e&#34;&gt;PQInitialize&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; MaxElements);
&lt;span style=&#34;color:#75715e&#34;&gt;//销毁堆
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PQDestroy&lt;/span&gt;(PriorityQueue H);
&lt;span style=&#34;color:#75715e&#34;&gt;//清空堆
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;MakeEmpty&lt;/span&gt;(PriorityQueue H);
&lt;span style=&#34;color:#75715e&#34;&gt;//插入元素
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Insert&lt;/span&gt;(ElementType X, PriorityQueue H);
&lt;span style=&#34;color:#75715e&#34;&gt;//打印目前堆的形状
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PrintPQ&lt;/span&gt;(PriorityQueue H);
&lt;span style=&#34;color:#75715e&#34;&gt;//出队
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;ElementType &lt;span style=&#34;color:#a6e22e&#34;&gt;DeleteMin&lt;/span&gt;(PriorityQueue H);
&lt;span style=&#34;color:#75715e&#34;&gt;//寻找下一个出队元素
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;ElementType &lt;span style=&#34;color:#a6e22e&#34;&gt;FindMin&lt;/span&gt;(PriorityQueue H);
&lt;span style=&#34;color:#75715e&#34;&gt;//堆是否为空
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;IsEmpty&lt;/span&gt;(PriorityQueue H);
&lt;span style=&#34;color:#75715e&#34;&gt;//减少关键字的值(增大优先级)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DecreaseKey&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; P,&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; delta,PriorityQueue H);
&lt;span style=&#34;color:#75715e&#34;&gt;//增大关键字的值(减少优先级)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;IncreaseKey&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; P, &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; delta, PriorityQueue H);
&lt;span style=&#34;color:#75715e&#34;&gt;//删除一个元素
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DeleteKey&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; P, PriorityQueue H);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;详细的各种函数实现方法在我写的对应的 &lt;a href=&#34;https://git.coding.net/Eggycat/DSAA.git&#34;&gt;repo&lt;/a&gt; 中的 &lt;code&gt;Priority_Queue&lt;/code&gt; 中，不具体介绍。&lt;/p&gt;
&lt;h2 id=&#34;d-&#34;&gt;d-堆&lt;/h2&gt;
&lt;p&gt;d-堆，又被称作多叉堆，是一个完全的多叉树，与二叉堆相比，多叉堆的优点在于减少了 &lt;code&gt;Insert&lt;/code&gt; 的时间，因为树的层树少了，而 &lt;code&gt;Insert&lt;/code&gt; 操作的最坏时间就是元素从最底层升到根，与层数多少有关，为 &lt;em&gt;O(logdN)&lt;/em&gt;。而 &lt;code&gt;DeleteMin&lt;/code&gt; 操作由于有相邻元素的比较过程，多叉堆的效率就显著下降，为 &lt;em&gt;O(d&lt;/em&gt;logdN)*，d 堆的使用和 B 树使用类似，在磁盘上读写数据时效率高于二叉堆。&lt;/p&gt;
&lt;h2 id=&#34;heading-5&#34;&gt;左式堆&lt;/h2&gt;
&lt;p&gt;左式堆的实现是为了简化两个二叉堆的合并过程，左式堆的定义如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们把任一节点 X 的 &lt;strong&gt;零路径长（NPL）&lt;/strong&gt; &lt;em&gt;Npl(X)&lt;/em&gt; 定义为从 &lt;em&gt;X&lt;/em&gt; 到一个没有两个儿子的节点的最短路径的长度。具有一个或者零个节点的 &lt;em&gt;Npl(X)&lt;/em&gt; 为 0，而 *Npl(NULL)*=-1。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;左式堆：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;中任意节点的左儿子零路径长要大于等于右儿子零路径长。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;定理：在右路径上有 r 个节点的左式树必然至少有 2^r-1 个节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-7-24-Priority_Queue/leftist_heap.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading-6&#34;&gt;左式堆的合并（重点）&lt;/h2&gt;
&lt;p&gt;合并是左式堆的基本操作。插入可以看做是一个单节点树的合并。合并的过程是一个递归的过程，怎么理解呢，就是左式堆的两个子树一定也是左式堆，我们可以从一个基本状态开始，逐步分析递归合并的过程：确保合并过后每个节点的左子树右子树均为左式堆，并保证根节点满足左式堆要求。&lt;/p&gt;
&lt;h4 id=&#34;heading-7&#34;&gt;合并的过程中的类型&lt;/h4&gt;
&lt;p&gt;对于左式堆 H1&amp;lt;-H2 的合并的过程有三种类型，第一种是 H1 的左子树为空，在这种条件下，我们可以直接将 H2 置为 H1 左子树，因为在左式堆中左子树为空意味着右子树也为空，H1 是一个单节点左式堆，直接合并的操作是安全的。并且这样甚至不会改变 H1 根节点的 &lt;em&gt;Npl&lt;/em&gt; 值，它依旧为 0。&lt;/p&gt;
&lt;p&gt;第二种为 H1 的右子树为空，这种状态下，我们将 H2 置为 H1 的右子树，因为 H2 是左式堆，H1 的左子树也是左式堆，故我们只要确保合并后的 H1 根节点的零路径长满足要求即可，也就是此时 H1 根节点左零路径长于右路径，若不满足则将其左右子树交换位置，最后我们将 H1 根节点的 &lt;em&gt;Npl&lt;/em&gt; 值变成两者中最小值加一，就完成了合并的过程。&lt;/p&gt;
&lt;p&gt;但是很多情况下，这种状态并不常发生，H1 通常左右子树已经有子树了，那怎么办呢？没关系，我们一直顺着 H1 的右子树路径走下去，直到找到有一个满足我们第一或第二种类型的节点 H1* 即可，因为 H1 是左式堆，子树的每一个节点都满足左式堆的条件，我们这个时候就视作 H1* 为第一或第二种类型中的左式堆根节点，将 H1* 和 H2 合并。但是在第二种类型中，我们修改的 Npl 值会影响父节点的零路径长，故我们要依次向上检查，有可能要交换好几次左右子树的位置，而第一种类型的合并是安全的，我们无需再去考虑。&lt;/p&gt;
&lt;p&gt;有的时候，在 H1 向右寻找儿子的过程中，有可能会遇到 H1 的子节点值小于 H2 根节点值大小的情况，我们只需要交换 H1* H2 的顺序即可，也就是本来是 H1*&amp;lt;-H2 合并，改为 H2&amp;lt;-H1*，合并完的结果是 H1 树中的某些点被 H2 给先合并了，然后带有 H1 某些节点的 H2 左式堆又被 H1 合并了，实际的元素并没有丢失，只不过在 H1 和 H2 之间进行了位置的互换。&lt;/p&gt;
&lt;p&gt;详细实现的代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SwapChildren&lt;/span&gt;(PriorityQueue L) {
	PriorityQueue temp;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (L &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;;
	temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; L&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Left;
	L&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; L&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Right;
	L&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; temp;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; PriorityQueue &lt;span style=&#34;color:#a6e22e&#34;&gt;Merge1&lt;/span&gt;(PriorityQueue L1, PriorityQueue L2) {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (L1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL)
		L1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; L2;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
		L1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Merge(L1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Right, L2);
		&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (L1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Left&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Npl &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; L1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Right&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Npl)
			SwapChildren(L1);

		L1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Npl &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; L1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Right&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Npl &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
	}
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; L1;
}

PriorityQueue &lt;span style=&#34;color:#a6e22e&#34;&gt;Merge&lt;/span&gt;(PriorityQueue L1, PriorityQueue L2) {
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (L1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; L2;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (L2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; L1;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (L1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Element &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; L2&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Element)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Merge1(L1, L2);
	&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; Merge1(L2, L1);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;heading-8&#34;&gt;斜堆&lt;/h2&gt;
&lt;p&gt;斜堆与左式堆的关系如同伸展树和 AVL 树之间的关系，我们对于斜堆的合成使用与左式堆相同的方式，递归的生成合成树，但是在验证根的左式性时，我们都假设合并后右子树零路径长较长，直接进行交换，这样合成的树在大多数情况下是左式的，但是并不能保证。&lt;/p&gt;
&lt;p&gt;斜堆这个无需验证的性质使得斜堆的节点无需储存 Npl 值，使其具有较高的空间利用率，并且减少了验证过程的时间消耗。&lt;/p&gt;
&lt;p&gt;精确确定左式堆和斜堆的右路径长是一个悬而未决的问题。&lt;/p&gt;
&lt;h2 id=&#34;heading-9&#34;&gt;二项队列&lt;/h2&gt;
&lt;p&gt;二项队列使用了一个很有意思的思维，它使用了“森林”的数据结构，在二项队列中，有许多 &lt;strong&gt;堆序树&lt;/strong&gt; 组成，而这些树的元素个数都是 2 的倍数：高度为 0 的二项树是一棵单节点树；高度为 k 的二项树 B&lt;em&gt;k&lt;/em&gt; 由两棵高度为 B&lt;em&gt;k-1&lt;/em&gt; 的二项树组成，类似于二进制中的进位概念，最后组成的数据结构的形状如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-7-24-Priority_Queue/binomial_queue.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这样构造的森林结构和元素数量一一对应，譬如有 11 个元素，转换为二进制为：11=8+2+1=0b1011。则森林的结构为 B0，B1，B3。没有 B2，对应的二进制位也为 0。&lt;/p&gt;
&lt;p&gt;这样构造的堆序树森林，我们要寻找最小元素，只需要在森林各个树的根寻找，易得，时间复杂度是 &lt;em&gt;O(logn)&lt;/em&gt;。合并操作拥有与二进制相同的进位方法。合并两个相同结构树只需要将其中根节点值较大的树附加在根节点值较小树的根上就可以了。&lt;/p&gt;
&lt;p&gt;为了方便遍历这个森林中的根节点，我们将其根节点放置在一个数组中。而由图可见，我们发现二项队列中的树不是二叉树，节点的子树数量不定，这样怎么用程序表示呢？我们可以通过一个简单的转变即可，将每一层中的相邻节点用链表穿起来，这些同一层的节点可以视作是 “兄弟” 而不是父子关系，因为兄弟之间没有大小顺序，而父子之间存在大小关系。图中的虚线就是表示这种关系。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-7-24-Priority_Queue/binomial_queue_new.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;每个节点的数据结构为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; BinNode{
	ElementType Element;
	Position Child;
	Position Sibling;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;进行合并的时候，很简单的操作，譬如两个二项队列 B1 和 B2 合并，B1 根元素小于 B2。故为 B1&amp;lt;-B2 合并，根据二项队列的结构我们可以知道合并的双方具有相同的形状。依旧使用递归，这个递归在树的合并中使用太广泛了，不讲解了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;BinTree &lt;span style=&#34;color:#a6e22e&#34;&gt;CombineTrees&lt;/span&gt;(BinTree T1, BinTree T2){
	&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt;(T1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Element &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; T2&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Element)
		&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; CombineTrees(T2, T1);
	T2&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Sibling&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;T1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Child;
	T1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;Child&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;T2;
	&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; T1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;heading-10&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;这一章我们介绍了数种常见的优先队列数据结构，它们各有各的优点和缺点，对于最常用的二叉堆，它的实现是简单和快速的，因为它平均仅仅需要常数时间的插入时间花费（最坏情况为 &lt;em&gt;logN&lt;/em&gt;，气泡法，从底浮到根），和 &lt;em&gt;logN&lt;/em&gt; 的删除时间花费(气泡法，每次删除几乎都是从根到底沉下，所以最坏也为 &lt;em&gt;O(logN)&lt;/em&gt;)，但是它对于合并的支持较差，时间边界为 &lt;em&gt;O(N)&lt;/em&gt;。左式堆和斜堆对于插入，合并，和删除的操作，时间边界均为 &lt;em&gt;O(logN)&lt;/em&gt;。二项队列以 &lt;em&gt;O(logN)&lt;/em&gt; 时间边界支持这三种操作，并且对于插入操作，平均花费常数时间。&lt;/p&gt;
&lt;p&gt;具体使用哪一种还是要看具体的数据性质咯。Peace out~&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linking (CSAPP Reading Notes)</title>
      <link>https://xiahualiu.github.io/posts/2018-07-13-csapp-link/</link>
      <pubDate>Fri, 13 Jul 2018 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2018-07-13-csapp-link/</guid>
      <description>&lt;h2 id=&#34;heading&#34;&gt;静态链接&lt;/h2&gt;
&lt;p&gt;像Linux LD 程序这样的 &lt;strong&gt;静态链接器（static linker）&lt;/strong&gt; 以一组可重定位目标文件和命令行参数作为输入，神成一个完全链接的、可以加载和运行的可执行目标文件作为输出。输入的可重定位目标文件由各种不同的代码和 &lt;strong&gt;数据节&lt;/strong&gt; 组成，每一节都是一个连续的字节序列。指令在一节中，初始化了的全局变量在另一节中，而未初始化的变量又在另外一节中。&lt;/p&gt;
&lt;p&gt;构建可执行文件前，链接器必须完成以下的两个主要任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;符号解析（symbol resolution）&lt;/strong&gt;。目标文件定义和引用符号，每个符号对应一个函数、一个全局变量或一个静态变量（也就是 C 语言中任何以 static 属性声明的变量）。符号解析的目的是将每个符号引用正好和一个符号定义关联起来。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;重定位（reallocation）&lt;/strong&gt;。编译器和汇编器生成正好从地址 0 开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而 &lt;em&gt;重定位&lt;/em&gt; 这些节，然后修改所有对于这些符号的引用，使得他们指向这个内存位置。链接器使用汇编器产生的 &lt;em&gt;重定位条目（relocation entry）&lt;/em&gt; 的详细指令，不加甄别地执行这样的重定位。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链接器的目标文件：**目标文件纯粹是字节块的集合。**在这些块中，有些包含程序代码，有些包含程序数据，而其他的则包含引导链接器和加载器的数据结构。链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置。链接器对目标机器的连接甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。&lt;/p&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;目标文件&lt;/h2&gt;
&lt;p&gt;目标文件有三种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可重定位目标文件&lt;/strong&gt;。包含二进制代码和数据，可以在编译的时候与其他的可重定位目标文件合并起来，创建一个可执行目标文件。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可执行目标文件&lt;/strong&gt;。包含二进制代码和数据，其形式可以被直接复制到内存中执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;共享目标文件&lt;/strong&gt;。一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载到内存并且链接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading-2&#34;&gt;可重定位目标文件&lt;/h2&gt;
&lt;p&gt;一个典型的 ELF 可重定位目标文件的格式。我们会在接下来的内容里逐条分析各个节的内容和作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-7-13-CSAPP-link/ELF_structure.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;ELF 头（ELF header）以一个 16 字节的序列开始，这个序列描述了生成该文件的系统的 &lt;strong&gt;字的大小&lt;/strong&gt; 和 &lt;strong&gt;字节顺序&lt;/strong&gt;。 ELF 头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括 &lt;strong&gt;ELF 头的大小&lt;/strong&gt;、&lt;strong&gt;目标文件的类型（如可重定位、可执行或可共享的）&lt;/strong&gt;、&lt;strong&gt;机器类型（如 x86-64）&lt;/strong&gt;、&lt;strong&gt;节头部表（section header table）的文件偏移&lt;/strong&gt;，以及节头部表中条目的大小和数量。不同节的位置和大小都是由节头部表描述的。其中目标文件中的每个节都有一个固定大小的条目（entry）。&lt;/p&gt;
&lt;p&gt;夹在 ELF 头和节头部表之间的都是 &lt;strong&gt;节（section）&lt;/strong&gt;。一个典型的 ELF 可重定位目标文件包含下面的几个节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.text&lt;/code&gt;：已经编译的机器代码。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.rodata&lt;/code&gt;：只读数据，比如 &lt;code&gt;printf&lt;/code&gt; 语句中的格式串和 &lt;code&gt;switch case&lt;/code&gt; 开关语句的跳转表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.data&lt;/code&gt;：已经初始化的全局和静态 C 变量。局部 C 变量在运行的时候被保存在栈中，既不会出现在 .data 中，也不会出现在 .bss 节中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.bss&lt;/code&gt;：未初始化的全局变量和静态 C 变量，以及所有被初始化为 0 的全局或静态变量。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化的变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为 0。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;symtab&lt;/code&gt;：一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。一些程序员错误的认为必须通过 &lt;code&gt;-g&lt;/code&gt; 选项来编译一个程序，才能得到符号表信息。实际上，每个重定位目标文件在 .symtab 中都有一张符号表（除非程序员特意用 STRIP 明朗去掉它）。然而，和编译器中的符号表不同，.symtab 符号表不包含局部变量的条目。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.rel.text&lt;/code&gt;：一个 .text 节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置。一般而言，任何 &lt;strong&gt;调用外部函数或者引用全局变量&lt;/strong&gt; 的指令都需要修改。而调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常被省略，除非用户显式地指示链接器包含这些信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rel.data&lt;/code&gt;：被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的变量，如果它的初始值是一个 &lt;strong&gt;全局变量地址&lt;/strong&gt; 或者 &lt;strong&gt;外部定义函数的地址&lt;/strong&gt;，都需要被修改。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.debug&lt;/code&gt;：一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的 C 源文件。只有 &lt;code&gt;-g&lt;/code&gt; 选项编译时，才会得到这张表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.line&lt;/code&gt;：原始 C 源文件中的行号和 &lt;code&gt;.text&lt;/code&gt; 节中的机器指令之间的映射。只有 &lt;code&gt;-g&lt;/code&gt; 选项调用编译器驱动程序时，才会得到这张表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.strtab&lt;/code&gt;：一个字符串表，其内容包括 .symtab 和 .debug 节中的符号表，以及节头部表中的节名字。字符串表就是以 null 结尾的字符串的序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;heading-3&#34;&gt;位置无关的代码&lt;/h2&gt;
&lt;p&gt;共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码，因而节约宝贵的内存资源。那么，多个进程是如何共享程序中的一个副本的呢？一种方法是给每个库分配一个事先预备好的专用的地址空间片，然后要求加载器总是在这个地址加载共享库。虽然这种方法很简单，但是它同时造成了一些严重的问题，它对于地址空间的使用效率不高，因为即使一个进程不使用这个库，那部分空间还是会被分配出来。它也难以管理，我们必须保证没有片重叠。每当一个库修改了以后，我们必须保证分配的空间还依旧合适。更糟的是，对每个系统而言，库在内存中的分配方式都是不同的，这就引起了更多令人头痛的管理问题。&lt;/p&gt;
&lt;p&gt;要避免这些问题，现在系统以这样一种方式编译共享模块的嗲码段，是的可以把它们加载到内存的任何位置而无需链接器修改。使用这种方法，无限多个进程可以共享一个共享模块的代码段的单一副本。（每个进程仍然有自己的读/写数据块。）&lt;/p&gt;
&lt;p&gt;可加载而无需重定位的代码被称作 &lt;strong&gt;位置无关代码（Position-Independent Code，PIC）&lt;/strong&gt;。用户可以对 GCC 使用 -fpic 选项指示 GNU 编译系统生成 PIC 代码。共享库的编译必须使用该选项。&lt;/p&gt;
&lt;h4 id=&#34;pic-&#34;&gt;PIC 数据引用&lt;/h4&gt;
&lt;p&gt;编译器通过已知得的信息确定全局变量的 PIC 引用。也就是无论在内存中的何处加载一个目标模块（包括共享的目标模块），数据段与代码段的距离总是保持不变（在编译的时候由库中头部表首先划分两个段的大小和位置）。&lt;/p&gt;
&lt;p&gt;PIC 引用的编译器使用了这一事实，它在数据段开始的地方创建了一个表，叫做 &lt;strong&gt;全局偏移量表（Global Offset Table, GOT）&lt;/strong&gt;。在 GOT 中所有被这个库引用的全局变量都会有一个 8 字节条目。而在代码中，编译器为每一个在 GOT 条目中的变量设置了重定位信息，将其重定位为 GOT 对应的条目，每个引用全局变量的库都有自己单独的 GOT。&lt;/p&gt;
&lt;p&gt;简单来说，编译器在共享库中的数据段开始的地方设置了 GOT 表，表内容是每一条变量的重定位信息，但是在库并未加载的时候，这些信息都是无效的，加载器会在加载库的时候，根据系统的环境信息对库中的每一条 GOT 条目分别设置对应的重定位条目，解析对应变量真实的绝对地址。如果这个库想要使用这个变量的时候，它并不知道变量的内存地址，但是它可以根据自己携带的 GOT 表去重定位该变量（因为 GOT 表的位置是相对库本身静止的，距离保持不变，所以可以使用简单的偏移量访问 GOT 表各个条目）。&lt;/p&gt;
&lt;h4 id=&#34;pic--1&#34;&gt;PIC 函数调用&lt;/h4&gt;
&lt;p&gt;如果程序调用了一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行的时候可以加载的任何位置。在这里，编译器使用了一个称为 &lt;em&gt;延迟绑定&lt;/em&gt; 的技术，该技术使得 PIC 的函数调用可以在运行的时候再进行解析，这种方法并不是 GOT 因为它修改了调用者的代码段。&lt;/p&gt;
&lt;p&gt;为什么使用延迟绑定技术是因为在一个库中，通常会具有成千上百个函数，一个典型的应用程序只会用到其中的一小部分。把函数地址解析放在实际被调用的地方，可以避免动态链接器在加载时进行成千上百个其实并不需要的重定位。第一次调用的开销很大，但是其后的每次调用都只会花费一条指令和一个间接的内存引用。&lt;/p&gt;
&lt;p&gt;延迟绑定是通过两个表实现的，第一个就是我们之前提到的 &lt;strong&gt;GOT 全局偏移量表&lt;/strong&gt;，第二个就是 &lt;strong&gt;过程链接表（procedure linkage table,PLT）&lt;/strong&gt;。GOT 是数据段的一部分，PLT 是代码段的一部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;过程链接表（PLT）&lt;/strong&gt;。PLT 是一个数组，其中的每个条目是 16 字节代码。PLT[0] 是一个特殊条目，它跳转到动态链接器中。每个可执行程序调用的库函数都有它自己的系统启动函数（&lt;code&gt;__libc_start_main&lt;/code&gt;），它初始化执行环境，调用 &lt;code&gt;main&lt;/code&gt; 函数并且处理其返回值。从 PLT[2] 开始的条目调用用户代码调用的函数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全局偏移量表（GOT）&lt;/strong&gt;。GOT 是一个数组，其中每个条目是 8 字节的地址。和 PLT 联合使用的时候，GOT[0] 和 GOT&lt;a href=&#34;https://xiahualiu.github.io/img/2018-7-13-CSAPP-link/ELF_structure.png&#34;&gt;1&lt;/a&gt; 包含动态链接器在解析函数地址时会用到信息。其余每一个条目对应一个被调用的函数，其地址需要在运行时被解析。每个条目都对应一个相匹配的 PLT 条目。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    <item>
      <title>Program Low Level Optimization (CSAPP Reading Notes)</title>
      <link>https://xiahualiu.github.io/posts/2018-07-05-optimize-your-c-code/</link>
      <pubDate>Thu, 05 Jul 2018 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2018-07-05-optimize-your-c-code/</guid>
      <description>&lt;p&gt;写出一个不管在任何情况下都能够正确运行的程序是作为一个程序员的基本技能，在此之上，作为一个程序员，也应该写出一个清晰而简洁的代码，这样做不仅仅是为了自己能够在调试的时候看懂代码，也是为了在未来检查代码和今后需要修改代码的时候，其他人能哦过读懂和理解自己的代码。&lt;/p&gt;
&lt;p&gt;但是在数据量日益增大今天，很多情况下，程序运行的速度也成为了一个重要的考虑因素。如果一个程序要实时的处理视频和网络包，一个运行很慢的程序就不能够满足使用的要求。而对于一个计算任务非常大的程序，例如需要执行数日或数周的程序，其速度提升 20% 也能够造成巨大的影响，本文的目的在于探讨使用不同的类型的程序优化技术，使得程序优化的更快。&lt;/p&gt;
&lt;p&gt;编写高效的程序需要做到以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;必须选择合适的算法和数据结构&lt;/li&gt;
&lt;li&gt;必须编写出编译器能够有效优化，转换成高效可执行代码的源代码。&lt;/li&gt;
&lt;li&gt;将大任务分成多个部分，并行计算。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于第二个方面，我们应该理解编译器优化方法的局限性。对于 C 语言来说，由于存在指针运算和强制类型转换，使得编译器很难对于代码进行优化，在目前，最好的编译器也受到 &lt;em&gt;妨碍优化的因素&lt;/em&gt; 的阻碍，妨碍优化的因素就是程序行为中那些 &lt;strong&gt;严重依赖于执行环境&lt;/strong&gt; 的方面。程序员必须编写容易优化的代码，以帮助编译器。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;优化的第一步&lt;/h2&gt;
&lt;p&gt;程序优化的第一步是消除不必要的工作，让代码尽可能有效的执行所期望的任务。这包括消除不必要的 &lt;strong&gt;过程调用、条件测试&lt;/strong&gt; 和 &lt;strong&gt;内存引用&lt;/strong&gt; 。这些优化不依赖于目标机器的任何具体属性。为了使代码的执行效率最高，在程序员和编译器面前都有一个目标机器的模型，指明如何执行各条代码，以及各个操作的时序特性。例如，编译器必须知道处理器的时序信息，这样才能确定如何编译乘法，是使用移位和加法的某种组合还是直接使用乘法指令。现代计算机使用了复杂的技术来处理机器级程序，并行执行许多条指令，执行的顺序还可能不同于其在程序中出现的顺序。&lt;/p&gt;
&lt;p&gt;了解处理器的运作规律，就可以进行优化程序的第二布，利用处理器提供的指令级并行能力 (instruction-level parallelism) 能力，同时执行多条指令。&lt;/p&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;编译器的局限性&lt;/h2&gt;
&lt;p&gt;编译器在优化的过程中，只对于程序进行安全的优化。也就是对于程序可能遇到的所有情况下，编译器都保证优化后的程序和优化前的程序有一样的行为，这样就限制了编译器只进行安全的优化。为了理解这一点，我们来看以下两个过程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;twiddle1&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;xp, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;yp)
{
    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;xp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;yp;
    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;xp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;yp;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;twiddle2&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;xp, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;yp)
{
    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;xp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;yp;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这两个过程的结果看似是完全一致的，但是执行的效率不同。对于 &lt;code&gt;twiddle1()&lt;/code&gt; 过程，进行了六次内存引用（读 yp，读 xp，写 xp，读 yp，读 xp，写 xp），而对于 &lt;code&gt;twiddle2()&lt;/code&gt; 过程，只进行了 3 次内存引用（读 yp，读 xp，写 xp）。因此，基于编译器编译过程  &lt;code&gt;twiddle1()&lt;/code&gt;，我们认为基于 &lt;code&gt;twiddle2()&lt;/code&gt; 过程会产生更加有效的代码。&lt;/p&gt;
&lt;p&gt;不过，我们应该考虑到当 &lt;code&gt;xp&lt;/code&gt; 和 &lt;code&gt;yp&lt;/code&gt; 相等的情况下。在这种情况下，两个过程的执行结果完全不同：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;twiddle1&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;xp, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;yp)
{
    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;xp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;yp; &lt;span style=&#34;color:#75715e&#34;&gt;/* *xp=2* *xp */&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;xp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;yp; &lt;span style=&#34;color:#75715e&#34;&gt;/* *xp=2* 2* *xp=4* *xp */&lt;/span&gt;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;twiddle2&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;xp, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;yp)
{
    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;xp &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;yp; &lt;span style=&#34;color:#75715e&#34;&gt;/* *xp=3* *xp */&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果是前者 &lt;code&gt;*xp&lt;/code&gt; 的值增大为原来的 4 倍，后者为增大 3 倍。&lt;/p&gt;
&lt;p&gt;这种两个指针可能指向同一个内存地址的情况被称为 &lt;strong&gt;内存别名引用（memory aliasing）&lt;/strong&gt;。对于不同的情况下，编译器必须保证这种情况存在，而不对于该程序进行过程的优化。这造成了一个主要的妨碍优化的因素，也是可能严重限制编译器产生优化代码程序的一个方面。如果编译器不能确定两个指针指向同一个位置，就必须假设什么情况都有可能。&lt;/p&gt;
&lt;p&gt;另外一个妨碍编译器优化的因素是函数调用。作为一个示例，考虑以下的两个过程：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;();

&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func1&lt;/span&gt;(){
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; f()&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;f()&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;f()&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;f();
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func2&lt;/span&gt;(){
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;f();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这两个过程的结果又是感觉是相同的结果，但是在 &lt;code&gt;func1()&lt;/code&gt; 中，连续调用了四次 &lt;code&gt;f()&lt;/code&gt;；而在 &lt;code&gt;func2()&lt;/code&gt; 中，仅仅调用了一次。从以上的角度来看，过程 2 明显效率更高，编译器应该使用 &lt;code&gt;func2()&lt;/code&gt; 为优化的版本。但是，考虑到以下的情况：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;();
 &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; counter&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; 

 &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;f&lt;/span&gt;(){
     &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; counter&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;;
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 &lt;code&gt;f()&lt;/code&gt; 中修改了某个全局变量 counter，这就导致 &lt;code&gt;f()&lt;/code&gt; 的引用次数变化会使该全局变量产生不同的值。所以，大多数编译器会保持原有代码中所有的函数调用不变，并不会优化相的代码。&lt;/p&gt;
&lt;p&gt;如果想要优化函数调用的过程，可以使用两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内联函数&lt;/li&gt;
&lt;li&gt;宏定义函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种方法的本质是一样的，就是在代码中，将原有的函数调用初插入调用的函数代码，这样编译器就可以将其当做普通的代码进行优化。但是这两种方法都有调试的危险性，在调试的过程中，调试器将无法追踪该函数调用，也无法在函数内部设置断点。还有，在使用代码剖析的方式来评估程序的性能，用内联或者宏定义的函数调用是无法被正确剖析的。&lt;/p&gt;
&lt;h2 id=&#34;heading-2&#34;&gt;程序性能的表述&lt;/h2&gt;
&lt;p&gt;这里引用度量标注 &lt;strong&gt;元素的周期数（Cycles Per Element，CPE）&lt;/strong&gt;，作为一种表示程序性能和直到我们改进代码的方法。用时钟周期来表示，度量值表示的是执行了多少条指令，而不是时钟运行的有多快。&lt;/p&gt;
&lt;p&gt;举个例子，在这里，我们提供两个不同的函数 &lt;code&gt;psum1&lt;/code&gt; &lt;code&gt;psum2&lt;/code&gt;，他们都有相同的功能，就是对于一个向量前 n 个元素求和，但是对应的采用的代码不同，通过比较两个函数的 CPE 值，我们可以理解为什么 CPE 是衡量程序性能的指标。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* 计算一个向量的 n 前序和 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;psum1&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; a[], &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; p[], &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; n)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; i;
    p[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; a[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;)
        p[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; p[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; a[i];
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; psum2(&lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; a[]; &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; p[]; &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; n)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; i;
    p[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;a[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;float&lt;/span&gt; mid_val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; p[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; a[i];
        p[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid_val;
        p[i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; mid_val &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; a[i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;];
    }
    &lt;span style=&#34;color:#75715e&#34;&gt;/* 对于 n 为偶数的情况 */&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n)
        p[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; p[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; a[i];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;随着 n 值的变化，以上两个函数的计算所需周期也会发生变化，我们通过测试不同的 n 值的情况下的运行周期，使用最小二乘法，获得两种函数的 &lt;strong&gt;周期 - n&lt;/strong&gt; 多项式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;psum1: 368 + 9.0n&lt;/li&gt;
&lt;li&gt;psum2: 368 + 6.0n&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出，&lt;code&gt;psum2&lt;/code&gt; 的斜率（一次项）系数要小于 &lt;code&gt;psum1&lt;/code&gt;，也就是在 n 较大的情况下，&lt;code&gt;psum2&lt;/code&gt; 的性能要好于 &lt;code&gt;psum1&lt;/code&gt;。而这种优化的方法又被称作 &lt;strong&gt;循环展开（loop unrolling）&lt;/strong&gt; 技术，至于为什么有效，我们可以看做通过增加每次循环的计算量，减少了测试环节的次数，计算在循环中的占比增加，这样处理器可以用更多的周期进行计算。&lt;/p&gt;
&lt;h3 id=&#34;heading-3&#34;&gt;程序示例&lt;/h3&gt;
&lt;p&gt;为了说明一个抽象的程序是如何被系统得转换成为更加有效地代码的，我们将使用一个基于向量数据结构的运行示例。向量由两个内存块组成：头部和数据数组。头不是一个生命如下的结构。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; len;
    data_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;data;
} vec_rec, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;vec_ptr;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当然，我们会给这个结构分配一个 len 个 data_t 类型对象的数组，用来存放实际的向量元素。&lt;/p&gt;
&lt;p&gt;在下面我们会给出一些常见的生成向量、访问向量和确定向量长度等基本过程。请注意在下面的向量访问程序 get_vec_element，它会对每个向量引用进行边界检查，边界检查减少了出错的机会，但是它也会减缓程序的执行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* 创造一个特定长度的向量 */&lt;/span&gt;
vec_ptr &lt;span style=&#34;color:#a6e22e&#34;&gt;new_vec&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; len)
{
    &lt;span style=&#34;color:#75715e&#34;&gt;/* 分配结构空间 */&lt;/span&gt;
    vec_ptr result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (vec_ptr) malloc(&lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(vec_rec));
    data_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; NULL;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;result)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; NULL; &lt;span style=&#34;color:#75715e&#34;&gt;/* 分配失败 */&lt;/span&gt;
    result&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len;
    &lt;span style=&#34;color:#75715e&#34;&gt;/* 分配向量空间 */&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (len &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) {
        data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (data_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)calloc(len, &lt;span style=&#34;color:#66d9ef&#34;&gt;sizeof&lt;/span&gt;(data_t));
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;data) {
            free((&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;) result);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; NULL; &lt;span style=&#34;color:#75715e&#34;&gt;/* 分配失败 */&lt;/span&gt;
        }
    }
    &lt;span style=&#34;color:#75715e&#34;&gt;/* data 指针指向空或者分配的向量 */&lt;/span&gt;
    result&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; data;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result;
}

&lt;span style=&#34;color:#75715e&#34;&gt;/* 获得向量元素并将其储存在 dest *
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * 返回 0（越界）或者 1（成功）  */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;get_vec_element&lt;/span&gt;(vec_ptr v, &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; index, data_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dest)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; index &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;len)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dest &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; v&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;data[index];
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
}

&lt;span style=&#34;color:#75715e&#34;&gt;/* 返回向量的长度 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;vec_length&lt;/span&gt;(vec_ptr v)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; v&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;len;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为了能够使用一种代码描述多种运算过程，我们采用了如下的代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* 合并运算的初始实现 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 加法运算 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define IDENT 0&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define OP +&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 乘法运算 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;// #define IDENT 1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// #define OP *
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;combine1&lt;/span&gt;(vec_ptr, data_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dest)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; i;

    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dest &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; IDENT;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; vec_length(v); i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;) {
        data_t val;
        get_vec_element(v, i, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;val);
        &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dest &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dest OP val;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在接下来的内容中，我们将会对代码进行一些变换，有些事有效的有些事无效的，而如何确定变换的组合也是很重要的，它们能使编译器对于代码进一步优化。在下面我们给出在 Intel Core i7 Haswell 处理器的机器上运行此求和和求积函数的 CPE 性能，这个机器又被称作参考机。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;方法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;整数 CPE&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;浮点数 CPE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;combine1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;抽象未优化的&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;22.68(+) 20.02(*)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;19.98(+) 20.18(*)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;combine1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;抽象 -O1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;10.12(+) 10.12(*)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;10.17(+) 11.14(*)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以看出简单的 &amp;ldquo;-O1&amp;rdquo; 优化就可以有效提高程序的效率。&lt;/p&gt;
&lt;h2 id=&#34;heading-4&#34;&gt;消除循环的低效率&lt;/h2&gt;
&lt;p&gt;在计算元素的乘积和算数和的时候，过程 &lt;code&gt;combine1&lt;/code&gt; 调用函数 &lt;code&gt;vec_length&lt;/code&gt; 作为 &lt;code&gt;for&lt;/code&gt; 循环的测试条件。而在编译章节，我们了解了 &lt;code&gt;for&lt;/code&gt; 循环在机器级程序中的翻译结果，它会在每一次循环时计算测试条件的值。另一方面，不管循环进行到哪里，测试条件的值保持不变。因此我们只需要在循环前调用一次 &lt;code&gt;vec_length&lt;/code&gt;，并且在测试条件中一直使用此值即可。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;·&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;·&lt;/span&gt;&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;·&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; combine2(vec_ptr, data_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dest)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; i;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec_length(v);

    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dest &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; IDENT;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; length; i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;) {
        data_t val;
        get_vec_element(v, i, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;val);
        &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dest &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dest OP val;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;方法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;整数 CPE&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;浮点数 CPE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;combine1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;抽象 -O1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;10.12(+) 10.12(*)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;10.17(+) 11.14(*)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;combine2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;移动 vec_length&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7.02(+) 9.03(*)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9.02(+) 11.03(*)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这一类优化是比较常见的优化方法，被称作 &lt;strong&gt;代码移动&lt;/strong&gt;。通常情况下，编译器会尝试进行这种优化，但是在本例中，涉及到调用函数，参见以上的内容我们知道，编译器会假设调用的函数有全局的副作用，故并不会对其进行优化。&lt;/p&gt;
&lt;h2 id=&#34;heading-5&#34;&gt;减少过程调用&lt;/h2&gt;
&lt;p&gt;通过之前讲解，我们知道过程调用会产生开销，而且妨碍程序优化。在 &lt;code&gt;combine2&lt;/code&gt; 程序中我们发现在循环体内，我们都是通过调用 &lt;code&gt;get_vec_element()&lt;/code&gt; 来获取下一个向量元素的值。在这个调用中，我们可以看到每次都会对向量索引 i 和边界比较检查 i 合法性，而通过对于代码上下文的观察，在这个环境中，每次的引用都是合法的。&lt;/p&gt;
&lt;p&gt;我们可以使用一个新的函数 &lt;code&gt;get_vec_start()&lt;/code&gt;，这个函数获取向量的首地址，在后续计算中，直接访问地址，而不通过调用获取元素。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;data_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;get_vec_start&lt;/span&gt;(vec_ptr v)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; v&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;data;
}
&lt;span style=&#34;color:#75715e&#34;&gt;/* 通过访问矢量数据直接访问 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;combine3&lt;/span&gt;(vec_ptr v,data_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dest)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; i;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec_length(v);
    data_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; get_vec_start(v);

    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dest &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; IDENT;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; length; i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;){
        &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dest &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dest OP data[i];
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;方法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;整数 CPE&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;浮点数 CPE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;combine2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;移动 vec_length&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7.02(+) 9.03(*)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9.02(+) 11.03(*)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;combine3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;减少过程调用&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7.17(+) 9.02(*)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9.02(+) 11.04(*)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;有表可见，没有明显的提升。显然，循环中的其他操作形成了瓶颈，限制性能超过调用 &lt;code&gt;get_vec_element()&lt;/code&gt;。但是这种转换带来了一些其他的好处，我们将其视作优化的一个环节。&lt;/p&gt;
&lt;h2 id=&#34;heading-6&#34;&gt;消除不必要的内存引用&lt;/h2&gt;
&lt;p&gt;在以上的 &lt;code&gt;combine3()&lt;/code&gt; 代码中，我们将 *dest 视作累积值的存放目标。通过检查内循环编译后的汇编代码，可以看出这个属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;combine3 的内循环。data_t 是双浮点型，OP = *
dest 在 %rbx 中，data + i 在 %rdx 中，data + length 在 %rax 中

.L17:                           loop:
    vmovsd (%rbx), %xmm0            *dest -&amp;gt; %xmm0
    vmulsd (%rdx), %xmm0, %xmm0     data[i] * %xmm0 -&amp;gt; %xmm0
    vmovsd %xmm0, (%rbx)            %xmm0 -&amp;gt; *dest
    addq $8, %rdx                   i += 8
    cmpq %rax, %rdx                 if (!(%rdx - %rax)) set ZF
    jne .L17                        if (~ZF) loop:
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在每次内循环中，我们都要经历 &lt;code&gt;*dest -&amp;gt; %xmm0&lt;/code&gt; 和 &lt;code&gt;%xmm0 -&amp;gt; *dest&lt;/code&gt; 两个访存过程，一次读取一次写入，也就是说我们计算完的结果要先写入内存后，下一次循环再进行读取到寄存器再计算。这个过程其实是不必要的，因为我们可以将数一直放在乘法寄存器中，等待计算循环完全完成后再将值写回内存，这样可以减少许多不必要的内存访问时间。&lt;/p&gt;
&lt;p&gt;修改过的汇编代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;combine3 的内循环。data_t 是双浮点型，OP = *
acc 在 %xmm0 中，data + i 在 %rdx 中，data + length 在 %rax 中
.L25:                           loop:
    vmulsd (%rdx), %xmm0, %xmm0     data[i] * %xmm0 -&amp;gt; %xmm0
    addq $8, %rdx                   i += 8
    cmpq %rax, %rdx                 if (!(%rdx - %rax)) set ZF
    jne .L25                        if (~ZF) loop:
&lt;/code&gt;&lt;/pre&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;combine4&lt;/span&gt;(vec_ptr v, data_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dest)
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; i;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;long&lt;/span&gt; length &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec_length(v);
    data_t &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; get_vec_start(v);
    data_t acc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; IDENT;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; length; i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;) {
        acc &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; acc OP data[i];
    }
    &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;dest &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; acc;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;结果被积累在临时变量 acc 中，消除了每次循环中从内存读出并更新的过程。这个改变使程序的速度有了较大的提升，如下表：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;方法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;整数 CPE&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;浮点数 CPE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;combine3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;减少过程调用&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7.17(+) 9.02(*)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9.02(+) 11.04(*)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;combine4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;累计在临时变量中&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.27(+) 3.01(*)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3.01(+) 5.01(*)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;有人觉得，编译器应该做到直接优化成为 &lt;code&gt;combine4&lt;/code&gt; 中代码的格式，但是在实际的过程中，dest 指针不一定是否和数组名产生重名，故编译器并不会做出优化的措施。&lt;/p&gt;
&lt;p&gt;在使用 &amp;lsquo;-O2&amp;rsquo; 的命令行选项编译 &lt;code&gt;combine3&lt;/code&gt; 时，程序的效率提高许多，尽管还是没有 &lt;code&gt;combine4&lt;/code&gt; 效率高：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;方法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;整数 CPE&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;浮点数 CPE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;combine3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-O1 编译&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7.17(+) 9.02(*)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9.02(+) 11.04(*)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;combine3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-O2 编译&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.60(+) 3.01(*)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3.01(+) 5.01(*)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;combine4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;累计在临时变量中&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.27(+) 3.01(*)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3.01(+) 5.01(*)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在检查编译器产生的汇编代码时，我们发现内循环汇编代码发生了一个有趣的变化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;combine3 的 -O2 内循环。data_t 是双浮点型，OP = *
dest 在 %rbx 中，data + i 在 %rdx 中，data + length 在 %rax 中

.L22:                           loop:
    vmulsd (%rdx), %xmm0, %xmm0     data[i] * %xmm0 -&amp;gt; %xmm0
    addq $8, %rdx                   i += 8
    cmpq %rax, %rdx                 if (!(%rdx - %rax)) set ZF
    vmovsd %xmm0, (%rbx)            %xmm0 -&amp;gt; *dest
    jne .L22                        if (~ZF) loop:
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过调整写回的位置，减少了一次读取内存的操作，提高了效率，并且，在这种情况下，即使出现内存重名，也还是可以保证安全性。&lt;/p&gt;
&lt;h2 id=&#34;heading-7&#34;&gt;理解现代处理器&lt;/h2&gt;
&lt;p&gt;由于大量的晶体被集成在一块芯片上，现代微处理器采用了复杂的硬件，试图使得程序的性能最大化。在代码级别上，看起来是一次执行一条指令，但是在实际的处理器中，是同时对多条指令求值的，这个现象被称作 &lt;em&gt;指令级并行&lt;/em&gt;。现代处理器取得的了不起的功绩之一是：他们采用复杂而奇异的处理器结构，其中多条指令可以并行的执行，同时又呈现出一种简单的顺序执行指令的现象。&lt;/p&gt;
&lt;p&gt;当一系列操作必须严格按照顺序执行时，就会遇到 &lt;em&gt;延迟界限&lt;/em&gt;，因为在下一条指令开始之前，这条指令必须结束。当代码中的数据相关限制了处理器指令级并行执行能力时，延迟界限能够限制程序性能。&lt;em&gt;吞吐量界限&lt;/em&gt; 刻画了处理器功能单元的原始计算能力。这个界限是程序性能的终极限制。&lt;/p&gt;
&lt;h2 id=&#34;heading-8&#34;&gt;整体操作&lt;/h2&gt;
&lt;p&gt;在这里展示一个近期的 Intel 处理器的结构。这些处理器在工业中被称为 &lt;em&gt;超标量&lt;/em&gt;，也就是说它可以在每个时钟周期执行多个操作，而且是 &lt;strong&gt;乱序的&lt;/strong&gt;。指令的执行顺序不一定要与他们在机器级程序中的顺序一致。整个设计有两个部分：&lt;strong&gt;指令控制单元（Instruction Control Unit，ICU）&lt;/strong&gt; 和 &lt;strong&gt;执行单元（Execution Unit，EU）&lt;/strong&gt;。前者负责在内存中读出指令序列，并且根据这些指令序列产生一组针对程序数据的基本操作；后者执行这些操作。和我们之前研究过的 SEQ 和 PIPE 流水线相比，乱序处理器需要更大、更复杂的硬件，但是它们能够更好地达到更高的指令级并行度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-7-5-optimize-your-c-code/ooo_CPU.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如图所示，指令控制单元 ICU 负责从内存中读出指令，并产生一系列基本操作。然后执行单元 EU 完成这些操作，并指出分支预测是否正确。ICU 会提前很早对于当前执行的指令进行取指，这样它才有足够的时间对于其进行指令译码，并把操作发给 EU。&lt;/p&gt;
&lt;p&gt;EU 接收实际的程序指令，并将其转换为一系列基本操作（也成微操作）。对于有复杂指令的机器，例如 x86 处理器，一条指令可以被译码成为多个操作，而指令如何被译码成为操作序列的细节，不同的机器都不同，这个信息是高度机密。但是我们并不需要知道这些底层细节，也可以优化自己的程序。&lt;/p&gt;
&lt;p&gt;**退役单元（retirement unit）**记录正在进行的处理。退役单元控制内部寄存器的更新。指令在被译码完成后，指令的信息将会被放置在一个先进先出的队列中。而队列更新只有在以下两种条件下被完成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这条信息的所有操作完成了，并且引起这条指令的预测被判断正确，对寄存器更新。&lt;/li&gt;
&lt;li&gt;引起这条指令的某个分支预测点错误，该指令被清空。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种方法导致预测的错误情况发生后，程序的状态不会发生改变。&lt;/p&gt;
&lt;p&gt;对于功能单元，我们的 Intel Core i7 Haswell 参考机具有 8 个功能单元，每个单元的功能有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;整数运算、浮点乘、整数和浮点数除法、分支&lt;/li&gt;
&lt;li&gt;证书运算、浮点加、整数乘、浮点乘&lt;/li&gt;
&lt;li&gt;加载、地址计算&lt;/li&gt;
&lt;li&gt;加载、地址计算&lt;/li&gt;
&lt;li&gt;储存&lt;/li&gt;
&lt;li&gt;整数运算&lt;/li&gt;
&lt;li&gt;整数运算、分支&lt;/li&gt;
&lt;li&gt;储存、地址运算&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;heading-9&#34;&gt;功能单元的性能&lt;/h2&gt;
&lt;p&gt;对于不同的功能单元，由于其负责不同的算数运算，故各个功能单元的性能并不相同，这些性能是通过以下的这些数值进行刻画的（单位为时钟周期）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;延迟（latency）&lt;/strong&gt;，完成运算所需的总时间。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;发射时间（issue time）&lt;/strong&gt;，两个连续同类型运算之间需要的最小周期数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;容量（capacity）&lt;/strong&gt;，执行该运算的功能单元的数量。&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;运算&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;整数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;浮点数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;延迟&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;发射&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;容量&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;延迟&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;发射&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;容量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;加法&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;乘法&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;除法&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3~30&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3~30&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3~15&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3~15&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;表现发射时间的一种更常见的方法是指明这个功能单元的最大 &lt;em&gt;吞吐量&lt;/em&gt;，定义为发射时间的倒数。对于一个容量为 &lt;em&gt;C&lt;/em&gt;，发射时间为 &lt;em&gt;I&lt;/em&gt; 的操作来说，处理器可能获得的吞吐量为每时钟周期 &lt;em&gt;C/I&lt;/em&gt; 个操作，而最小的 CPE 吞吐界限就是 &lt;em&gt;I/C&lt;/em&gt; 个周期。我们的参考机可以每个时钟周期执行两个浮点乘法运算。我们可以利用这个能力来提高程序的性能。根据计算，得出处理器的理论最小 CPE 参数。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;函数&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;方法&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;整数 CPE&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;浮点数 CPE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;combine4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;累计在临时变量中&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.27(+) 3.01(*)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3.01(+) 5.01(*)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;延迟&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.00(+) 3.00(*)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;3.00(+) 5.00(*)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;吞吐量&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0.50(+) 1.00(*)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1.00(+) 0.50(*)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;我们可以看到，除了整数加法之外的运算都已经基本达到了延迟 CPE 的硬件界限，在接下来的内容里，我们将会着手于创建处理器操作的抽象模型，对于代码的执行过程在处理器层面进行详细探究。&lt;/p&gt;
&lt;h4 id=&#34;heading-10&#34;&gt;机器级代码到数据流图&lt;/h4&gt;
&lt;p&gt;综上所述，程序代码的数据流不能体现在处理器层面上面。我们将注意力集中在对于内循环的过程，因为对于一个巨大的 n 值，内循环的计算时间，也即是循环的 CPE 值是决定性能的主要因素。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;combine3 的内循环。data_t 是双浮点型，OP = *
acc 在 %xmm0 中，data + i 在 %rdx 中，data + length 在 %rax 中
.L25:                           loop:
    vmulsd (%rdx), %xmm0, %xmm0     data[i] * %xmm0 -&amp;gt; %xmm0
    addq $8, %rdx                   i += 8
    cmpq %rax, %rdx                 if (!(%rdx - %rax)) set ZF
    jne .L25                        if (~ZF) loop:
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对于形成循环的代码片段，我们可以将访问到的寄存器分为四类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只读：这些寄存器只作为运算的源值，也可以作为计算的内存地址，在循环的过程中，其中的值保持不不变，在 &lt;code&gt;combine4&lt;/code&gt; 循环中，%rax 寄存器为只读类型的。&lt;/li&gt;
&lt;li&gt;只写：这些寄存器被作为数据传送操作的目的。本循环中没有此类寄存器。&lt;/li&gt;
&lt;li&gt;局部：在循环内部被修改和使用。本例中的条件码寄存器就是这类寄存器，cmp 操作会修改他们，jne 操作又会使用到他们。&lt;/li&gt;
&lt;li&gt;循环：对于循环来说，这些寄存器会在本次循环中修改，在下次循环中用到。本例中的 %rdx 和 %xmm0 是 &lt;code&gt;combine4&lt;/code&gt; 的循环寄存器，对应变量 &lt;code&gt;data+i&lt;/code&gt; 和 &lt;code&gt;acc&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2018-7-5-optimize-your-c-code/combine4_data_flow.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;根据汇编代码画出对应的数据流图，由于比较 cmp 和分支 jne 操作不直接影响数据流。处理器会中的指令控制单元会预测分支，使程序继续进行。&lt;/p&gt;
&lt;p&gt;故我们循环的主要延迟来自于三个操作，mul、add、load 操作，而在这些操作之中，mul 操作的延迟最长，为 3 个时钟周期（或者 5 个时钟周期），我们将其视作 &lt;strong&gt;关键路径（Critical Path）&lt;/strong&gt;。剩余的两个操作可以视作在 mul 操作运行时并行进行。也就是说在每次循环中，load 指令会在 mul 指令开始前就加载好数字，而 add 指令需要等待 mul 指令完成后才能进行加法的操作。可以看到，该程序的理论 CPE 界限值为 3.00 或者 5.00，也就是 mul 指令的 CPE 界限值。&lt;/p&gt;
&lt;h2 id=&#34;heading-11&#34;&gt;增加并行性&lt;/h2&gt;
&lt;p&gt;可以使用增加累积标量的方式进行并行的计算，或者可以使用 Intel 处理器最新的 SSE 指令，进行 AVX 寄存器支持的向量计算方式增加并行性。（具体怎么用不介绍了，太长了）&lt;/p&gt;
&lt;p&gt;以上两种方式都会使得程序超过 CPE 延迟界限，逼近 CPE 吞吐量界限，但是无法超越吞吐界限。&lt;/p&gt;
&lt;h2 id=&#34;heading-12&#34;&gt;一些限制因素&lt;/h2&gt;
&lt;h4 id=&#34;heading-13&#34;&gt;寄存器溢出&lt;/h4&gt;
&lt;p&gt;在增加并行性的过程中，我们增加了循环寄存器的使用的量，而参考机中的 xmm 和 ymm 寄存器都是只有 16 个，一旦在写程序的过程中超过了该值，就会将变量储存在临时栈中，而这样的操作会使 CPE 值略微上升，造成不必要的性能损失。&lt;/p&gt;
&lt;h4 id=&#34;heading-14&#34;&gt;分支预测和预测错误惩罚&lt;/h4&gt;
&lt;p&gt;不要过分关心可预测的分支。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;书写适合用条件传送实现的代码。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;heading-15&#34;&gt;理解内存性能&lt;/h2&gt;</description>
    </item>
    <item>
      <title>CAN Protocol Tuturial</title>
      <link>https://xiahualiu.github.io/posts/2017-12-12-can_bus/</link>
      <pubDate>Tue, 12 Dec 2017 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2017-12-12-can_bus/</guid>
      <description>&lt;p&gt;本文的首要目标是帮助记忆一下有关 CAN 总线上面的知识，并且也帮助一下感兴趣的同学，从浅入深的了解一下 CAN 总线的一些知识，相比其他的教程，我的初衷是将本文写的尽量接地气，简单明了，因为自己也啃过不少的技术文章，但是从一个读者的角度，有些 CAN 协议内容相当晦涩难懂。如果本文出现错误（肯定有错误），大家可以在下边的评论栏中回复具体内容，以便于我及时更改。&lt;/p&gt;
&lt;h1 id=&#34;heading&#34;&gt;简介&lt;/h1&gt;
&lt;p&gt;CAN 协议全称 Controller Area Network protocol，自从 CAN 协议从 1986 年被正式推出后，就一直在不断地更新其标准细节。官方的文献 ISO11898 只提供了一些非常粗浅的相关信息，然而在工业用途上，CAN 网络还有许多不是被规定覆盖的内容，需要自己针对特定的环境理解。&lt;/p&gt;
&lt;h1 id=&#34;can-&#34;&gt;CAN 网络的结构&lt;/h1&gt;
&lt;p&gt;CAN 是一个多主机串行总线，在 CAN 总线上的 ECU 被称作节点。在网络上必须有两个或者多个节点才能相互交流。节点的复杂度从简单的 I/O 设备到拥有 CAN 界面的嵌入式电脑。节点同时也有可能是 CAN 网关，允许电脑通过 USB 或者以太网端口进行网络交互。&lt;/p&gt;
&lt;p&gt;所有的节点都通过两根线相连接，线缆必须为 120Ω 的标称双绞线。根据 &lt;strong&gt;ISO 11898-2&lt;/strong&gt; 标准，高速 CAN 总线必须在两根线的末端用 120Ω 的电阻相互连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-12-12-CAN_Bus/CAN_ISO11898-2_Network.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;p&gt;CAN 网络中，这两根线的名称分为别，CAN High 和 CAN Low，简称为 CAN_H 和 CAN_L：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在某节点发送 &lt;code&gt;0&lt;/code&gt; 的状态下，CAN_H 会被该节点驱动向 5V，CAN_L 会被驱动向 0V，直到两根线间拥有了 2V 的电势差，通常此时 CAN_H 为 3.5V，CAN_L 为 1.5V。&lt;/li&gt;
&lt;li&gt;在总线空闲或者某节点在发送 &lt;code&gt;1&lt;/code&gt; 的状态下，CAN_H 和 CAN_L 不会被驱动，两根线的电压在线路上电阻的作用下维持相同的电压。（通常是 2.5V）&lt;/li&gt;
&lt;li&gt;在隐性状态下的电压值需要保持在 -12~+12V 之间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-12-12-CAN_Bus/ISO11898-2.png&#34; alt=&#34;2&#34;&gt;&lt;/p&gt;
&lt;p&gt;图中的黑线为逻辑电平值，红线即为 CAN_H 电平，绿线为 CAN_L 电平。
我们通常称 CAN 总线上的 &lt;code&gt;0&lt;/code&gt; 为显性的，一旦有一个设备发送了 &lt;code&gt;0&lt;/code&gt; 总线即发生改变，而总线上的 &lt;code&gt;1&lt;/code&gt; 是隐性的，&lt;code&gt;1&lt;/code&gt; 信号可以当做什么也没干，&lt;code&gt;0&lt;/code&gt; 信号可以覆盖 &lt;code&gt;1&lt;/code&gt; 信号。隐性状态可以为空闲状态，或者为发送 &lt;code&gt;1&lt;/code&gt; 状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ISO 11898-3&lt;/strong&gt; 还有规定了另外一种类型的 CAN 总线，叫做&lt;strong&gt;低速 CAN 总线&lt;/strong&gt;，或者错误包容 CAN 总线，在这种总线上面，各个节点在总线的终端，节点电阻的并联电阻即为原有的末端电阻，这个电阻值应该为 100Ω 左右，但是不能低于 100Ω。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-12-12-CAN_Bus/CAN_ISO11898-3_Network.png&#34; alt=&#34;3&#34;&gt;&lt;/p&gt;
&lt;p&gt;低速 CAN 总线上的 CAN_L 在隐性状态下并不与 CAN_H 相同，相反隐性状态下两根线的电平之差最大，具体的时序图见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-12-12-CAN_Bus/ISO11898-3_Waveform.png&#34; alt=&#34;4&#34;&gt;&lt;/p&gt;
&lt;p&gt;在这种总线类型下，显性位时，CAN_H 必须高于 CAN_L 超过 2.3V（在 5V 的 VCC 下），隐性条件时，CAN_H 为 4.7V(VCC - 0.3V)，同理 CAN_L 为 0.3V(VCC + 0.3V)。&lt;/p&gt;
&lt;p&gt;由于 CAN 总线在隐性位向显性位转变的时候是被节点驱动的，故这种转变要快于显性位向隐性位转变，后者是由两根线的电气特性决定的，故速度和 CAN_H，CAN_L 线之间的等效电容有关，高速 CAN 通常用于汽车和工业，节点较少的环境下，低速 CAN 通常用于多个节点连接在同一位置的情况下。&lt;/p&gt;
&lt;p&gt;最常见的 CAN 接口没有被规定，你可以用任何接口，但是最常见的 CAN 接口是 DB9，具有四个引脚，具有一个供电端和地端：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CAN-Low(CAN_L)&lt;/li&gt;
&lt;li&gt;GND(Ground)&lt;/li&gt;
&lt;li&gt;CAN-High(CAN_H)&lt;/li&gt;
&lt;li&gt;CAN V+(Power)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-12-12-CAN_Bus/9_pin_d-sub_connector_male_closeup.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;这就是标准的 DB9 公接头。&lt;/p&gt;
&lt;h2 id=&#34;can--1&#34;&gt;CAN 节点&lt;/h2&gt;
&lt;p&gt;一个标准的 CAN 节点应该有以下的几个部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微处理器 MCU
&lt;ul&gt;
&lt;li&gt;决定接收的 CAN 报文的内容和需要发送的 CAN 报文内容。&lt;/li&gt;
&lt;li&gt;传感器和其他信号设备需要连接在微处理器上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CAN 控制器（一般由 MCU 集成）
&lt;ul&gt;
&lt;li&gt;按位接收数据，并且回馈给微处理器（通常通过中断）。&lt;/li&gt;
&lt;li&gt;按位发送数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CAN 收发器 ISO 11898-2/3 Medium Access Unit [MAU] 标准
&lt;ul&gt;
&lt;li&gt;接收 CAN 总线上的电位值，并将其转换为数字信号 1/0 通常具有电路保护作用，防止损坏 CAN 控制器。&lt;/li&gt;
&lt;li&gt;将数据按位解算成为 CAN 电气信号，发送到总线上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-12-12-CAN_Bus/CAN_Node.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;CAN 总线具有一个特性就是只单向从隐性状态驱动至显性状态，每个 CAN 节点就像是一个打气筒一样，只把 CAN 线路从 1 打气驱动到 0 ，然后不驱动时总线就会自动漏气归 1（因为两根线是通过电阻连接在一起的）。&lt;/p&gt;
&lt;h1 id=&#34;can--2&#34;&gt;CAN 的数据传输过程&lt;/h1&gt;
&lt;p&gt;上面讲的都是一些物理层的特性，我们只讨论了 1 和 0 状态，CAN 总线是串行总线，数据就是按照位一位一位发送的，与其他的串行协议（I2C, SPI, UART）基本类似，CAN 同时也是异步通信协议，没有像 SPI 一样拥有一根时钟线，所以 CAN 传输过程中的波特率必须接收方和发送方一致才可以。&lt;/p&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;数据帧&lt;/h2&gt;
&lt;p&gt;CAN 发送的最小信息单位叫做帧，我们先以最基础的 CAN 数据帧讲解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-12-12-CAN_Bus/CAN_data_frame.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;首先，如果一个设备要发送数据时，首先向总线发送一个位的显性位（0），我们又称 &lt;strong&gt;帧起始/SOF(Start-of-Frame)&lt;/strong&gt;，这个显性位的作用是声明自己已经占有了总线，在发送显性位 &lt;strong&gt;之后&lt;/strong&gt;，其他的设备就知道了，哦现在总线有人了，不能再发送数据了。&lt;/p&gt;
&lt;p&gt;但是还有一种情况，就是在这个显性位发送的同时，巧了，也有一个设备也同时发送了一个 &lt;strong&gt;帧起始&lt;/strong&gt;，这就会导致，这俩设备都以为自己是现在的总线占有者，那这样不就乱了么？这时就要介绍一下 CAN 的仲裁机制，CAN 采用了一种非常巧妙的仲裁机制，叫做 &lt;strong&gt;无损按位仲裁（Lossless Bitwise Arbitration）&lt;/strong&gt; 它的作用就是保证在同一时刻只有一个设备在发送数据。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;帧起始&lt;/strong&gt; 后，接着是 &lt;strong&gt;仲裁段(Arbitration Field)&lt;/strong&gt; ，有一个长达 11 位的 &lt;strong&gt;CAN ID/CAN 标识段&lt;/strong&gt;。在这段，就开始了比谁更优先的游戏，这个游戏的优先规则就是，谁先显性谁优先。设备在仲裁段发送每一位会时刻注意 CAN 总线的状态，我们知道显性位可以覆盖隐性位，一旦设备它自己发现自己发送的隐性位被别的设备覆盖成了显性了，这个设备就知道自己输了，就不会继续发送数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-12-12-CAN_Bus/arbitration_method.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;注意：上图中的电平为逻辑电平，0 对应我们的显性位，1 对应我们的隐性位。&lt;/p&gt;
&lt;p&gt;在 &lt;strong&gt;CAN ID&lt;/strong&gt; 的后边是 &lt;strong&gt;RTR&lt;/strong&gt;(Remote Transmission Request) &lt;strong&gt;远程请求位&lt;/strong&gt;，这一位也在优先级的比赛内，这一位的作用就是标识本帧是不是远程帧，数据帧这一位为 0；远程帧为 1。所以如果之前都是平局，在这一位到来时，数据帧就要优先于远程帧，远程帧是没有数据的帧哈（后边详细介绍）。&lt;/p&gt;
&lt;p&gt;到此为止，&lt;strong&gt;仲裁段(Arbitration Field)&lt;/strong&gt; 就已经结束了，成功占据总线的设备就开始了发送 &lt;strong&gt;控制段(Control Field)&lt;/strong&gt;，控制段内容有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IDE(Identifier Extension Bit)&lt;/strong&gt;，我们可以认作 CAN 拓展帧使能位，这一位的隐性位也即是 1 意味着此 CAN 帧不是标准的，而是拓展的，拓展的 CAN 帧具有 29 位的 CAN ID 而不是标准的 11 位（后边介绍），在标准的 CAN2.0A 帧上此位为 0，CAN2.0B 也即是拓展帧此位为 1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Reserved bit&lt;/strong&gt; 此位为保留位，也可以称作 &lt;strong&gt;r1, r0&lt;/strong&gt; 通常情况下保留一个显性位，也即是 &lt;strong&gt;r0&lt;/strong&gt;，但是接收设备接收到 &lt;strong&gt;r1&lt;/strong&gt; 不会认作错误。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DLC(Data length code)&lt;/strong&gt; 后续数据字节的数量，一共有 4 位，但是只能 0-8，在物理上表示 9-15 是可行的，但 DLC&amp;gt;8 时还是按照 8 字节发送和接收。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来就是数据段了，长度不定，根据控制段的 DLC 变化，长度只能在 0-64bits 或者 0-8bytes 之间。&lt;/p&gt;
&lt;p&gt;接下来是 &lt;strong&gt;CRC 段&lt;/strong&gt;，这一部分的内容作为校验码，接收方可以根据在此之前的接收数据（从 SOF 到 CRC 段开始）主动计算出一个 CRC 码，然后用自己计算的 CRC 和被动接收的 CRC 比较内容，如果不一致就说明之前接受的数据出现错误，具体感兴趣的可以自行查询 CRC 算法，很神奇，只要用一个寄存器的位移就可以实现计算。注意在 CRC 接收末尾有一个 CRC 边界位，边界位必须为隐性位，是为了给后边的应答做准备。&lt;/p&gt;
&lt;p&gt;接下来是 &lt;strong&gt;ACK Field 应答段&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;应答槽(ACK Slot)&lt;/strong&gt;，这一位发送方会发送一个隐性位，应答方需要发送一个位的显性位，这样发送方才知道数据发送成功了，和 I2C 的应答有点类似。如果接收方接收出现错误，接收方必须保持沉默，这样发送方会知道自己的发送失败了。但是，如果有很多接收方，其中有一部分接收失败了，另一部分接收成功了并且应答，发送方依旧会检测到应答，并认为自己发送成功，&lt;strong&gt;发送方并不知道应答是由哪一个设备发出的&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应答边界(ACK Delimiter)&lt;/strong&gt; 因为之前应答了一位显性位，要保证应答数据不影响后边发送的数据，就要等待一位以确保应答位不因为错位，而影响到后续信息的发送。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最后是 &lt;strong&gt;帧结束/EOF(End-of-Frame)&lt;/strong&gt;，其实就是 7 个连续的隐性位。在帧结束后，还有一个 &lt;strong&gt;帧间空白/IFS(Interframe Spacing)&lt;/strong&gt; 直接翻译是帧之间的空白，IFS 保证在前一帧数据和后一帧数据间要保证有 3 个隐性位的长度，这一段空白是必须的。&lt;/p&gt;
&lt;h2 id=&#34;heading-2&#34;&gt;拓展帧&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-12-12-CAN_Bus/CAN_data_frame.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;拓展帧中 CAN ID 被分作两部分，合并起来一共有 29 位，就是拓展帧的 CAN ID，拓展帧并不是数据长度变长了，而是 CAN ID 变长了，原有的 &lt;strong&gt;RTR&lt;/strong&gt; 位置被 &lt;strong&gt;SRR(Substitute Remote Request)&lt;/strong&gt; 取代了，SRR 是一个固定的显性位，原来的 RTR 跑到 CAN ID B 的后边去了。具体可以看做是标准的 CAN 更换了一段额外的 SRR 和增加了一个 18 位的 CAN ID B 段。&lt;/p&gt;
&lt;p&gt;为什么要拓展呢，因为有些时候，CAN ID 也是有一定作用的，譬如接收方一般并不是接收所有的 CAN 信息，而是过滤只感兴趣的 CAN ID 帧。有些时候 CAN ID 会被分成两端，一段是发送方的地址，一段是接收方的地址，这样就需要更长的 CAN ID，但是 CAN ID 太长的话，数据发送的效率就会变低（拓展帧帧一共 100 多位，最多只有 60 位数据），所以拓展帧作为一种选择产生了，以满足某些特殊需要。&lt;/p&gt;
&lt;p&gt;注意，不是所有的 CAN 网络均支持拓展帧，只有支持 CAN2.0B 标准的 CAN 网络才支持拓展帧，仅支持 CAN2.0A 标准的 CAN 网络只能使用标准数据帧。&lt;/p&gt;
&lt;h2 id=&#34;heading-3&#34;&gt;远程帧&lt;/h2&gt;
&lt;p&gt;远程帧英文原意，是远程请求帧，顾名思义，发送此帧的设备请求另外一个节点发送数据。远程帧不包含数据段，但是依旧有 DLC 段，DLC 为请求的数据字节数。在远程帧后，一般会跟随着一个数据帧，由响应的节点发送。&lt;/p&gt;
&lt;p&gt;远程帧的结构与标准的数据帧或者拓展的数据帧基本一致，只有一个区别就是没有数据段，在 DLC 后紧跟着的就是 CRC 段。&lt;/p&gt;
&lt;h2 id=&#34;heading-4&#34;&gt;错误帧&lt;/h2&gt;
&lt;p&gt;错误帧和上述的 CAN 帧不同，错误帧有两个位段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;叠加的错误标志（6-12bits）段，由各个设备发送的错误叠加而成。&lt;/li&gt;
&lt;li&gt;错误边界段，由 8 个隐性位组成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;错误标志分为两种类型：&lt;/p&gt;
&lt;h4 id=&#34;heading-5&#34;&gt;主动错误标志&lt;/h4&gt;
&lt;p&gt;由 6 个显性位组成，由被检测到错误的节点（处于主动错误状态）发送。&lt;/p&gt;
&lt;h4 id=&#34;heading-6&#34;&gt;被动错误标志&lt;/h4&gt;
&lt;p&gt;由 6 个隐性位组成，由被检测到错误的节点（处于被动错误状态）发送。&lt;/p&gt;
&lt;p&gt;什么是主动错误状态和被动错误状态呢？这个和 CAN 网络中的错误计数器有关，每个 CAN 节点都有两个计数器，一个是 &lt;strong&gt;发送错误计数器(TEC)&lt;/strong&gt;，一个是 &lt;strong&gt;接收错误计数器(REC)&lt;/strong&gt;，当节点的错误计数值不同时，节点会进入不同的计数状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 TEC 或者 REC 小于 128，节点处于主动错误状态。&lt;/li&gt;
&lt;li&gt;当 TEC 或者 REC 大于 127 并且小于 255，节点进入被动错误状态。&lt;/li&gt;
&lt;li&gt;当 TEC 大于 255，节点进入 Bus Off 状态，不再发送接收任何帧，不对总线有任何影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;错误帧只会在 CAN 总线正在发送的时候才能产生，也就是说主动错误会直接打断当前发送的数据，被动错误标志不会打断总线的传输。错误计数器的累加和很多种情况有关，但是规则很简单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送错误会导致 TEC 加 8&lt;/li&gt;
&lt;li&gt;接收错误会导致 REC 加 1&lt;/li&gt;
&lt;li&gt;正确的发送和接受会使 TEC 和 REC 递减或者清 0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CAN 控制器一般会提供一个引脚来反馈错误，通常是经过中断方式通知 MCU 该节点进入了 Bus Off 状态或者检测到错误，但是有些芯片会提供完全的错误控制，譬如最常见的 Philips SJA1000。&lt;/p&gt;
&lt;p&gt;应该知道的是，错误的种类有哪些呢？
CAN 一共提供了不少于 5 种的错误检测方式，前两种工作在物理层层面，后 3 种工作在信息层。&lt;/p&gt;
&lt;h4 id=&#34;heading-7&#34;&gt;位错误&lt;/h4&gt;
&lt;p&gt;发送方独有错误，某个节点在总线上发送数据的时候是按位发送的，节点会自动在发送后，也像接收方一样对总线上的状态采样，一旦发现和自己的发送所需状态不同，即我发的数和总线上的不一样，（举个例子：我发的隐性位，我发完一检测，总线上却是一个显性位，错误产生）就是产生了一个位错误。&lt;/p&gt;
&lt;h4 id=&#34;heading-8&#34;&gt;位填充错误&lt;/h4&gt;
&lt;p&gt;在这个地方需要介绍一下 CAN 网络中的一个特有的特性，就是 &lt;strong&gt;位填充(Bit stuffing)&lt;/strong&gt; 不同于一般的异步总线，CAN 总线需要连续发送很长的一串位流，这就会导致在连续发送同一状态值（0 或 1）时的时间错位累加，这种错位不能在接收方被检测到，这样很有可能发送和接收时出现错位状态，所以 CAN 定义了如果总线上有&lt;strong&gt;连续 5 个&lt;/strong&gt;的 0 或者 1 时，会自动生成一个相反极性的位填充在后边，也相当于一个边界，防止连续过长相同位出现，举个例子：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;11111000011110000&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在传输时，其实是这样的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;11111&lt;strong&gt;0&lt;/strong&gt;0000&lt;strong&gt;1&lt;/strong&gt;1111&lt;strong&gt;0&lt;/strong&gt;0000&lt;strong&gt;1&lt;/strong&gt;&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一个 0 被填充后，导致后续的数据出现了 5 个连续相同状态，所以又产生了一连串位填充。&lt;/p&gt;
&lt;p&gt;位填充在接收的时候会被硬件忽视，但是硬件同时会检测有无填充，如果 5 个连续相同位后还是相同位，节点会认为产生了位填充错误，但是也有可能是别的节点产生了主动错误帧，无论是哪个，都会使总线上的数据传输挂起。&lt;/p&gt;
&lt;p&gt;然而，CAN 网络在 CRC 段时是没有位填充的，在这里不会产生位填充错误。&lt;/p&gt;
&lt;p&gt;位填充错误也会在主动错误标志产生时产生，如果一个节点没有检测到错误，同时别的节点发出主动错误标志帧，则该节点就会检测到位填充错误，同时产生错误，实现总线上设备错误同步，保证产生错误的帧不被所有设备接收。&lt;/p&gt;
&lt;h4 id=&#34;crc-&#34;&gt;CRC 错误&lt;/h4&gt;
&lt;p&gt;这个不用多说了，是接收方产生的错误，CRC 校验不符，说明该帧之前接收的数据不可靠。&lt;/p&gt;
&lt;h4 id=&#34;heading-9&#34;&gt;应答错误&lt;/h4&gt;
&lt;p&gt;发送方独有错误，检测到应答位为隐性，也即无应答。（CAN 总线不能只有一个节点，否则会无限产生应答错误）&lt;/p&gt;
&lt;h4 id=&#34;heading-10&#34;&gt;格式错误&lt;/h4&gt;
&lt;p&gt;接收的数据帧没有按照标准的格式，譬如 CRC 边界位或者 ACK 边界位不是隐性，EOF 段出现了显性位。&lt;/p&gt;
&lt;h3 id=&#34;heading-11&#34;&gt;错误同步&lt;/h3&gt;
&lt;p&gt;以上五种错误都会使主动状态下的节点触发主动错误标志，连续的 6 个主动错误标志会直接覆盖毁掉数据的发送，这时如果其余节点没有检测到错误时也会由于主动错误标志的破坏而检测到位填充错误，这样所有的设备都会同时检测到错误而丢弃之前的数据。&lt;/p&gt;
&lt;p&gt;错误帧与其说是一个帧，不如说是很多错误帧的叠加：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-12-12-CAN_Bus/CAN_error_frame.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;bus-failure-modes&#34;&gt;*总线失败错误(Bus Failure Modes)&lt;/h4&gt;
&lt;p&gt;这种错误是物理层错误，并不在上列错误之中，但是也要知道，如果 CAN 线路不符合 ISO 要求的电气标准时会产生该错误，在 ISO 11898 中规定了以下的总线失败：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CAN_H 断路&lt;/li&gt;
&lt;li&gt;CAN_L 断路&lt;/li&gt;
&lt;li&gt;CAN_H 和电池正极短路&lt;/li&gt;
&lt;li&gt;CAN_L 和地短路&lt;/li&gt;
&lt;li&gt;CAN_H 和地短路&lt;/li&gt;
&lt;li&gt;CAN_L 和电池正极短路&lt;/li&gt;
&lt;li&gt;CAN_L 和 CAN_H 短路&lt;/li&gt;
&lt;li&gt;CAN_L 和 CAN_H 同地点断路&lt;/li&gt;
&lt;li&gt;节点无法连接总线&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在实际环境下，某些错误包容型 CAN 收发器（譬如 TJA1053）可以处理以上的所有总线失败，但是其数据速度会受到影响（125bits/s)。&lt;/p&gt;
&lt;h2 id=&#34;heading-12&#34;&gt;过载帧&lt;/h2&gt;
&lt;p&gt;在过去，当设备的性能不是很好的时候，CAN 总线作为一个高速总线，有些节点还偏偏爱一连串发数据帧，相邻两帧间只有 3 位的 IFS 帧间空白时间内供其余节点处理数据，有些节点的数据处理能力较差，需要延长 IFS 时间，过载帧因此而生，过载帧由两段组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;叠加的过载标志（6-7bits）段，为显性，由各个设备发送的过载标志叠加而成。&lt;/li&gt;
&lt;li&gt;过载边界段，由 8 个隐性位组成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个帧很神奇，怎么神奇呢，它格式跟主动错误帧都一模一样，甚至也有同步的作用，，但是有一点和错误帧不同：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;过载帧在帧间空白 IFS 段内第一位开始&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个设备会在以下两种情况下发送过载帧：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于设备内部状态需要总线延迟下一帧的数据发送，在 IFS 段第一位开始产生过载标志。&lt;/li&gt;
&lt;li&gt;某设备检测到 IFS 段内有显性位。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以看到第二个发送过载帧的条件使总线上所有的过载帧都会同步，没有发送过载帧的节点会因为检测到过载帧而产生过载帧。&lt;/p&gt;
&lt;p&gt;过载帧不是错误帧，不会导致内部的错误计数器累加。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-12-12-CAN_Bus/CAN_overload_frame.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;过载帧将会使下一帧的发送时间推迟，具体推迟多少，发送节点根据规定自行选择。&lt;/p&gt;
&lt;p&gt;到此为止，所有的 CAN 规定的帧都已经介绍完毕了，到这里已经基本上可以说了解了 CAN 的基本内容了，但是还有些细节，这些细节不影响使用 CAN，但是了解一些也会有好处。&lt;/p&gt;
&lt;h2 id=&#34;heading-13&#34;&gt;位时间分配&lt;/h2&gt;
&lt;p&gt;CAN 在传输每一位的时候，在这一位的时间内，会做一系列的事情，并不是发送就完事了，我们知道，CAN 节点在发送数据的同时还会有检验位错误，在什么时候检测？在接收的时候还要有位时间的校准防止错位，如何自动校准？接收方在什么时刻采样捕获总线上的状态？这一部分的功能都在位时间内表现出来：&lt;/p&gt;
&lt;p&gt;CAN 总线每一位的时间，都可以分成以下的几个部分，在不同的部分内，CAN 控制器会做不同的事情。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-12-12-CAN_Bus/CAN_bit_time.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到一个位的时间其实可以被分成更小的 10 小份时间，其中第一小份是 &lt;strong&gt;SYNCHRONIZATION&lt;/strong&gt; 部分，也就是同步部分，这一部分主要用于捕获从隐性位到显性位的跳变沿。&lt;/p&gt;
&lt;h4 id=&#34;hard-synchronization--&#34;&gt;HARD SYNCHRONIZATION  硬同步&lt;/h4&gt;
&lt;p&gt;在每个 CAN 帧传输的开头，我们知道有一位的 SOF 帧起始，从总线空闲状态的隐性，向显性位跳变一次，在这个过程中，总线上所有的设备进入了 HARD SYNCHRONIZATION 状态，每个节点捕获到跳变后，都将这个跳变的时刻定义在第一位的 SYNCHRONIZATION 内，实现 CAN 帧开始的同步。&lt;/p&gt;
&lt;p&gt;我们知道 CAN 没有一根时钟同步线，所以 CAN 总线空闲的时候，是可以在任意时刻发起传输的，这个硬件同步确保了传输发起时的同步性，即所有设备在第一个隐-&amp;gt;显跳变沿同步。&lt;/p&gt;
&lt;p&gt;第二个阶段是 &lt;strong&gt;Propagation Segment&lt;/strong&gt; 部分，这一部分和后续的 &lt;strong&gt;Phase 1 Segment(相位缓冲 1)&lt;/strong&gt; 和 &lt;strong&gt;Phase 2 Segment(相位缓冲 2)&lt;/strong&gt; 都是可以更改的，在这里的长度只是一般情况下的长度 3 3 3 平均分布。&lt;/p&gt;
&lt;h4 id=&#34;heading-14&#34;&gt;位同步&lt;/h4&gt;
&lt;p&gt;一般情况下，每次隐性到显性的跳变沿都在开始的 SYNC 段内被捕获，在这种情况下，并不会触发位同步，而一旦检测到隐-&amp;gt;显跳变沿超出 SYNC 范围，譬如提前到前一帧的 Phase 2 中或者推迟到 SYNC 后的 Propagation Segment 段内，就会自动触发位同步功能，这时 CAN 会自动调整 Phase 1 Segment(相位缓冲 1) 或者 Phase 2 Segment(相位缓冲 2) 的长度，以使下一次跳变沿在 SYNC 段内捕获。&lt;/p&gt;
&lt;p&gt;举个例子：
&lt;img src=&#34;https://xiahualiu.github.io/img/2017-12-12-CAN_Bus/CAN_sync1.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果接收方发现自己相位靠前了，隐-&amp;gt;显跳边沿到 Prop 段了，就会自动在 Phase 1 缓冲中增加这个靠前的时长，这样当采样的时候，接收方和发送方已经做到了同步，增加的这个时长使得接收方的此位时间长了一丁点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-12-12-CAN_Bus/CAN_sync2.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;如果接收方前一位还未结束，在 Phase 2 缓冲区内就检测到了隐-&amp;gt;显跳变，则接收方此时强制进入下一位的 SYNC 状态，这导致了上一位的接收时间稍微短了一点点。&lt;/p&gt;
&lt;p&gt;请注意 SYNC 段只能捕获隐-&amp;gt;显跳变，显-&amp;gt;隐跳变由于时间一般较长，不会视作位同步的依据。&lt;/p&gt;
&lt;p&gt;到此为止，文章内容就已经全部结束了，如果有什么疑问或者本文有什么错误可以直接在下方留言，感谢您的交流！&lt;/p&gt;
&lt;h3 id=&#34;heading-15&#34;&gt;课后习题：&lt;/h3&gt;
&lt;p&gt;哈，还有课后习题？课后习题是一种反馈，在学习中非常重要。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DLC 为 0 的数据帧和远程帧有什么区别？&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;DLC 为 0 的数据帧没有数据段，虽然远程帧也没有数据段，但是远程帧的 DLC 一般都不等于 0，在远程帧中，DLC 对应的是请求的数据帧的数据段长度。当然还有 RTR 位两者的区别，在仲裁的时候，远程帧和数据帧在 CAN ID 优先级相同的条件下由于 RTR 位数据帧为 0 所以优先于远程帧。&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    <item>
      <title>Deep Understanding of C pointers</title>
      <link>https://xiahualiu.github.io/posts/2017-12-07-c-pointer/</link>
      <pubDate>Thu, 07 Dec 2017 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2017-12-07-c-pointer/</guid>
      <description>&lt;p&gt;在 C 语言中，要说什么概念最难理解，那指针当仁不让处于第一的位置，初学者对于指针是叫苦不堪，即使是熟练地程序员在写程序的时候，复杂的指针也会使程序的可读性大大降低。&lt;/p&gt;
&lt;p&gt;但是指针又是 C 语言的一个特点，使用指针可以使编程更加容易。而且有些任务，譬如动态内存分配，如 &lt;code&gt;malloc&lt;/code&gt; &lt;code&gt;calloc&lt;/code&gt; &lt;code&gt;realloc&lt;/code&gt; 函数的使用又必须依赖指针，所以如果想要成为一个熟练的 C 程序员，理解熟练使用指针是非常必要的。&lt;/p&gt;
&lt;h2 id=&#34;heading&#34;&gt;什么是指针&lt;/h2&gt;
&lt;p&gt;首先，在程序运行中，变量都是存在计算机的内存中的。指针是一种变量，它的值是&lt;strong&gt;另外一个变量的地址&lt;/strong&gt;，也就是直接的内存地址，在 32 位系统中，指针的大小为 4 字节（在远古时期的远指针，近指针，巨指针，等不参加讨论），很好理解，一个字节长度为 8 bits，4 bytes = 32 bits，如果在最新的 64 位系统中编译并且运行的话，指针会变成 8 字节的长度，因为对应的地址位宽增加了。&lt;/p&gt;
&lt;p&gt;运行以下的内容就可以发现, 打印的是 8 个 16 进制的字符，也就是 4 个字节。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt; () {

   &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;  var1;
   &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; var2[&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;];

   printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Address of var1 variable: %x&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;var1  );
   printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Address of var2 variable: %x&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;var2  );

   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$gcc -o main *.c
$main
Address of var1 variable: 9f98435c
Address of var2 variable: 9f984352
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在上边的例子中，&lt;code&gt;var1&lt;/code&gt; 就是一个指针，它内部存有一个 &lt;code&gt;int&lt;/code&gt; 型变量的地址， 而 &lt;code&gt;var2&lt;/code&gt; 存着一个 &lt;code&gt;char[10]&lt;/code&gt; 数组的地址。在平常描述中，通常使用『&lt;strong&gt;指向&lt;/strong&gt;』这个动词来描述指针与对应变量的关系，我们可以说 &lt;code&gt;var1&lt;/code&gt; 指针指向某个（因为还未定义哪个） &lt;code&gt;int&lt;/code&gt; 型的变量。通过这个例子的打印结果我们可以看到，不管指针指向什么类型的变量，它的本身长度，始终都是固定的值，在本例中为 4bytes，不同指针唯一的不同就是指针变量内部存的值的不同，也即是指针所对应的地址不同。&lt;/p&gt;
&lt;h2 id=&#34;heading-1&#34;&gt;如何使用指针&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;指针的操作符很少，只有 &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; 两种。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; 是引用符号，对一个普通的变量，数组，结构，等类型使用可以取得其地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; 是解除引用符号，对于指针使用可以返回其指向的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt; () {
   &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;  var &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;;   &lt;span style=&#34;color:#75715e&#34;&gt;/* 整形变量声明定义 */&lt;/span&gt;
   &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;  &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ip;        &lt;span style=&#34;color:#75715e&#34;&gt;/* 指针声明 */&lt;/span&gt;
   ip &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;var;  &lt;span style=&#34;color:#75715e&#34;&gt;/* 将 var 变量的值赋给 ip*/&lt;/span&gt;

   printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;var 的地址是: %x&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;var  );
   printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;ip 中储存的地址是: %x&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, ip );
   printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;原本 *ip 的值是: %d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ip );
   printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;原本 var 的值是: %d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, var );

   &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ip&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;

   printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;*ip 现在的值是: %d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ip );
   printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;var 现在的值是: %d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, var );
   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行结果:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$gcc -o main *.c
$main
var 的地址是: f977beb4
ip 中储存的地址是: f977beb4
原本 *ip 的值是: &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;
原本 var 的值是: &lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;
*ip 现在的值是: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
var 现在的值是: &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到，当我修改 &lt;code&gt;*ip&lt;/code&gt; 的值的时候， &lt;code&gt;var&lt;/code&gt; 整形变量的值也发生了变化，这是因为我们是通过 &lt;code&gt;ip&lt;/code&gt; 这个指针修改的，程序通过这个指针中的地址找到了对应的内存（var 所在），然后将这段内存修改成为了 10 ，这个过程相当于直接修改了在内存中 &lt;code&gt;var&lt;/code&gt; 对应的值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请不要直接将变量的值直接赋值给指针本身！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;错误用法：&lt;code&gt;ip = (int)10;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;warning: assignment makes pointer from integer without a cast &lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;-Wint-conversion&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt;
    ip&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;int&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;10;
      ^
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;指针变量的类型和一般的变量不同，直接这样赋值会导致编译错误，而且这种操作毫无意义。&lt;/p&gt;
&lt;p&gt;指针是可以赋给另外一个指针的，这样两个指针指向了同一个地方，但是这种一个地址对应两个指针的操作在某种意义上是比较危险的，因为这样对应的值很有可能被误修改，或者内存被释放后导致&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%BF%B7%E9%80%94%E6%8C%87%E9%92%88&#34;&gt;迷途指针&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&#34;null-&#34;&gt;NULL 指针&lt;/h2&gt;
&lt;p&gt;又名&lt;strong&gt;空指针&lt;/strong&gt;，指针内的值为 NULL，指针还没有分配指向的实体，NULL 指针会出现在指针的声明时，也就是我们第一个例子中的两个指针，只声明了对应的类型，没有实际赋予其地址，又称没有被初始化。&lt;/p&gt;
&lt;p&gt;空指针中的值是 4 个字节的 0，而在计算机系统结构中，0 地址的内存一般情况下是被保留给操作系统运行的，里面已经有了一些操作系统运行中所需要的值，所以利用 NULL 指针修改对应的内存的话，后果可想而知。&lt;/p&gt;
&lt;p&gt;解决空指针的办法就是在指针声明后，进行赋值，将指针变成一个指向固定地址的变量。&lt;/p&gt;
&lt;h2 id=&#34;heading-2&#34;&gt;指针运算&lt;/h2&gt;
&lt;p&gt;指针的运算符有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;++&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们主要就 +/- 运算进行讲解，因为 ++/&amp;ndash; 不就是 +1/-1 么。&lt;/p&gt;
&lt;p&gt;如果我们定义了一个指针指向一个 int 型变量（4 字节长度），请在脑中构思这个创建指针和定义的过程，然后我们对这个指针加 1。&lt;/p&gt;
&lt;p&gt;实际上，指针内部的地址并不是简单的加 1，而是加了 4，也就是在内存中移动到了 4 个字节后的下一个 int 变量。&lt;/p&gt;
&lt;p&gt;这个特性使得我们不用去注意一些非常底层的概念，最普遍的使用地点就是在一串同类数据中切换数据，也就是在数组中使用指针。&lt;/p&gt;
&lt;p&gt;在使用这个的过程中，请保证自己不会将指针移动到未声明的内存空间中，譬如上述单个 int 变量的指针偏移，否则将有大几率损坏其他变量数据。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; MAX &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt; () {

   &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;  var[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;};
   &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;  i, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ptr;
    
   ptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; var;

   &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; ( i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; MAX; i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;) {

      printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;var[%d] 地址 = %x&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, i, ptr );
      printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;var[%d] 值 = %d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, i, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ptr );

      ptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ptr&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;      &lt;span style=&#34;color:#75715e&#34;&gt;//等于 ptr++
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;   }
	
   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行结果:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$gcc -o main *.c
$main
var&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; 地址 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 220fe454
var&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;0&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; 值 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
var&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; 地址 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 220fe458
var&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;1&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; 值 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;
var&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;2&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; 地址 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 220fe45c
var&lt;span style=&#34;color:#f92672&#34;&gt;[&lt;/span&gt;2&lt;span style=&#34;color:#f92672&#34;&gt;]&lt;/span&gt; 值 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;200&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到地址每次增加的值是 4。在这个例子中，如果你仔细读代码则会发现，我们使用了如下的代码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;   ptr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; var;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而在编译运行的过程中并没有错误产生，这是应为它本身就没有错误，在 c 语言中，数组的名字会被当做一个指针处理，其中的 var 可以被看做 &lt;code&gt;int * const var_name = &amp;amp;var[0];&lt;/code&gt; 中的 &lt;code&gt;var_name&lt;/code&gt;，也就是说，数组名其实是一个指针，而它对应的地址就是 var[0] 的地址。&lt;/p&gt;
&lt;p&gt;由于这是一个常量指针，其特点是指针内的地址不可以变动，也就意味着这个指针不能够指向其他的 int 变量了。也就是:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; var_name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;var[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;];
var_name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;是错误的:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;error: assignment of read-only variable ‘var_name’
    var_name &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;(&lt;/span&gt;int *&lt;span style=&#34;color:#f92672&#34;&gt;)&lt;/span&gt;10;
             ^
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;我试了直接给 var = 另外的指针，但是显示错误不是这个，显示的是 &lt;code&gt;error: assignment to expression with array type&lt;/code&gt; ，但是原理是一样的。&lt;/p&gt;
&lt;p&gt;还有一种数组，叫做字符数组，其主要形式是以下形式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; ch[&lt;span style=&#34;color:#ae81ff&#34;&gt;20&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;{&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;hello world&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这句话，定义了一个具有 20 个元素的数组，元素的类型为 char 型，也就是字符型，数组的第一个元素是 h，第二个是 e，数组被依次填入&amp;quot;hello world\0&amp;rdquo;，其中 &lt;code&gt;\0&lt;/code&gt; 为终止符。&lt;/p&gt;
&lt;p&gt;在 C 语言中，&amp;ldquo;hello world&amp;rdquo; 这样的字符串其实本质是一个指针，指向字符串开头的地址。在赋值或者打印的时候，C 语言会使用这个指针自动的将字符串从头读取到终止符。&lt;/p&gt;
&lt;p&gt;从下边这个例子来解释：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; MAX &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt; () {

   &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ptr&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Hello world&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;;
   printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;,ptr);

   &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行结果是打印了 Hello world，在这个地方，我们直接用字符串给一个指针赋值了，但是编译器并没有报错。&lt;/p&gt;
&lt;h2 id=&#34;heading-3&#34;&gt;二级指针&lt;/h2&gt;
&lt;p&gt;因为指针是一个变量，故其在内存中也有一个储存的地址，而这个地址可以赋值给另外一个指针。当一个指针指向另外一个指针的时候，此指针就是二级指针。&lt;/p&gt;
&lt;p&gt;二级指针的声明如下:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;var;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你觉得之前的内容很简单，指针现在的恐怖之处才体现出来，对于二级指针的解除引用 &lt;code&gt;*&lt;/code&gt; 一次之后还是指针，只有解除两次之后才能成为真正的指向的数值变量。&lt;/p&gt;
&lt;h2 id=&#34;heading-4&#34;&gt;函数指针&lt;/h2&gt;
&lt;p&gt;在 C 语言中，函数指针一直就是一个很神奇的东西，因为它有很多违反常规的设定，函数其实和变量一样，都储存在内存中，只不过这部分内存存的是一些命令而不是值，函数名就像是数组名一样对应着它的入口地址，所以我们可以用一个指针指向函数，这样指针就能代表函数了。&lt;/p&gt;
&lt;p&gt;函数指针和普通指针不同的是，函数指针声明的是函数的&lt;strong&gt;返回值&lt;/strong&gt;和&lt;strong&gt;参数&lt;/strong&gt;，而不是仅仅变量类型。&lt;/p&gt;
&lt;p&gt;譬如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p)(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;声明了这个指针指向的是一个函数，该函数具有 int 返回值和 const char * （在 C 中遇到它，99% 对应字符串）的参数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;string_print&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;s){
    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;,s);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(){

    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; a;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;p)(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;);
    
    p&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;string_print;

    a&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;string_print(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;WINNER WINNER CHIKEN DINNER!&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
    a&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;p(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;WINNER WINNER CHIKEN DINNER!&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$gcc -o main *.c
$main
WINNER WINNER CHIKEN DINNER!
WINNER WINNER CHIKEN DINNER!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;看，这个指针指向函数后，用指针名就可以直接调用这个函数，如果有很多函数，我们就可以在运行的时候动态的调用不同的函数了。&lt;/p&gt;
&lt;p&gt;如果你眼睛够尖，或者你认真看了我上面的所有内容的话，会发现一个问题，我这个地方给指针赋值用的是:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;    p&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;string_print;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;函数名不就是地址么？再取地址不就是二级指针了么？你想的不错，这个地方其实说明了一个问题，如果函数名是地址的话，我们调用就要用 &lt;code&gt;*&lt;/code&gt; 来解除引用后才能声明和定义函数，但是 C 为了使大家使用方便就去掉了函数调用定义时加 &lt;code&gt;*&lt;/code&gt; 的过程，也就是说使用函数名其实就已经是解除引用后的地址了，这样说可能看起来比较难受，其实，&lt;code&gt;p=&amp;amp;string_print;&lt;/code&gt; 和 &lt;code&gt;p=string_print;&lt;/code&gt; 这两句话在这里是完全一样的，哈哈，不信你试试，输出结果完全一样，编译也不会报错。也就是说函数名既可以看做是一个实际的实体，也可以看做是一个地址，但是在定义以及声明函数的时候，不能定义函数名前面加 &lt;code&gt;*&lt;/code&gt;，因为这样就变成函数指针了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;string_print)(&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;s){
    printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;,s);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;是错误的，无法通过编译，因为这样的 &lt;code&gt;string_print&lt;/code&gt; 就是函数指针了哦。&lt;/p&gt;
&lt;h2 id=&#34;heading-5&#34;&gt;指针结合&lt;/h2&gt;
&lt;p&gt;到此为止，一般的指针类型都已经介绍完毕了，但是这仅仅是指针的基础知识，有时候我们需要的是一些更加复杂的指针类型，譬如我想让 &lt;code&gt;p&lt;/code&gt; 是一个指向数组的指针，在数组中的元素均为指向 &lt;code&gt;int&lt;/code&gt; 的指针。那这个指针该怎么声明呢？&lt;/p&gt;
&lt;p&gt;我们介绍了函数指针，在上个章节，有人会发现我在声明指针时，用小括号圈起来了指针（&lt;code&gt;int (*p)(const char *);&lt;/code&gt;）,可能你会想为什么要多次一举的加上一个括号呢，这个地方就牵涉到了指针中运算符的优先级的问题。（这个括号是必须的，没有就不是函数指针了，而是返回指针的函数了）&lt;/p&gt;
&lt;p&gt;在学习指针结合的开始，我们要首先了解 C 语言中的运算符的结合优先级，指针结合的优先级使用 C 语言中规定的运算符优先级。&lt;/p&gt;
&lt;p&gt;参阅&lt;a href=&#34;http://zh.cppreference.com/w/cpp/language/operator_precedence&#34;&gt;C++ 运算符优先级&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;大概浏览一下就可以咯，下面让我们先从简单的类型开始慢慢分析吧:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;int ptr;&lt;/code&gt; 这是一个普通的整型变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int *ptr;&lt;/code&gt; 从 ptr 处开始，先与 * 结合，说明 ptr 是一个指针，然后再与 int 结合，说明指针所指向的内容的类型为 int 型。所以 ptr 是一个返回整型数据的指针。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int ptr[3];&lt;/code&gt;  从 ptr 处开始，先与 [] 结合，说明 ptr 是一个数组，然后与 int 结合，说明数组里面的元素类型是整型的，所以 ptr 是一个由整型数据组成的数组。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int *ptr[3];&lt;/code&gt; 从 ptr 开始，左边是 * 运算，右边是 [] 运算，由于 [] 运算符的优先级比 * 高，所以先与 [] 结合，说明 ptr 是一个数组，然后再与 * 结合，说明数组元素的类型是指针类型，最后与 int 结合，说明指针所指向的内容的类型是整型数据。
所以 ptr 是一个&lt;strong&gt;整型数据的指针&lt;/strong&gt;所组成的&lt;strong&gt;数组&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int (*ptr)[3];&lt;/code&gt; 从 ptr 开始，首先与 * 结合，() 是为了提高 * 相对于 [] 的优先级，所以 ptr 是一个指针，然后与 [] 结合，说明 ptr 是指针，指向的内容是一个数组，最后与 int 结合，说明数组里的元素是整型的。
所以 ptr 是一个&lt;strong&gt;指向由整型数据组成的数组&lt;/strong&gt;的&lt;strong&gt;指针&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int **ptr;&lt;/code&gt; 从 ptr 开始，先与 * 结合，说是 ptr 是一个指针，然后再与 * 结合，说明指针所指向的元素是指针，然后再与 int 结合，说明该指针所指向的元素是整型数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int ptr(int);&lt;/code&gt; 从 ptr 处起，先与 () 结合，说明 ptr 是一个函数，然后进入 () 里分析，说明该函数有一个整型变量的参数，然后再与外面的 int 结合，说明函数的返回值是一个整型数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int (*ptr)(int);&lt;/code&gt; 从 ptr 处开始，先与指针结合，说明 ptr 是一个指针，然后与 () 结合，说明指针指向的是一个函数，然后再与 () 里的 int 结合，说明函数有一个 int 型的参数，再与最外层的 int 结合,说明函数的返回类型是整型。
所以 ptr 是一个指向&lt;strong&gt;有一个整型参数且返回类型为整型的函数&lt;/strong&gt;的指针。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int *ptr(int);&lt;/code&gt; 从 ptr 处开始，先与 () 结合，说明 ptr 是一个函数，然后与 * 结合，说明函数返回值是一个指针，然后再与 int 结合，说明函数返回指针指向 int。
所以 ptr 是一个&lt;strong&gt;有一个整型参数且返回类型为指向整型的指针&lt;/strong&gt;的&lt;strong&gt;函数&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int *(*ptr(int))[3];&lt;/code&gt; 难度 MAX，从 ptr 开始，先与 () 结合，说明 ptr 是一个函数,然后进入 () 里面，与 int 结合，说明函数有一个整型变量参数，然后再与外面的 * 结合，说明函数返回的是一个指针（参考上边的第9条），然后到最外面一层，先与 [] 结合，说明返回的指针指向的是一个数组，然后再与 * 结合，说明数组里的元素是指针，然后再与 int 结合，说明指针指向的内容是整型数据。
所以 ptr 是一个指向&lt;strong&gt;参数为一个 int 且返回一个指向由整型指针变量组成的数组的指针变量&lt;/strong&gt;的&lt;strong&gt;函数&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上列中的 &lt;strong&gt;4. 5.&lt;/strong&gt; 是很多考试的考点，其中 &lt;code&gt;int *ptr[3];&lt;/code&gt; 中 ptr 有个称号叫做 &lt;strong&gt;指针数组&lt;/strong&gt; ，&lt;code&gt;int (*ptr)[3];&lt;/code&gt; 中 ptr 有个称号叫做 &lt;strong&gt;数组指针&lt;/strong&gt;，连名字都几乎一模一样，新手大多头疼这两个的判断，其实按照上述的方法来处理指针结合的话，两种类型的区别还是很好判断的。&lt;/p&gt;
&lt;p&gt;数组指针，是一个指向数组的指针，注意这里的指针不等同与数组名指针，这个指针指向的，是一个整体数组，而数组名指针指向的是数组中的元素。数组指针加 1 后，会跨过整个数组长度总和，而数组名加 1 只会增加一个元素的长度。举个例子就是：数组指针是班号，加 1 后移动到下个班，数组名是班级内的学号，加 1 后移动到下个学生。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-12-7-C-pointer/ap&amp;amp;pa.png&#34; alt=&#34;ap&amp;pa.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;其中 p 为普通函数名指针，ptr 为数组指针。
我们可以看到数组指针可以跳过一整个行数组，用途在哪里最普遍？二维数组中。&lt;/p&gt;
&lt;p&gt;指针数组不用多介绍了，就是个普通数组，里面装的全是指针而已。&lt;/p&gt;
&lt;h2 id=&#34;--&#34;&gt;常量指针 &amp;amp; 指针常量&lt;/h2&gt;
&lt;p&gt;我们在介绍数组名是指针的时候用到了一个指针类型，叫做“指针常量”，也就是 &lt;code&gt;int * const var_name = &amp;amp;var[0];&lt;/code&gt; 中的指针，这种指针内部的地址不能变动，只能在声明的时候定义一次，也就是不能指向别的变量了。&lt;strong&gt;指针本身是一个常量&lt;/strong&gt;就称作&lt;strong&gt;指针常量&lt;/strong&gt;我们称，数组名就是一种指针常量。字符串，也是一种指针常量。&lt;/p&gt;
&lt;p&gt;还有一种指针，它本身不是常量，但它指向的是常量，大家想一想，这个指针的声明该怎么写？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; c&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ptr&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;c;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;或者：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; c&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;ptr&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;c;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;是一样的。但是要清楚一点，这个常量的定义，是指不能通过 ptr 这个指针来修改 c 中的值了（&lt;code&gt;*ptr=20;&lt;/code&gt; 会提示错误），但是 c 本身不是常量，用其他的指针或者，直接通过 &lt;code&gt;c=20;&lt;/code&gt; 都是可以修改 c 的值的。这种&lt;strong&gt;指向常量的指针&lt;/strong&gt;就叫做&lt;strong&gt;常量指针&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指针常量/常量指针&lt;/strong&gt; 这两种是不是特别容易搞混啊？考试就考这个了！其实按照我们的结合律来判断也非常好判断，如果指针名先跟 const 结合了，这个指针内的地址就不能变了，那就是指针常量，而如果指针名先跟 * 结合了，这就说明指针是可变的，然后遇到了 const 和某种类型，那就说明指针指向了某种常量，是常量指针。&lt;/p&gt;
&lt;p&gt;来一个难一点的判断：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;test)();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;首先从名字入手，&lt;code&gt;(*test)&lt;/code&gt; 说明 test 是一个指针，然后向外，() 优先级较高，先判断后面的小括号，说名 test 指针指向一个没有参数的函数，其返回值目前未知，然后向前判断，首先遇到了一个 *，说明返回值也是一个指针，指向了前面的 &lt;code&gt;(int * const)&lt;/code&gt; ，接着跟 const 结合，返回指针为指针常量，接着是 &lt;code&gt;(int *)&lt;/code&gt; 说明这个指针常量是一个二级指针，它指向了一个指向 int 型的指针。&lt;/p&gt;
&lt;p&gt;也就是说 &lt;code&gt;test&lt;/code&gt; 是一个指针，指向了一个函数，函数不接受参数，并且返回一个二级指针，这个二级指针是个指针常量，解除引用一次后的指针，指向一个 int 型变量。&lt;/p&gt;
&lt;p&gt;当然 “常量指针常量” 这种变态也是存在的，这种指针不能修改地址，其对应的变量也不能通过此指针改变。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; ptr&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如果你之前写过程序，或者看我上文的函数指针例子中，发现很多字符串处理函数的字符串参数都是 &lt;code&gt;const char *&lt;/code&gt; 这种类型，你就应该明白了，字符串譬如 &lt;code&gt;&amp;quot;Hello world&amp;quot;&lt;/code&gt; 本质其实就是一个常量指针，&lt;code&gt;const char *&lt;/code&gt; 的存在是为了保证内部的字符不会因为这个指针而发生改变。注意，如果你用一个字符串给指针赋值的话，这个指针是不能修改字符串的内容的，否则会报错哦。&lt;/p&gt;
&lt;p&gt;所以常量指针的存在意义其实是为了保护数据，在操作的过程中不会因为一些错误修改而改变了内存中对应的数据的值。其意义还是十分重大的！&lt;/p&gt;
&lt;p&gt;到此为止，如果你全部掌握了以上的内容，恭喜，你已经熟练掌握指针的操作了！&lt;/p&gt;
&lt;p&gt;最后留一个问题，如果本文最后的 test 指针，我想让他的返回值是一个二级指针，但这个二级指针的解引用一次之后才是一个常量指针该怎么改写这个声明呢？非常简单啊哈哈！&lt;/p&gt;</description>
    </item>
    <item>
      <title>FT_Write Commands</title>
      <link>https://xiahualiu.github.io/posts/2017-11-28-ft232h-command/</link>
      <pubDate>Tue, 28 Nov 2017 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2017-11-28-ft232h-command/</guid>
      <description>&lt;p&gt;在使用 &lt;code&gt;FT_Write&lt;/code&gt; 发送命令的时候应该注意，一个标准的命令包含一个操作字节（OPCODE）和几个从属的字节，所有的命令都是以字节为单位发送的。&lt;/p&gt;
&lt;h1 id=&#34;heading&#34;&gt;数据发送命令&lt;/h1&gt;
&lt;p&gt;这个是控制 MPSSE 发送数据时候的设置字节组成:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bit 0 : 在下降沿发送&lt;/li&gt;
&lt;li&gt;Bit 1 : 1 为 bits 发送，其他为 bytes 发送&lt;/li&gt;
&lt;li&gt;Bit 2 : 在下降沿读取&lt;/li&gt;
&lt;li&gt;Bit 3 : 1为LSB first, 其他为 MSB first&lt;/li&gt;
&lt;li&gt;Bit 4 : 允许写 TDI（允许发送数据）&lt;/li&gt;
&lt;li&gt;Bit 5 : 允许读 TDO（允许接收数据）&lt;/li&gt;
&lt;li&gt;Bit 6 : 开启写入时的 TMS（片选）&lt;/li&gt;
&lt;li&gt;Bit 7 : 0&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;msb-&#34;&gt;MSB 首先&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;设置字节&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;数据是否接收&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;数据是否发送&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;位/字节&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;接收数据的&lt;strong&gt;捕获&lt;/strong&gt;时钟沿&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;发送数据的&lt;strong&gt;变化&lt;/strong&gt;时钟沿&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x10&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BYTES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上升沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x11&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BYTES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;下降沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BITS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上升沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x13&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BITS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;下降沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x20&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BYTES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上升沿&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x24&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BYTES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;下降沿&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x22&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BITS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上升沿&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x26&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BITS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;下降沿&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x31&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BYTES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上升沿&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;下降沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x34&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BYTES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;下降沿&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上升沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x33&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BITS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上升沿&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;下降沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x36&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BITS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;下降沿&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上升沿&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;举例子:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如果发送字节在上升沿，MSB，不读取，则发送的字节顺序为:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;0x10,
LengthL,
LengthH,
Byte1
..
Byte65536 (max)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;长度 &lt;code&gt;0x0000&lt;/code&gt; 为 1 字节，&lt;code&gt;0xffff&lt;/code&gt; 为 65536 字节，最多一次可以发送 65536，因为缓存只有 64KB。第一个字节的第 7 位，也就是首先要发送的位会被放置在 TDI/DO 上，然后时钟会开始第一个跳变，数据会在下一个上升沿变化。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;如果读取字节在上升沿，MSB，不发送，则发送的字节顺序为:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;0x20,
LengthL,
LengthH
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个设置字节会在 TDO/DI 端口接收 1 - 65536 个字节，第一个位会是第一个字节的 MSB（最高位），数据会在每个 CLK 的上升沿进行捕获。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;接收数据并且发送数据，MSB 首先:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;0x31,   // 发送数据在下降沿跳变，接收数据在上升沿捕获
LengthL,
LengthH,
Byte1
..
Byte65536 (max)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;lsb-&#34;&gt;LSB 首先&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;设置字节&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;数据是否接收&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;数据是否发送&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;位/字节&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;接收数据的&lt;strong&gt;捕获&lt;/strong&gt;时钟沿&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;发送数据的&lt;strong&gt;变化&lt;/strong&gt;时钟沿&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x18&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BYTES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上升沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x19&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BYTES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;下降沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x1A&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BITS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上升沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x1B&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BITS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;下降沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x28&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BYTES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上升沿&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x2C&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BYTES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;下降沿&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x2A&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BITS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上升沿&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x2E&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BITS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;下降沿&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x39&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BYTES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上升沿&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;下降沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x3C&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BYTES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;下降沿&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上升沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x3B&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BITS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上升沿&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;下降沿&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x3E&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BITS&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;下降沿&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;上升沿&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;具体例子可以参考上述的 MSB 章节，几乎一模一样。&lt;/p&gt;
&lt;h2 id=&#34;heading-2&#34;&gt;初始化端口状态&lt;/h2&gt;
&lt;p&gt;端口分为高 8 位和低 8 位。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;设置字节&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;设置状态&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;读取状态&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;高 8 位&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;低 8 位&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x80&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x82&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x81&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x83&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;heading-3&#34;&gt;设置状态值和方向&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;0x80,
0xValue,
0xDirection
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会设置低 8 位端口的方向和状态值。&lt;br&gt;
1 为输出方向，0 为输入方向。&lt;/p&gt;
&lt;h3 id=&#34;heading-4&#34;&gt;读取值&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;0x81,
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;会读取当前的端口状态值，返回一个字节。&lt;/p&gt;
&lt;h2 id=&#34;heading-5&#34;&gt;内部回环&lt;/h2&gt;
&lt;p&gt;内部短接 TDI/DO 和 TDO/DI，以测试传输。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;设置字节&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;是否回环&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x84&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x85&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;NO&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;heading-6&#34;&gt;设置分频因子&lt;/h2&gt;
&lt;p&gt;对于 FT232H/FT2232H/FT4232H 型号，发送 &lt;code&gt;0x8A&lt;/code&gt; 可以关闭内部的 5 预分频器。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0x86,
0xValueL,
0xValueH,
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;TCK period = 60MHz / (( 1 +[ (0xValueH * 256) OR 0xValueL] ) * 2)&lt;/p&gt;
&lt;h2 id=&#34;ft232hft2232hft4232h-&#34;&gt;FT232H/FT2232H/FT4232H 特殊的指令&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;操作字节&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x8A&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;关闭 5 预分频器，主时钟频率为 60MHz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x8B&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启 5 预分频，以便于适应 FT2232D&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x8C&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启三相数据时钟，&lt;!-- raw HTML omitted --&gt;使用 I2C 总线会使数据在双时钟沿传送&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x8D&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;关闭三相数据时钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x8E&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;允许时钟在无数据输出的时候输出，&lt;!-- raw HTML omitted --&gt;通常用于 JTAG 状态机，时钟按位计算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x8F&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;允许时钟在无数据输出的时候输出，&lt;!-- raw HTML omitted --&gt;通常用于 JTAG 状态机，时钟按字节计算&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x94&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;允许时钟在无数据输出的时候输出，&lt;!-- raw HTML omitted --&gt;直到 GPIOL1 输入 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x95&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;允许时钟在无数据输出的时候输出，&lt;!-- raw HTML omitted --&gt;直到 GPIOL1 输入 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x96&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;开启适应性时钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x97&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;关闭适应性时钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x9C&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;允许时钟在无数据输出的时候输出，&lt;!-- raw HTML omitted --&gt;直到 GPIOL1 输入 1 或者一定数量的时钟被发送&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0x9C&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;允许时钟在无数据输出的时候输出，&lt;!-- raw HTML omitted --&gt;直到 GPIOL1 输入 0 或者一定数量的时钟被发送&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ftstatus-&#34;&gt;ftStatus 错误状态分析：&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;错误码&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;错误类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无效的 HANDLE&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;未找到设备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;设备未被打开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;设备 IO 错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;资源不足&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;参数无效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无效波特率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;设备擦拭未打开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;设备写入未打开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;写入设备无效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;EEPROM 读取失败&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;EEPROM 写入失败&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;13&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;EEPROM 擦拭失败&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;14&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;EEPROM 不存在&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;15&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;EEPROM 未格式化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;16&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;无效的参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;17&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;不支持的类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;18&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;其他错误&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
    <item>
      <title>FT232H Notes</title>
      <link>https://xiahualiu.github.io/posts/2017-11-13-ft232h-1/</link>
      <pubDate>Mon, 13 Nov 2017 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2017-11-13-ft232h-1/</guid>
      <description>&lt;p&gt;好久不见了朋友们。&lt;/p&gt;
&lt;p&gt;这段时间忙于项目设计上面的问题，前一段时间在 S32K144 上面进行了针对 W5500 以太网模块的适配，结果不尽人意，速度最快也只能到达 520KB/s 的速度（在 20MHz 的 LPSPI 时钟频率下），由于项目要求至少能够达到 1Mb/s 的速度，所以只能换一个芯片，于是我发现了这一块芯片，英国 FTDI 半导体公司生产的 FT232H 芯片，主要是实现了 USB 到各个单片机其他协议的转换功能，根据其官方数据，其 SPI 端口最多可以支持 30MHz 的时钟频率，这个速度相当可观，因为在大部分情况下，SPI 的时钟频率都不会超过这个值，相当于 SPI 的物理极限了。但是这块芯片的资料实在是少之又少，大部分人使用这块芯片都是在 FPGA 上设计 FIFO 转 USB 功能的，所以又回到了最艰苦奋斗的状态————读文档，幸好本渣英语好，加上 S32K144 2000 页的文档都搞定了，这个几百页的基本上不算问题了。&lt;/p&gt;
&lt;h3 id=&#34;ft232h-&#34;&gt;FT232H 基本信息&lt;/h3&gt;
&lt;p&gt;（全部翻译自官方文档）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单通道的 USB to 串/并口&lt;/li&gt;
&lt;li&gt;片内 USB 全协议处理，不需要额外的硬件编程需要&lt;/li&gt;
&lt;li&gt;支持 USB2.0(480Mbits/s) 和 USB Full-Speed(8Mbits/s)&lt;/li&gt;
&lt;li&gt;多协议同步串口引擎（MPSSE）简化了同步串口协议的设计流程&lt;/li&gt;
&lt;li&gt;UART 传输速率可达 12Mbaud（RS232 传输速度受到外部的电平转变器的限制）&lt;/li&gt;
&lt;li&gt;USB to 异步 245 FIFO 模式可达 8Mbytes/s 的速度&lt;/li&gt;
&lt;li&gt;USB to 同步 245 FIFO 模式可达 40Mbytes/s 的速度&lt;/li&gt;
&lt;li&gt;支持一个半双工 FT1248 界面，可以设置的数据总线宽度(1, 2, 4 or 8 bits wide)&lt;/li&gt;
&lt;li&gt;CPU-style FIFO 界面简化 CPU 界面设计&lt;/li&gt;
&lt;li&gt;快速串口界面选项&lt;/li&gt;
&lt;li&gt;FTDI 皇家自由虚拟串口（VCP），和直接（D2XX）降低了开发 USB 驱动的设计需求&lt;/li&gt;
&lt;li&gt;可调整的接受数据缓冲超时&lt;/li&gt;
&lt;li&gt;发送或者接受 LED 驱动信号&lt;/li&gt;
&lt;li&gt;Bit-Bang 模式界面设置通过 RD# 和 WR# 频闪&lt;/li&gt;
&lt;li&gt;高度集成化设计，包含了 5V 到 3.3V 或 +1.8V 的 LDO 线性稳压器给 VCORE 供电，并集成 POR 上电复位功能&lt;/li&gt;
&lt;li&gt;异步 UART 界面选项，包含完全的硬件握手和调制信号功能&lt;/li&gt;
&lt;li&gt;支持硬件 X-ON 和 X-OFF 握手&lt;/li&gt;
&lt;li&gt;UART 支持 7/8 bits 数据位 1/2 bits 停止位和，奇校验/偶校验/Mark&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;/Space&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;/无校验位 校验方式&lt;/li&gt;
&lt;li&gt;自动发送控制 RS485 串口应用通过 TXDEN 管脚&lt;/li&gt;
&lt;li&gt;操作模式设置和 USB 描述字符串设置在外部的 EEPROM 通过 USB 界面进行设置&lt;/li&gt;
&lt;li&gt;可设置的 I/O 驱动力（4, 8, 12 or 16mA）和摆动速度&lt;/li&gt;
&lt;li&gt;低工作功率和闲置功率&lt;/li&gt;
&lt;li&gt;支持自我供电，总线供电，高功率总线供电&lt;/li&gt;
&lt;li&gt;UHCI/OHCI/EHCI 主机控制器支持&lt;/li&gt;
&lt;li&gt;USB 块数据传输功能，一次传输 512 字节包（在高速传输模式下）。&lt;/li&gt;
&lt;li&gt;+1.8V 核心电压和 3.3V I/O 界面电压（耐压 5V）&lt;/li&gt;
&lt;li&gt;-40°C to 85°C 工业级工作范围&lt;/li&gt;
&lt;li&gt;紧凑 48 管脚无铅 LQFP 封装或 QFN 封装&lt;/li&gt;
&lt;li&gt;可设置的 ACBUS I/O 管脚&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading&#34;&gt;驱动设置&lt;/h3&gt;
&lt;p&gt;FT232H 需要一个 USB 驱动，有 VCP 和 D2XX 两种，VCP 会创建一个虚拟串口，允许串口操作应用操作，D2XX 则是使用 DLL 来直接操作 FT232H&lt;/p&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;模块图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-11-13-FT232H_1/FT232H_Block.png&#34; alt=&#34;FT232H block diagram&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;mpsse&#34;&gt;引脚图（MPSSE）&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;管脚号&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;管脚名称&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;MPSSE&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;13&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ADBUS0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TCK/SK&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;14&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ADBUS1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TDI/DO&lt;sup id=&#34;fnref:4&#34;&gt;&lt;a href=&#34;#fn:4&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;4&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;15&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ADBUS2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TDO/DI&lt;sup id=&#34;fnref:5&#34;&gt;&lt;a href=&#34;#fn:5&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;16&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ADBUS3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TMS/CS&lt;sup id=&#34;fnref:6&#34;&gt;&lt;a href=&#34;#fn:6&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;6&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;17&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ADBUS4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;GPIOL0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;18&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ADBUS5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;GPIOL1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;19&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ADBUS6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;GPIOL2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;20&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ADBUS7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;GPIOL3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;21&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ACBUS0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;GPIOH0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;25&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ACBUS1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;GPIOH1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;26&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ACBUS2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;GPIOH2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;27&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ACBUS3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;GPIOH3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;28&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ACBUS4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;GPIOH4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;29&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ACBUS5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;GPIOH5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;30&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ACBUS6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;GPIOH6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;31&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ACBUS7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;GPIOH7&lt;sup id=&#34;fnref:7&#34;&gt;&lt;a href=&#34;#fn:7&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;7&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ACBUS8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ACBUS8&lt;sup id=&#34;fnref:8&#34;&gt;&lt;a href=&#34;#fn:8&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;8&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;33&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ACBUS9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ACBUS9&lt;sup id=&#34;fnref:9&#34;&gt;&lt;a href=&#34;#fn:9&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;9&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;mpsse-&#34;&gt;MPSSE 简介&lt;/h3&gt;
&lt;p&gt;这个就是我想要的功能了，MPSSE 模式允许 FT232H 有效的和同步串口协议（JTAG, I2C, SPI(MASTER)）总线交互。&lt;/p&gt;
&lt;p&gt;MPSSE 是完全可设置的，设置需要通过沿着数据流发送命令。这些命令可以被单独发送或者打包成为数据包发送，MPSSE 最多支持数据速度为 30Mbits/s。&lt;/p&gt;
&lt;p&gt;注意在使用 MPSSE 模拟 SPI 总线的时候，FT232H 是处于主机模式状态下的。&lt;/p&gt;
&lt;p&gt;在产品介绍当中，FT232H 主要是作为 PC 端通过 USB 来下载代码或者下命令使用的，所以在软件的设计中，也主要是集中在 PC 端进行设计说明的，这在一定程度上给我们未来的软件开发带来了一定的便利。但是在硬件开发层面，可能会带来一定程度上的困难，因为我主要是将单片机作为数据输出的。&lt;/p&gt;
&lt;h4 id=&#34;mpsse--1&#34;&gt;MPSSE 波形图&lt;/h4&gt;
&lt;p&gt;MPSSE 的波形如下所示，这是一个同步串口通用波形，所以我们在设计的时候要针对协议进行波形控制。
&lt;img src=&#34;https://xiahualiu.github.io/img/2017-11-13-FT232H_1/MPSSE_Waveform.png&#34; alt=&#34;MPSSE_Waveform&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Min&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Typ&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Max&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Units&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Comments&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;t1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;15.15&lt;sup id=&#34;fnref:10&#34;&gt;&lt;a href=&#34;#fn:10&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;10&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;16.67&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ns&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CLKOUT 总周期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;t2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7.5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8.33&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9.17&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ns&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CLKOUT 高位时长&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;t3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7.5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8.33&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9.17&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ns&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CLKOUT 低位时长&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;t4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;7.15&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ns&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CLKOUT to TDI/DO 延迟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;t5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ns&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TDI/DO 维持时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;t6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;8.33&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;9.17&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ns&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TDI/DO 设置时间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;fine，我承认这个时序图完全没看懂，不管了，在下面有 MPSSE 对应协议的设置推荐，直接去看我想用的 SPI 章节。&lt;/p&gt;
&lt;h3 id=&#34;mpsse--2&#34;&gt;MPSSE 设置&lt;/h3&gt;
&lt;p&gt;所有的 MPSSE 命令或者是 GPIO 命令，都是通过 USB 总线从 PC 端发送到 FT 串口端。在这个过程中 &lt;strong&gt;必须使用 D2XX API&lt;/strong&gt;，并且所有的 MPSSE 命令都是通过读写命令实现的，并且应当注意需要的模块和驱动。&lt;/p&gt;
&lt;p&gt;请注意一旦硬件连接被建立，工程师必须决定如何设置 MPSSE 让其与目标硬件单位沟通，下列是需要设置的参数。&lt;/p&gt;
&lt;h4 id=&#34;msblsb--&#34;&gt;MSB/LSB 和 数据长度&lt;/h4&gt;
&lt;p&gt;请确定目标设备的 MSB/LSB 方向以及传输数据的长度。
MPSSE 命令运行在字节层面上，例如传输十进制 16 ，将会先发送一个 &lt;code&gt;0x00&lt;/code&gt; 字节，在发送 &lt;code&gt;0x01&lt;/code&gt; 字节（MSB）。但是也可以设置成为基于位的传输方式，以适应不适应字节传输的设备上。&lt;/p&gt;
&lt;h4 id=&#34;heading-2&#34;&gt;时钟&lt;/h4&gt;
&lt;p&gt;和数据传输方向一样，设定时钟是非常重要的。&lt;/p&gt;
&lt;h5 id=&#34;heading-3&#34;&gt;分频因子&lt;/h5&gt;
&lt;p&gt;$$Data Speed=\frac{60MHz}{((1+Divisor) \times 2)}$$&lt;/p&gt;
&lt;p&gt;FTx232H 的分频因子是一个从 &lt;code&gt;0x0000&lt;/code&gt; 到 &lt;code&gt;0xFFFF&lt;/code&gt; 的数，也就是说数据的的速度从 30MHz 到 460Hz 之间。并且在 FTx232H 上有一个 5 的分频系数选项以维持稳定性。当开启的时候，将上式中的 &lt;code&gt;60MHz&lt;/code&gt; 更换为 &lt;code&gt;12MHz&lt;/code&gt; 即可。&lt;/p&gt;
&lt;h5 id=&#34;heading-4&#34;&gt;沿设置&lt;/h5&gt;
&lt;p&gt;数据在默认情况下是在时钟的边沿进行读取和更改的，所以沿设置是必须的。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;传输时钟沿&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;接收时钟沿&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;空闲时钟状态&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Rising&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Rising&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Not Valid&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Rising&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Falling&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Low&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Falling&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Rising&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Falling&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Falling&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Not Valid&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Rising&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;No data transfer&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Low&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Falling&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;No data transfer&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;No data transfer&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Rising&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Low&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;No data transfer&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;Falling&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;High&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;heading-5&#34;&gt;杂项&lt;/h4&gt;
&lt;h5 id=&#34;heading-6&#34;&gt;初始管脚状态&lt;/h5&gt;
&lt;p&gt;设定初始的时钟状态：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;初始 SK 状态&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;产生的时钟脉冲&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;低&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;低-高-低&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;高&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;高-低-高&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在发送和接受任何数据前，四个 MPSSE 管脚和 GPIO 管脚都应该设置为正确的数据方向，如果是输出状态，则应该设置其初始状态。&lt;/p&gt;
&lt;h5 id=&#34;buffer-sizes&#34;&gt;Buffer Sizes&lt;/h5&gt;
&lt;p&gt;MPSSE 数据和命令都混合在一个单独的 Buffer 下，多命令可以被送到 MPSSE 通过简单的调用 &lt;code&gt;FT_Write&lt;/code&gt;，在这个过程中应用缓存必须有充足的大小才能一次性处理多命令和数据。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;数据类型&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;数据长度（bytes）&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Command&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Data length&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Data payload&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;1 到 65536&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;Total&lt;/strong&gt;&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;&lt;strong&gt;4 到 65539&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上表为 Buffer 分配制度。&lt;/p&gt;
&lt;h3 id=&#34;mpsse--3&#34;&gt;MPSSE 软件设置&lt;/h3&gt;
&lt;p&gt;所有的 MPSSE 交流都是通过 FTDI D2XX API 实现的，其官方手册如下 &lt;a href=&#34;http://www.ftdichip.com/Support/Documents/ProgramGuides/D2XX_Programmer&#39;s_Guide(FT_000071).pdf&#34;&gt;FTDI D2XX Programmer’s Guide&lt;/a&gt;，实现的必须步骤如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-11-13-FT232H_1/MPSSE_Flow_Chart.png&#34; alt=&#34;MPSSE_Flow_Chart&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;heading-7&#34;&gt;确认设备连接并打开处理&lt;/h4&gt;
&lt;p&gt;在使用 MPSSE 前，应用程序需要了解有多少 FT 系列设备被连接在了主机系统上，并且选择其中正确的一个。这个过程是通过 D2XX API 调用实现的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;FT_CreateDeviceInfoList&lt;/code&gt; 这个调用返回可用的 FT 系列设备数量，&lt;strong&gt;重要&lt;/strong&gt;：多端口的设备的每个端口都会被统计到这个数值内。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FT_GetDeviceInfoList&lt;/code&gt; 或者 &lt;code&gt;FT_GetDeviceInfoListDetail&lt;/code&gt; 取决于使用方法，这个调用返回每个可用设备的信息，例如设备名称，端口名（例如 “FT2232H A” 或 “FT2232H B”），对应的 USB 地址 ID，USB 串口序号，还有最重要的 &lt;strong&gt;USB Handle&lt;/strong&gt; 值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FT_Open&lt;/code&gt; 或 &lt;code&gt;FT_OpenEx&lt;/code&gt; 一旦端口信息被确定，下一步则可以打开端口，基于端口对应的 &lt;strong&gt;USB Handle&lt;/strong&gt; 值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;-ftdi--mpsse-&#34;&gt;设置 FTDI 端口为 MPSSE 功能&lt;/h4&gt;
&lt;p&gt;在打开端口后，一些参数需要被设置才能够正式打开 MPSSE，这个步骤包括以下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;FT_ResetDevice&lt;/code&gt; 重置 FTDI 外围端口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FT_SetUSBParameters&lt;/code&gt; 设置最大的 USB 传输字节，这个值可以被设置成为 64 bytes 到 64 Kbytes，取决于需要传输的数据总量，输入和输出的大小可以分别设置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FT_SetChars&lt;/code&gt; 设置事件和错误码，大多数应用会禁用事件和错误代码。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FT_SetTimeouts&lt;/code&gt; 设置读取和写入的超时时间（毫秒），超时选项在默认状态下是禁用的，这个选项主要是给驱动一个突破错误传输的手段。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FT_SetLatencyTimer&lt;/code&gt; 这个设置在发送一个不完全的 USB 数据包前的等待时间，如果需要的快速反应，请将此值设置成为较小的值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FT_SetFlowControl&lt;/code&gt; 设置 RTS/CTS 流控制以确认驱动不会响应 IN 请求如果 buffer 无法接受数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FT_SetBitMode&lt;/code&gt; 设置 &lt;code&gt;mode = 0, mask = 0&lt;/code&gt; 以重置 MPSSE 控制器，但不会给端口重置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FT_SetBitMode&lt;/code&gt; 设置 &lt;code&gt;mode = 2, mask = 0&lt;/code&gt; 启用 MPSSE 控制器，引脚方向会在接下来的 MPSSE 命令中设置。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;-mpsse&#34;&gt;设置 MPSSE&lt;/h4&gt;
&lt;p&gt;在这个状态下，MPSSE 已经可以接受命令了，MPSSE 命令包含一个 op-code 和一到多个参数，参数已经被 &lt;a href=&#34;http://www.ftdichip.com/Support/Documents/ProgramGuides/D2XX_Programmer&#39;s_Guide(FT_000071).pdf&#34;&gt;FTDI D2XX Programmer’s Guide&lt;/a&gt; 中定义了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FT_Write&lt;/code&gt; 用于向 MPSSE 发送命令，反馈则使用 &lt;code&gt;FT_Read&lt;/code&gt; 读取。&lt;/p&gt;
&lt;h5 id=&#34;heading-8&#34;&gt;同步和坏命令侦测&lt;/h5&gt;
&lt;p&gt;如果有一个坏命令被侦测到，MPSSE 将会返回 &lt;code&gt;0xFA&lt;/code&gt; 同时跟着错误字节。&lt;/p&gt;
&lt;p&gt;使用坏命令侦测是决定 MPSSE 是否和应用同步的推荐方法，通过故意发送一个坏命令，等待 &lt;code&gt;0xFA&lt;/code&gt; 应用可以确定与 MPSSE 之间的沟通是否有效。&lt;/p&gt;
&lt;h5 id=&#34;mpsse--4&#34;&gt;MPSSE 建立&lt;/h5&gt;
&lt;p&gt;通过连接建立，MPSSE 必须设置时钟速度，管脚方向和初始管脚状态。FTx232H 有一个额外的参数是 5 分频器，3 相时钟和 JTAG 适应性时钟。虽然默认的设置可能对特定应用有效，但是发送 op-code 设置所有的特性会让程序更可靠。&lt;/p&gt;
&lt;h4 id=&#34;heading-9&#34;&gt;串口交流&lt;/h4&gt;
&lt;p&gt;一旦所有的参数被设置后，与外围的沟通有可能会发生，MPSSE 为了诊断连接目的可以被设置为 loop-back 模式，数据会被传输到 DO 管脚，同时也会被传输到 DI 管脚。&lt;/p&gt;
&lt;p&gt;在正常模式和回送模式下，一共有 32 种 数据的发送和接收选择，选择的 op-codee 决定于以下的选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MSB 或者是 LSB 传输，注意这个是字节的传输顺序，如果数据长于 8-bits，则需要注意每个字节在 buffer 中的存放顺序是否正确。&lt;/li&gt;
&lt;li&gt;只发送数据、只接收数据、既接收又发送数据。&lt;/li&gt;
&lt;li&gt;发送数据沿，接收数据沿&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 &lt;code&gt;FT_Write&lt;/code&gt; 发送命令到 Buffer 中需要跟随 &lt;code&gt;FT_GetStatus&lt;/code&gt; 和 &lt;code&gt;FT_Read&lt;/code&gt; 去读取外围的反馈信息。&lt;/p&gt;
&lt;h4 id=&#34;gpio-&#34;&gt;GPIO 访问&lt;/h4&gt;
&lt;p&gt;每个带有 MPSSE 的 FTDI 芯片都有一些管脚可以用于通用目的输入或者输出。在串口通信的时候，&lt;code&gt;FT_Write&lt;/code&gt; 用于设置方向和输出值使 MPSSE 返回真实的管脚状态。在对 MPSSE 使用 &lt;code&gt;read GPIO&lt;/code&gt; 命令后，&lt;code&gt;FT_Read&lt;/code&gt; 将会取回包含引脚状态的数据。&lt;/p&gt;
&lt;h4 id=&#34;heading-10&#34;&gt;关闭处理程序&lt;/h4&gt;
&lt;p&gt;当应用完成与外围的沟通的时候，处理程序必须被正确关闭。虽然不是额外的需要，但是重启 MPSSE 并将管脚置为空闲状态是一个推荐的选择。&lt;/p&gt;
&lt;h4 id=&#34;heading-11&#34;&gt;例程&lt;/h4&gt;
&lt;h5 id=&#34;heading-12&#34;&gt;第一段设置了一些变量用于以后使用&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;_tmain&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; argc, _TCHAR&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; argv[])
{
&lt;span style=&#34;color:#75715e&#34;&gt;// -----------------------------------------------------------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Variables
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// -----------------------------------------------------------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;FT_HANDLE ftHandle; &lt;span style=&#34;color:#75715e&#34;&gt;/* FTDI device 处理对象 */&lt;/span&gt;
FT_STATUS ftStatus; &lt;span style=&#34;color:#75715e&#34;&gt;/* 每个 D2XX 调用的结果 */&lt;/span&gt;
DWORD dwNumDevs; &lt;span style=&#34;color:#75715e&#34;&gt;/* 设备数量 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;unsigned&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; uiDevIndex &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xF&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 要用到的设备索引 */&lt;/span&gt;
BYTE byOutputBuffer[&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;/* MPSSE 命令和数据缓存（发送） */&lt;/span&gt;
BYTE byInputBuffer[&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;/* MPSSE 命令和数据缓存（接收） */&lt;/span&gt;
DWORD dwCount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 循环计数 */&lt;/span&gt;
DWORD dwNumBytesToSend &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 输出缓存索引 */&lt;/span&gt;
DWORD dwNumBytesSent &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* FT_Write 实际输出字节统计 */&lt;/span&gt;
DWORD dwNumBytesToRead &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 目前接收缓存中的字节 */&lt;/span&gt;
DWORD dwNumBytesRead &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* FT_Read 实际读取的字节统计 */&lt;/span&gt;
DWORD dwClockDivisor &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x05DB&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 时钟分频因子, SCL Frequency = 60/((1+0x05DB)*2) (MHz) = 1Mhz */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;heading-13&#34;&gt;确认设备存在并打开处理&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// -----------------------------------------------------------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Does an FTDI device exist?
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// -----------------------------------------------------------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Checking for FTDI devices...&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_CreateDeviceInfoList(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumDevs);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 取得 FTDI 设备数量 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_OK) &lt;span style=&#34;color:#75715e&#34;&gt;/* 命令是否正确执行 */&lt;/span&gt;
{
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Error in getting the number of devices&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 错误退出 */&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (dwNumDevs &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;/* 如果无设备则退出 */&lt;/span&gt;
{
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;There are no FTDI devices installed&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 错误退出 */&lt;/span&gt;
}
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;%d FTDI devices found &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;- the count includes individual ports on a single chip&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, dwNumDevs);
&lt;span style=&#34;color:#75715e&#34;&gt;// -----------------------------------------------------------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 打开端口 - 这个应用默认第一个设备是 FTx232H 设备
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 在打开端口前，可以检查设备的描述，地点，串口号，等等
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// -----------------------------------------------------------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Assume first device has the MPSSE and open it...&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_Open(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;ftHandle);
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_OK)
{
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Open Failed with error %d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, ftStatus);
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 错误退出 */&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;-ftdi--mpsse&#34;&gt;设置 FTDI 端口为 MPSSE&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* 设置端口参数 */&lt;/span&gt;
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Configuring port for MPSSE use...&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_ResetDevice(ftHandle);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 重置 USB 端口 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 首先通过读取 FT232H 接收缓存，清空 USB 接收缓存 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_GetQueueStatus(ftHandle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesToRead);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 读取接收缓存中的字节数 */&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_OK) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; (dwNumBytesToRead &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;))
FT_Read(ftHandle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;byInputBuffer, dwNumBytesToRead, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesRead);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 读取所有的 FT232H 接收缓存 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_SetUSBParameters(ftHandle, &lt;span style=&#34;color:#ae81ff&#34;&gt;65536&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;65535&lt;/span&gt;);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 设置 USB 请求发送大小为 64KB */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_SetChars(ftHandle, false, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, false, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 关闭错误事件码 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_SetTimeouts(ftHandle, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;5000&lt;/span&gt;);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 设置读取和写入超时时长 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_SetLatencyTimer(ftHandle, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 设置发送延时为 1ms */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_SetFlowControl(ftHandle, FT_FLOW_RTS_CTS, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 开启流控制以同步 IN 请求 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_SetBitMode(ftHandle, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 重置 MPSSE 控制器 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_SetBitMode(ftHandle, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x02&lt;/span&gt;);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 开启 MPSSE 控制器 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_OK)
{
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Error in initializing the MPSSE %d&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, ftStatus);
FT_Close(ftHandle);
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 错误退出 */&lt;/span&gt;
}
Sleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;50&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* 等待 USB 完成设置并准备工作 */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;： D2XX 中 &lt;code&gt;ftStatus&lt;/code&gt; 的返回值可以在上述所有的 API 调用完成后当做总检查。所以在接下来的例程中，&lt;code&gt;ftStatus&lt;/code&gt; 不会在每个调用任务后都被检查，请注意。&lt;/p&gt;
&lt;h5 id=&#34;-mpsse-1&#34;&gt;设置 MPSSE&lt;/h5&gt;
&lt;p&gt;在这个状态下 MPSSE 已经可以接受命令了，每个命令包含一个 co-code 紧跟着一些必须的参数或者数据。为了使程序清晰明了，每个命令都必须独自使用一个 &lt;code&gt;FT_Write&lt;/code&gt; 调用。在实际使用中，有时候需要将多个命令合并并使用一个 &lt;code&gt;FT_Write&lt;/code&gt; 调用。&lt;/p&gt;
&lt;h6 id=&#34;heading-14&#34;&gt;同步和坏命令检测&lt;/h6&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* 内部回环连接测试 */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x84&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 开启回环连接 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_Write(ftHandle, byOutputBuffer, \
dwNumBytesToSend, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesSent);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 发送回环命令 */&lt;/span&gt;
dwNumBytesToSend &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 重置输出缓存指针 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 检查接收缓存，应该是空 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_GetQueueStatus(ftHandle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesToRead);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 取得接收缓存的字节数 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (dwNumBytesToRead &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
{
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Error - MPSSE receive buffer should be empty&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, ftStatus);
FT_SetBitMode(ftHandle, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 重置端口以关闭 MPSSE */&lt;/span&gt;
FT_Close(ftHandle); &lt;span style=&#34;color:#75715e&#34;&gt;/* 关闭 USB 端口 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 错误退出 */&lt;/span&gt;
}
&lt;span style=&#34;color:#75715e&#34;&gt;// -----------------------------------------------------------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 同步 MPSSE 通过发送一个假 op-code 字节 (0xAB),
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// MPSSE 将会相应 &amp;#34;坏命令&amp;#34; (0xFA) 
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 和对应的 op-code 本身发送到应用上。
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// -----------------------------------------------------------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xAB&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 增加假 op-code 字节 (0xAB) 到队列中 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesSent);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 发送假字节 */&lt;/span&gt;
dwNumBytesToSend &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 重置输出缓存指针 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt;
{
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_GetQueueStatus(ftHandle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesToRead);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 得到接收缓存中的字节数 */&lt;/span&gt;
} &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; ((dwNumBytesToRead &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; (ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_OK));
&lt;span style=&#34;color:#75715e&#34;&gt;/* 超时跳出 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt; bCommandEchod &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; false;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_Read(ftHandle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;byInputBuffer, dwNumBytesToRead, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesRead);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 从输入缓存中读取相应数量字节 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (dwCount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; dwCount &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; dwNumBytesRead &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; dwCount&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;)
&lt;span style=&#34;color:#75715e&#34;&gt;/* 检查是否有坏命令信息 */&lt;/span&gt;
{
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((byInputBuffer[dwCount] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xFA&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; (byInputBuffer[dwCount&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xAB&lt;/span&gt;))
{
bCommandEchod &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; true;
&lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
}
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (bCommandEchod &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; false)
{
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Error in synchronizing the MPSSE&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
FT_Close(ftHandle);
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 错误退出 */&lt;/span&gt;
}

&lt;span style=&#34;color:#75715e&#34;&gt;/* 关闭内部回环连接 */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x85&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 关闭回环命令写入缓存 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_Write(ftHandle, byOutputBuffer,\
dwNumBytesToSend, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesSent);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 发送关闭回环命令 */&lt;/span&gt;
dwNumBytesToSend &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 重置输出缓存指针 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 检查输出缓存是否有字节 - 应当没有 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_GetQueueStatus(ftHandle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesToRead);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 取得接收缓存中的字节数 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (dwNumBytesToRead &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
{
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Error - MPSSE receive buffer should be empty&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, ftStatus);
FT_SetBitMode(ftHandle, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 重置 MPSSE 以关闭端口 */&lt;/span&gt;
FT_Close(ftHandle); &lt;span style=&#34;color:#75715e&#34;&gt;/* 关闭 USB 端口 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 错误退出 */&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h6 id=&#34;mpsse--5&#34;&gt;MPSSE 建立&lt;/h6&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// -----------------------------------------------------------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 设置 MPSSE 为 JTAG
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 可以在一个 FT_Write 中发送多个指令
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// -----------------------------------------------------------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;dwNumBytesToSend &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 开启一个新的发送索引数 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 设置高速模式的 FTx232H */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x8A&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 使用 60MHz 时钟主频 - 关闭 5 分频器 */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x97&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 关闭适应性时钟(可能对于 ARM 芯片需要开启) */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x8D&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 关闭三相时钟 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesSent);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 发送以上的命令 */&lt;/span&gt;
dwNumBytesToSend &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 重置输出缓存指针 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 设置分频因子 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* TCK = 60MHz /((1 + [(1 +0xValueH*256) OR 0xValueL])*2) */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;\x86&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 设置时钟分频因子的指令 */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dwClockDivisor &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xFF&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 设置 0xValueL 的分频因子 */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (dwClockDivisor &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xFF&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 设置 0xValueH 的分频因子 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesSent);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 发送以上的分频因子设置指令 */&lt;/span&gt;
dwNumBytesToSend &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 重置输出缓存指针 */&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;// 初始化 MPSSE 界面 - P1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// - 低字节, 对应管脚方向和输出值
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Pin name Signal Direction Config Initial State Config
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ADBUS0   TCK/SK output    1      high          1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ADBUS1   TDI/DO output    1      low           0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ADBUS2   TDO/DI input     0                    0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ADBUS3   TMS/CS output    1      high          1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ADBUS4   GPIOL0 output    1      low           0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ADBUS5   GPIOL1 output    1      low           0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ADBUS6   GPIOL2 output    1      high          1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ADBUS7   GPIOL3 output    1      high          1
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x80&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 设置 MPSSE 管脚低字节 */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xC9&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 设置上表的 Initial State 初始状态 */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xFB&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 设置上表的 Direction 方向 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesSent);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 发送上述命令 */&lt;/span&gt;
dwNumBytesToSend &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 重置输出缓存指针 */&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;/* 请注意数据在下述部分将会在上升沿震荡 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 初始时钟状态为高 - 时钟信号为 高-低-高 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 举个例子，在这个程序中，信息在上升沿改变，为了给其足够的时间让其有效，所以会在下降沿接收数据 */&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;// 初始化 MPSSE 界面 - P2
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// - 高字节, 对应管脚方向和输出值
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Pin name Signal Direction Config Initial State Config
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ACBUS0   GPIOH0 input     0      0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ACBUS1   GPIOH1 input     0      0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ACBUS2   GPIOH2 input     0      0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ACBUS3   GPIOH3 input     0      0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ACBUS4   GPIOH4 input     0      0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ACBUS5   GPIOH5 input     0      0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ACBUS6   GPIOH6 input     0      0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ACBUS7   GPIOH7 input     0      0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x82&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 设置 MPSSE 管脚高字节 */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 设置上表的 Initial State 初始状态 */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 设置上表的 Direction 方向 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesSent);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 发送上述命令 */&lt;/span&gt;
dwNumBytesToSend &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 重置输出缓存指针 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(dwCount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; dwCount &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;; dwCount&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;)
{ &lt;span style=&#34;color:#75715e&#34;&gt;/* 清空输入和输出缓存 */&lt;/span&gt;
byInputBuffer[dwCount] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;;
byOutputBuffer[dwCount] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;heading-15&#34;&gt;串口交流程序&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* 数据只发送不接收 */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x10&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 输出在上升沿，不输入，MSB 首先发送 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 时钟在发送后空闲（高） */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x01&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 字节长度 - 低字节 */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 字节长度 - 高字节 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 字节长度 = 0x0001+1 = 2 bytes */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xA5&lt;/span&gt;;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0F&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 数据 = 0xA50F */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesSent);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 数据发射 */&lt;/span&gt;
dwNumBytesToSend &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 重置输出缓存指针 */&lt;/span&gt;
Sleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* 等待发送完毕 检查状态 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 数据包发送延时 1ms 故此处要等待大于 1ms */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 检查输出缓存是否有字节 - 应当没有 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_GetQueueStatus(ftHandle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesToRead);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 检查接收缓存是否有字节 - 应当没有 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 本段程序第一句设置为数据只发送不接收 */&lt;/span&gt;
FT_Read(ftHandle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;byInputBuffer, dwNumBytesToRead, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesRead);
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (dwNumBytesToRead &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
{
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Error - MPSSE receive buffer should be empty&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, ftStatus);
FT_SetBitMode(ftHandle, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 重置 MPSSE 以关闭端口 */&lt;/span&gt;
FT_Close(ftHandle); &lt;span style=&#34;color:#75715e&#34;&gt;/* 关闭 USB 端口 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 错误退出 */&lt;/span&gt;
}

&lt;span style=&#34;color:#75715e&#34;&gt;/* 继续 */&lt;/span&gt;

printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Press &amp;lt;Enter&amp;gt; to continue&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
getchar(); &lt;span style=&#34;color:#75715e&#34;&gt;/* 捕获一个字符输入 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 更改发送设置，重复发送过程 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 既发送数据，又接收数据 */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x34&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 输出在上升沿，输入在下降沿 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* MSB 首先发送，时钟在发送后空闲（高） */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x01&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 字节长度 - 低字节 */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 字节长度 - 高字节 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 字节长度 = 0x0001+1 = 2 bytes */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xA5&lt;/span&gt;;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0F&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 数据 = 0xA50F */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesSent);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 发射数据 */&lt;/span&gt;
dwNumBytesToSend &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 重置输出缓存指针 */&lt;/span&gt;
Sleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* 等待发送完毕 检查状态 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 数据包发送延时 1ms 故此处要等待大于 1ms */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 检查输出缓存是否有字节 - 应当有 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_GetQueueStatus(ftHandle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesToRead);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 检查接收缓存是否有字节 - 应当有两个 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 因为目前是回环状态 */&lt;/span&gt;
FT_Read(ftHandle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;byInputBuffer, dwNumBytesToRead, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesRead);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 应当有两个 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (dwNumBytesToRead &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;)
{
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Error - MPSSE receive buffer should have the looped-back data&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
FT_SetBitMode(ftHandle, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 重置 MPSSE 以关闭端口 */&lt;/span&gt;
FT_Close(ftHandle); &lt;span style=&#34;color:#75715e&#34;&gt;/* 关闭 USB 端口 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 错误退出 */&lt;/span&gt;
}
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;The correct number of bytes have been received&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 检查发送与接收数据是否一致 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(dwCount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; dwCount &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dwNumBytesRead &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; dwCount&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;)
{
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (byInputBuffer[dwCount] &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; byOutputBuffer[dwCount &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;])
&lt;span style=&#34;color:#75715e&#34;&gt;/* 输出数组从索引 3 后开始才是数据 */&lt;/span&gt;

{
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Error - Data received does not match data output&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
FT_SetBitMode(ftHandle, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 重置 MPSSE 以关闭端口 */&lt;/span&gt;
FT_Close(ftHandle); &lt;span style=&#34;color:#75715e&#34;&gt;/* 关闭 USB 端口 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 错误退出 */&lt;/span&gt;
}
}
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;The input data matches the output data&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);

&lt;span style=&#34;color:#75715e&#34;&gt;/* 继续 */&lt;/span&gt;

printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Press &amp;lt;Enter&amp;gt; to continue&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
getchar(); &lt;span style=&#34;color:#75715e&#34;&gt;/* 捕获一个字符输入 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(dwCount &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; dwCount &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;; dwCount&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;)
{ &lt;span style=&#34;color:#75715e&#34;&gt;/* 清空输入和输出数组 */&lt;/span&gt;
byInputBuffer[dwCount] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;;
byOutputBuffer[dwCount] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;gpio--1&#34;&gt;GPIO 例程&lt;/h4&gt;
&lt;p&gt;有些 FTDI MPSSE 管脚不是专用管脚，这些管脚可以用于 GPIO。这些管脚可以作为 SPI 通信中的片选信号，置位或者清零这些管脚的方法也很流行。如果每个命令单独使用 &lt;code&gt;FT_Write&lt;/code&gt; 来控制 GPIO，GPIO 的速度将会受到很大的限制（由于发送延时的存在），以下例程展示了如何在一个 &lt;code&gt;FT_Write&lt;/code&gt; 中发送多个命令。片选信号被发送有效位（低），接着发送数据流，最后片选信号发送无效位（高）。&lt;/p&gt;
&lt;p&gt;下列代码展示了一个简单的 &lt;strong&gt;读-修改-写&lt;/strong&gt; 的序列，以确保每个 GPIO 位完整有效。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Read From GPIO low byte
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// *************************************************
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Change scope trigger to channel 4 (TMS/CS) falling edge
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;//
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// *************************************************
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x81&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 接收位数据 - 返回状态值 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 既返回输入也返回输出 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 低字节的 GPIO */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesSent);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 读取 GPIO 低位字节 */&lt;/span&gt;
dwNumBytesToSend &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 重置输出缓存指针 */&lt;/span&gt;
Sleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* 等待发送完毕 检查状态 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 数据包发送延时 1ms 故此处要等待大于 1ms */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 检查输出缓存是否有字节 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_GetQueueStatus(ftHandle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesToRead);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 得到 FTx232H 的接收缓存字节数 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_Read(ftHandle, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;byInputBuffer, dwNumBytesToRead, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesRead);
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ((ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_OK) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; (dwNumBytesToRead &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;))
{
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Error - GPIO cannot be read&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
FT_SetBitMode(ftHandle, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 重置 MPSSE 以关闭端口 */&lt;/span&gt;
FT_Close(ftHandle); &lt;span style=&#34;color:#75715e&#34;&gt;/* 关闭 USB 端口 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 错误退出 */&lt;/span&gt;
}
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;The GPIO low-byte = 0x%X&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, byInputBuffer[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 输入应当只有一个字节 */&lt;/span&gt;
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Press &amp;lt;Enter&amp;gt; to continue&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
getchar(); &lt;span style=&#34;color:#75715e&#34;&gt;/* 捕获一个字符输入 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 修改 GPIO 字节并发送 */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x80&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 修改 GPIO 低位字节 */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; byInputBuffer[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xF7&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 仅仅将片选信号置 0 */&lt;/span&gt;
byOutputBuffer[dwNumBytesToSend&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xFB&lt;/span&gt;;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 仍然需要写入 GPIO 方向 */&lt;/span&gt;
ftStatus &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; FT_Write(ftHandle, byOutputBuffer, dwNumBytesToSend, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;dwNumBytesSent);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 发射数据 */&lt;/span&gt;
dwNumBytesToSend &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// Reset output buffer pointer
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;Sleep(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* 等待发送完毕 检查状态 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 数据包发送延时 1ms 故此处要等待大于 1ms */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 检查输出缓存是否有字节 */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;heading-16&#34;&gt;关闭处理程序&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// -----------------------------------------------------------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Start closing everything down
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// -----------------------------------------------------------
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;AN_135 example program executed successfully.&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
printf(&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Press &amp;lt;Enter&amp;gt; to continue&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;);
getchar(); &lt;span style=&#34;color:#75715e&#34;&gt;/* 捕获一个字符输入 */&lt;/span&gt;
FT_SetBitMode(ftHandle, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00&lt;/span&gt;);
&lt;span style=&#34;color:#75715e&#34;&gt;/* 重置 MPSSE 以关闭端口 */&lt;/span&gt;
FT_Close(ftHandle); &lt;span style=&#34;color:#75715e&#34;&gt;/* 关闭 USB 端口 */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* 成功退出 */&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;以上就是 FT232H 中的 MPSSE 简单使用方法。&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;指校验位始终为 1 的校验方式。 &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;指校验位始终为 0 的校验方式。 &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Clock Signal Output. &lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:4&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Serial Data Output. &lt;a href=&#34;#fnref:4&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:5&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Serial Data Input. &lt;a href=&#34;#fnref:5&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:6&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;Output Signal Select. &lt;a href=&#34;#fnref:6&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:7&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;此 GPIO 管脚内部有一个约为 75KΩ 的下拉电阻连接到地，如果使用 EEPROM 此管脚可被设置成为 USBVCC 模式而不是 GPIO 模式。 &lt;a href=&#34;#fnref:7&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:8&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;此管脚默认为三态输入，内部有一个约为 75KΩ 的上拉电阻连接到 VCCIO。 &lt;a href=&#34;#fnref:8&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:9&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;此管脚默认为三态输入，内部有一个约为 75KΩ 的上拉电阻连接到 VCCIO。 &lt;a href=&#34;#fnref:9&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:10&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;在官方文档中这个值是在 t1 的 Max 栏下的，我认为是 typo 将其归类在了 Min 栏下。 &lt;a href=&#34;#fnref:10&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
    </item>
    <item>
      <title>S32K144EVB Notes 8 Systick</title>
      <link>https://xiahualiu.github.io/posts/2017-10-26-s32k144_8/</link>
      <pubDate>Thu, 26 Oct 2017 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2017-10-26-s32k144_8/</guid>
      <description>&lt;p&gt;本章的内容是关于 Cortex M4F 内核中的 SysTick 时钟的运用，这是一个非常有用的模块，可以实现高精度的延时和快速中断的功能，但是这个内核功能在 MCU OEM 厂商的 Reference Manual 中一般都没有给出具体的实现方法，今天我们针对内核来进行分析。&lt;/p&gt;
&lt;p&gt;SysTick 在参考手册中提到的就是有关中断优先级的那一章，SysTick 类似于 LPIT 计时器，但是直接使用的是内核的时钟进行计数，中断优先级在内核中是最低的，但是相对于外围是高的。这个模块的使用主要集中在 4 个寄存器内。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/** S32_SysTick - Register Layout Typedef */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
  __IO uint32_t CSR;                               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; SysTick Control and Status Register, offset: 0x0 */&lt;/span&gt;
  __IO uint32_t RVR;                               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; SysTick Reload Value Register, offset: 0x4 */&lt;/span&gt;
  __IO uint32_t CVR;                               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; SysTick Current Value Register, offset: 0x8 */&lt;/span&gt;
  __I  uint32_t CALIB;                             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; SysTick Calibration Value Register, offset: 0xC */&lt;/span&gt;
} S32_SysTick_Type, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;S32_SysTick_MemMapPtr;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是 4 个 32 位的寄存器。&lt;/p&gt;
&lt;h3 id=&#34;systick-control-and-status-register-systick-csr&#34;&gt;SysTick Control and Status Register (SysTick_CSR)&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;16&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;COUNTFLAG&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;SysTick 计数比较标志&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;如果在上次读取本寄存器后，SysTick 已经数到了0，则该位为1&lt;!-- raw HTML omitted --&gt;如果读取该位，该位将自动清零&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CLKSOURCE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;SysTick 时钟源选择&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;0 选择内核时钟&lt;!-- raw HTML omitted --&gt;1 选择内核时钟&lt;!-- raw HTML omitted --&gt;震惊不，事实就是这样&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TICKINT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;SysTick 中断使能位&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;0 禁用&lt;!-- raw HTML omitted --&gt;1 开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ENABLE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;SysTick 使能位&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;0 关闭 SysTick&lt;!-- raw HTML omitted --&gt;1 开启 SysTick&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;systick-reload-value-register-systick-rvr&#34;&gt;SysTick Reload Value Register (SysTick_RVR)&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;23-0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RELOAD&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;SysTick 重载寄存器&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;如果 SysTick 已经数到了0&lt;!-- raw HTML omitted --&gt;则重新装载进此寄存器的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;systick-current-value-register-systick-cvr&#34;&gt;SysTick Current Value Register (SysTick_CVR)&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;23-0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CURRENT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;SysTick 当前值寄存器&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;读取时返回当前计数值并将其清零&lt;!-- raw HTML omitted --&gt;同时清除 COUNTFLAG&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;systick-calibration-value-register-systick-calib&#34;&gt;SysTick Calibration Value Register (SysTick_CALIB)&lt;/h3&gt;
&lt;p&gt;校准寄存器，不知道咋用。好像在使用说明中说了这一部分的值必须取全 0。&lt;/p&gt;
&lt;p&gt;我们现在来讲解这个东西究竟怎么用啊，从上面的描述我们可以知道这就是一个内核层面的计时器，可以触发中断，我们可以声明一个全局变量作为计数值，在延时子程序中给这个变量传递一个值然后循环判断此值是否为 1，然后在中断服务程序中每次触发就将此值减一就可以做到精确延时的功能。&lt;/p&gt;
&lt;p&gt;我写一下我自己写的延时程序，已经验证能够使用。使用方法就是 &lt;code&gt;include&lt;/code&gt; 你自己写的头文件然后使用 &lt;code&gt;delay_ms()&lt;/code&gt; 即可。&lt;em&gt;头文件怎么写不用教吧&amp;hellip;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* delay.c              Eggycat
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Description:  Use SysTick function to perform millisecond-level (us-level also if you like) delay in S32K144 Landzo-FRDM
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * 2017 10 25 initial version
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;S32K144.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;delay.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
uint32_t Systok &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// declare Systok as an extern parameter
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; idle_counter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SysTick_init&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;){ &lt;span style=&#34;color:#75715e&#34;&gt;// clock frequency=80MHz,
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// configure NVIC register
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    S32_NVIC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;ICPR[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* IRQ-1-SysTick: clr any pending IRQ*/&lt;/span&gt;
    S32_NVIC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;ISER[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;31&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* IRQ-1-SysTick: enable IRQ */&lt;/span&gt;
    S32_NVIC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;IP[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x0A&lt;/span&gt;;

    S32_SysTick&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;RVR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;80000&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// Reload 80000 = 1ms if you want a us change this value to 80.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    S32_SysTick&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CVR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// Initialize Current Value Register for a new reload on enable.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;delay_ms&lt;/span&gt;(uint32_t i){ &lt;span style=&#34;color:#75715e&#34;&gt;// delay_ms(time)
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    Systok &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i;
    S32_SysTick&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CSR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// TICKINT=1 enable SysTick interrupt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                        &lt;span style=&#34;color:#75715e&#34;&gt;// Enable=1 enable SysTick;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;                        &lt;span style=&#34;color:#75715e&#34;&gt;// CLKSOURCE=1 SysTick clock rate=80MHz=10MHz
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(Systok&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;){    &lt;span style=&#34;color:#75715e&#34;&gt;// Loop till Systok=0
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;        idle_counter&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;; 
    }
    S32_SysTick&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CSR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;// Disable SysTick interrupt.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    idle_counter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; S32_SysTick&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CVR; &lt;span style=&#34;color:#75715e&#34;&gt;// Any reads from CVR clear both COUNTFLAG &amp;amp; CVR
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SysTick_Handler&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;){
    idle_counter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; S32_SysTick&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CVR; &lt;span style=&#34;color:#75715e&#34;&gt;// Any reads from CVR clear both COUNTFLAG &amp;amp; CVR
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;    Systok&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>S32K144EVB Notes 7 SPI</title>
      <link>https://xiahualiu.github.io/posts/2017-10-20-s32k144_7/</link>
      <pubDate>Fri, 20 Oct 2017 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2017-10-20-s32k144_7/</guid>
      <description>&lt;p&gt;本节针对了我在工程上需要亟待着手解决的一个方面也就是使用外接 SPI 网卡进行高速传输的一个问题，在这里打算进行仔细的解读一下有关 SPI 协议使用的部分。但是还是老样子，我们根据例程进行分析相关的寄存器和使用方法。&lt;/p&gt;
&lt;p&gt;本例程来自 NXP 官方给出的 AN5413 Cookbook 上面的程序。&lt;/p&gt;
&lt;h3 id=&#34;heading&#34;&gt;介绍&lt;/h3&gt;
&lt;p&gt;这是一个简单的 LPSPI 程序在执行过程中使用了 FIFO 可以有效提高吞吐量。经过初始化，一个 16-bit 的帧将会以 1Mbps 的速度进行传输。在这里使用了软件上下拉标志位进行读取，而不是使用中断和 DMA。&lt;/p&gt;
&lt;p&gt;S32K144 评估板使用 LPSPI 的说明：在例程中使用了 LPSPI1 和外部芯片选择 3，链接在 MC33903 或者是 UGA1169TK/F 这两个 SBC(System Basis Chip) 芯片上面(默认是使用前者)，如果这个芯片收到数据被激活后，会返回一个 Reading Status Register 的值，我们就可以知道我们在 LPSPI 上的数据是否被发送到。为了给这个 SBC 供电，必须要连接一个 12V 的电源供应到 EVB 并且连接 1-2 管脚在 J107 跳线部分。在这个时候仍旧可以使用一个 USB 连接在 EVB 上面以允许 EVB 调试功能开启。如果 SBC 没有被供电的话，所有的 LPSPI 收到的数据都会是 0。&lt;/p&gt;
&lt;p&gt;使用 LPSPI1 要首先在 PCC 中选择时钟，然后根据 择的时钟进行分频，波特率计算，在 LPSPI1 中有两个 FIFO 寄存器，分别管理输入和输出队列。LPSPI 下方有一个 SBC 芯片，用作 Slave 器件，接收来自 LPSPI1 的数据。&lt;/p&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;设计流程：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;关狗&lt;/li&gt;
&lt;li&gt;系统时钟设置：初始化 SOSC 为 8MHz，系统时钟为 80MHz，RUN 模式为 80MHz&lt;/li&gt;
&lt;li&gt;初始化 LPSPI1：
&lt;ul&gt;
&lt;li&gt;模块控制：
&lt;ul&gt;
&lt;li&gt;关闭模块以允许设置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设置 LPSPI1 为主机(Master)：&lt;/li&gt;
&lt;li&gt;初始化时钟所需要的配置为 10MHz 为预分频功能时钟(100 微秒周期)
&lt;ul&gt;
&lt;li&gt;预分频功能时钟的频率 = 功能性时钟 / 预分频因子 = 40MHz/4 = 10MHz&lt;/li&gt;
&lt;li&gt;SCK 波特率 = (Functional clock / PRESCALE) / (SCKDIV+2) = (40 MHz / 4) / (8 + 2) = 10 MHz / 10 = 1 MHz&lt;/li&gt;
&lt;li&gt;SCK 和 PCS 间隔 = 5 prescaled functional clocks = 50 nesc&lt;/li&gt;
&lt;li&gt;PCS 和 CSK 间隔 = 10 prescaled functional clocks = 1 usec&lt;/li&gt;
&lt;li&gt;相邻两次传输的时间间隔 = 10 prescaled functional clocks = 1 usec&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FIFO 控制
&lt;ul&gt;
&lt;li&gt;RxFIFO: Receive Data Flag (RDF) 接收数据标志位 置位，当 FIFO&amp;gt;0&lt;/li&gt;
&lt;li&gt;TxFIFO: Transmit Data Flag (TDF) 发送数据标志位 置位，当 FIFO&amp;lt;=3&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设置发送命令（可以使用一些其他的设置在这里，例如使用不同的片选信号和每帧字节）
&lt;ul&gt;
&lt;li&gt;预分频因子为 8，(80 MHz / 8 = 10 MHz 预分频时钟)&lt;/li&gt;
&lt;li&gt;帧长度 = 16 bits&lt;/li&gt;
&lt;li&gt;PCS3 被用作片选信号&lt;/li&gt;
&lt;li&gt;SCK 极性为 Active Low&lt;/li&gt;
&lt;li&gt;相位：数据在 SCK 前沿改变，在后沿捕获&lt;/li&gt;
&lt;li&gt;MSB 首先（最高位先发），字节交换关闭，连续传输关闭&lt;/li&gt;
&lt;li&gt;单位宽度传送&lt;/li&gt;
&lt;li&gt;正常的 FIFO 配置：收到的数据在 Rx FIFO，发送的数据在 Tx FIFO&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;模块使能
&lt;ul&gt;
&lt;li&gt;使能模块，包括在调试模式和 DOZE 模式中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;初始化 PORT 管脚给 LPSPI1&lt;/li&gt;
&lt;li&gt;循环：
&lt;ul&gt;
&lt;li&gt;等待 TDF 置位（示意 Tx FIFO 可用），然后写入一帧到 Tx FIFO 并且清除 TDF&lt;/li&gt;
&lt;li&gt;等待 RDF 置位（示意接收到数据），然后读取一帧并且清楚 RDF&lt;/li&gt;
&lt;li&gt;减少 counter&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading-2&#34;&gt;代码&lt;/h3&gt;
&lt;p&gt;为了减少大家的阅读疲劳，这次仅仅挑出几个与本此 LPSPI 配置较为密切的寄存器以供大家学习。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PORT_init&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
PCC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCCn[PCC_PORTB_INDEX ]&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;PCC_PCCn_CGC_MASK; &lt;span style=&#34;color:#75715e&#34;&gt;/* Enable clock for PORTB */&lt;/span&gt;
PORTB&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCR[&lt;span style=&#34;color:#ae81ff&#34;&gt;14&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;PORT_PCR_MUX(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* Port B14: MUX = ALT3, LPSPI1_SCK */&lt;/span&gt;
PORTB&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCR[&lt;span style=&#34;color:#ae81ff&#34;&gt;15&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;PORT_PCR_MUX(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* Port B15: MUX = ALT3, LPSPI1_SIN */&lt;/span&gt;
PORTB&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCR[&lt;span style=&#34;color:#ae81ff&#34;&gt;16&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;PORT_PCR_MUX(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* Port B16: MUX = ALT3, LPSPI1_SOUT */&lt;/span&gt;
PORTB&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCR[&lt;span style=&#34;color:#ae81ff&#34;&gt;17&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;PORT_PCR_MUX(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* Port B17: MUX = ALT3, LPSPI1_PCS3 */&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个是设置 PORT MUX 的，如果这个看不懂的话可以从我的 S32K 第一节的 hello world 例程开始看起。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LPSPI1_init_master&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
PCC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCCn[PCC_LPSPI1_INDEX] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Disable clocks to modify PCS ( default) */&lt;/span&gt;
PCC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCCn[PCC_LPSPI1_INDEX] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0xC6000000&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Enable PCS=SPLL_DIV2 (40 MHz func&amp;#39;l clock) */&lt;/span&gt;
LPSPI1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000000&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Disable module for configuration */&lt;/span&gt;
LPSPI1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;IER &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000000&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Interrupts not used */&lt;/span&gt;
LPSPI1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;DER &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000000&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* DMA not used */&lt;/span&gt;
LPSPI1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CFGR0 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000000&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Defaults: */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* RDM0=0: rec&amp;#39;d data to FIFO as normal */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* CIRFIFO=0; Circular FIFO is disabled */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* HRSEL, HRPOL, HREN=0: Host request disabled */&lt;/span&gt;
LPSPI1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CFGR1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000001&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Configurations: master mode*/&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* PCSCFG=0: PCS[3:2] are enabled */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* OUTCFG=0: Output data retains last value when CS negated */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* PINCFG=0: SIN is input, SOUT is output */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* MATCFG=0: Match disabled */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* PCSPOL=0: PCS is active low */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* NOSTALL=0: Stall if Tx FIFO empty or Rx FIFO full */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* AUTOPCS=0: does not apply for master mode */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* SAMPLE=0: input data sampled on SCK edge */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* MASTER=1: Master mode */&lt;/span&gt;
LPSPI1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x5300000F&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Transmit cmd: PCS3, 16bits, prescale func&amp;#39;l clk by 4. */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* CPOL=0: SCK inactive state is low */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* CPHA=1: Change data on SCK lead&amp;#39;g, capture on trail&amp;#39;g edge*/&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* PRESCALE=2: Functional clock divided by 2**2 = 4 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* PCS=3: Transfer using PCS3 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* LSBF=0: Data is transferred MSB first */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* BYSW=0: Byte swap disabled */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* CONT, CONTC=0: Continuous transfer disabled */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* RXMSK=0: Normal transfer: rx data stored in rx FIFO */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* TXMSK=0: Normal transfer: data loaded from tx FIFO */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* WIDTH=0: Single bit transfer */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* FRAMESZ=15: # bits in frame = 15+1=16 */&lt;/span&gt;
LPSPI1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CCR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x04090808&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Clk dividers based on prescaled func&amp;#39;l clk of 100 nsec */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* SCKPCS=4: SCK to PCS delay = 4+1 = 5 (500 nsec) */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* PCSSCK=4: PCS to SCK delay = 9+1 = 10 (1 usec) */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* DBT=8: Delay between Transfers = 8+2 = 10 (1 usec) */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* SCKDIV=8: SCK divider =8+2 = 10 (1 usec: 1 MHz baud rate) */&lt;/span&gt;
LPSPI1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;FCR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000003&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* RXWATER=0: Rx flags set when Rx FIFO &amp;gt;0 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* TXWATER=3: Tx flags set when Tx FIFO &amp;lt;= 3 */&lt;/span&gt;
LPSPI1&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000009&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Enable module for operation */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* DBGEN=1: module enabled in debug mode */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* DOZEN=0: module enabled in Doze mode */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* RST=0: Master logic not reset */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* MEN=1: Module is enabled */&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这个就是 LPSPI 的主要设置内容了，里面的东西虽然繁杂，但是都需要一点点全部啃透了才能算理解，因为在工程中遇到的 SPI 协议有很多不同的设置，包括数据的捕获方式和片选方式，如果到时候还要查数据手册会大大降低效率。&lt;/p&gt;
&lt;p&gt;我们就详细的从最开始的 S32K144 LPSPI 模块的基本特性开始介绍：&lt;/p&gt;
&lt;h3 id=&#34;lpspi-&#34;&gt;LPSPI 特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Command/transmit FIFO 长度为 4 个 dwords (1 dword = 32 bits)&lt;/li&gt;
&lt;li&gt;Receive FIFO 为 4 个 words (1 dword = 32 bits)&lt;/li&gt;
&lt;li&gt;&amp;ldquo;主机输出请求 (Host request input)&amp;rdquo; 可以被用于控制 SPI 总线传输起始时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lpspi--1&#34;&gt;LPSPI 结构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-10-20-S32K144_7/LPSPI.png&#34; alt=&#34;LPSPI.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;lpspi--2&#34;&gt;LPSPI 工作模式&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Chip Mode&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;LPSPI Operation&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Run&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;正常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Stop/Wait&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;能够继续运行如果 &lt;code&gt;Doze Enable&lt;/code&gt; 置 0 &lt;!-- raw HTML omitted --&gt;并且 LPSPI 使用一个能够保持运行的时钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Low Leakage Stop&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;Doze Enable&lt;/code&gt; 被忽视，LPSPI 等待当前的传送任务完成&lt;!-- raw HTML omitted --&gt; 然后进入该模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Debug&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;能够继续运行如果 &lt;code&gt;Debug Enable&lt;/code&gt; 位被置位&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;heading-3&#34;&gt;用到的寄存器&lt;/h3&gt;
&lt;p&gt;由于实在太多了，大部分寄存器都是状态寄存器，所以就直接介绍一下设置寄存器，对于状态寄存器我们一概而过。&lt;/p&gt;
&lt;h3 id=&#34;control-register-lpspix-cr&#34;&gt;Control Register (LPSPIx_CR)&lt;/h3&gt;
&lt;p&gt;包含一些基本的寄存器操作。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RRF&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Reset Receive FIFO&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;0 没有作用&lt;!-- raw HTML omitted --&gt;1 Rx FIFO 被清空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RTF&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Reset Transmit FIFO&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;0 没有作用&lt;!-- raw HTML omitted --&gt;1 Tx FIFO 被清空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DBGEN&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Debug Enable&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;0 模块在 Debug 模式下关闭&lt;!-- raw HTML omitted --&gt;1 模块在 Debug 模式下开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DOZEN&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Doze mode enable&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;0 模块在 Doze 模式下关闭&lt;!-- raw HTML omitted --&gt;1 模块在 Doze 模式下开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RST&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Software Reset&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;重置所有的 SPI 内部寄存器（除了 CR）&lt;!-- raw HTML omitted --&gt;保持置位直到被软件清零&lt;!-- raw HTML omitted --&gt;0 不重置&lt;!-- raw HTML omitted --&gt;1 重置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;MEN&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Module Enable&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;0 不使能&lt;!-- raw HTML omitted --&gt;1 使能模块&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;status-register-lpspix-sr&#34;&gt;Status Register (LPSPIx_SR)&lt;/h3&gt;
&lt;p&gt;状态显示寄存器。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;24&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;MBF&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Module Busy Flag&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;0 LPSPI 空闲&lt;!-- raw HTML omitted --&gt;1 LPSPI 忙碌&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;13&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DMF&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Data Match Flag&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;指示接收的数据是否有和 MATCFG 寄存器中设置的一致&lt;!-- raw HTML omitted --&gt;0 LPSPI 未接收到匹配数据&lt;!-- raw HTML omitted --&gt;1 LPSPI 已经接收到匹配数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;REF&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Receive Error Flag&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;指示 Rx FIFO overflow&lt;!-- raw HTML omitted --&gt;0 Rx FIFO 没有溢出&lt;!-- raw HTML omitted --&gt;1 Rx FIFO 溢出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TEF&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Transmit Error Flag&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;指示 Tx FIFO underrun&lt;!-- raw HTML omitted --&gt;0 Tx FIFO 没有 underrun&lt;!-- raw HTML omitted --&gt;1 Rx FIFO 发生 underrun&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TCF&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Transfer Complete Flag&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;0 所有传输完成&lt;!-- raw HTML omitted --&gt;1 传输未完成&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;FCF&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Frame Complete Flag&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;0 当前接收/发送帧未传送完&lt;!-- raw HTML omitted --&gt;1 当前接收/发送帧已传送完&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;WCF&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Word Complete Flag&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;0 当前接收/发送字未传送完&lt;!-- raw HTML omitted --&gt;1 当前接收/发送字已传送完&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RDF&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Receive Data Flag&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;当 Rx FIFO中字多于 RXWATER 时置位&lt;!-- raw HTML omitted --&gt;0 接收数据准备好&lt;!-- raw HTML omitted --&gt;1 接收数据未准备好&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TDF&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Transmit Data Flag&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;当 Tx FIFO中字少于 TXWATER 时置位&lt;!-- raw HTML omitted --&gt;0 发送数据未准备好&lt;!-- raw HTML omitted --&gt;1 请求发送数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;interrupt-enable-register-lpspix-ier&#34;&gt;Interrupt Enable Register (LPSPIx_IER)&lt;/h3&gt;
&lt;p&gt;中断使能寄存器。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;13&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DMIE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Data Match Interrupt Enable&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;12&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DMIE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Receive Error Interrupt Enable&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;11&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TEIE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Transmit Error Interrupt Enable&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;10&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TCIE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Transfer Complete Interrupt Enable&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TEIE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Transmit Error Interrupt Enable&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;WCIE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Word Complete Interrupt Enable&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RDIE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Receive Data Interrupt Enable&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TDIE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Transmit Data Interrupt Enable&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;dma-enable-register-lpspix-der&#34;&gt;DMA Enable Register (LPSPIx_DER)&lt;/h3&gt;
&lt;p&gt;DMA 使能寄存器。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RDDE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Receive Data DMA Enable&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TDDE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Transmit Data DMA Enable&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;configuration-register-0-lpspix-cfgr0&#34;&gt;Configuration Register 0 (LPSPIx_CFGR0)&lt;/h3&gt;
&lt;p&gt;这个是一些基本的 SPI 设置，看到 0 了么，说明后面还有很多&amp;hellip;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RDMO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Receive Data Match Only&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;0 正常存取接收的数据到 FIFO &lt;!-- raw HTML omitted --&gt;1 如果接收的数据不是匹配数据就丢弃&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CIRFIFO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Circular FIFO Enable&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;开启后当 Tx FIFO 清空后会回复原状循环发送&lt;!-- raw HTML omitted --&gt;0 关闭循环发送&lt;!-- raw HTML omitted --&gt;1 开启循环发送&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;HRSEL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Host Request Select&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;0 Host request 输入是 LPSPI_HREQ 管脚&lt;!-- raw HTML omitted --&gt;1 Host request 输入是触发器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;HRPOL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Host Request Polarity&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;0 Active low&lt;!-- raw HTML omitted --&gt;1 Active high&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;HREN&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Host Request Enable&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;当在主机模式下的时候&lt;!-- raw HTML omitted --&gt;LPSPI 只会当收到 host request 后发送数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;configuration-register-1-lpspix-cfgr1&#34;&gt;Configuration Register 1 (LPSPIx_CFGR1)&lt;/h3&gt;
&lt;p&gt;这个寄存器应当在 LPSPI 关闭的时候进行写入。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;27&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PCSCFG&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Peripheral Chip Select Configuration&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;如果在使用 4-bit 传输，此位必须置位&lt;!-- raw HTML omitted --&gt;0 PCS[3:2] 启用 &lt;!-- raw HTML omitted --&gt;1 PCS[3:2] 禁用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;26&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;OUTCFG&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Output Config&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;设置如果片选为无效态的话输出数据 &lt;!-- raw HTML omitted --&gt;0 输出的数据保留最后&lt;!-- raw HTML omitted --&gt;1 输出的数据是三态的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;25-24&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PINCFG&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Pin Configuration&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;00 SIN 输入数据 SOUT 输出数据&lt;!-- raw HTML omitted --&gt;01 SOUT 既输入也输出&lt;!-- raw HTML omitted --&gt;10 SDI 既输入也输出&lt;!-- raw HTML omitted --&gt;11 SIN 输出数据 SOUT 输入数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;18-16&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;MATCFG&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Match Configuration&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;设置能够引起 DMF 置位的情况&lt;!-- raw HTML omitted --&gt;000 Match disabled&lt;!-- raw HTML omitted --&gt;010 Match 启用 (第一个数据字和 MATCH0 或者 MATCH1 一致)&lt;!-- raw HTML omitted --&gt;011 Match 启用 (任何数据字和 MATCH0 或者 MATCH1 一致)&lt;!-- raw HTML omitted --&gt;100 Match 启用 (第一个数据字和 MATCH0 且 第二个和 MATCH1 一致)&lt;!-- raw HTML omitted --&gt;101 Match 启用 (任何数据字和 MATCH0 且 下一个和 MATCH1 一致)&lt;!-- raw HTML omitted --&gt;110 Match 启用 (第一个数据字和 MATCH0 按位与 和 MATCH0 和 MATCH1 按位与一致)&lt;!-- raw HTML omitted --&gt;111 Match 启用 (任何数据字和 MATCH0 按位与 和 MATCH0 和 MATCH1 按位与一致)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;11-8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PCSPOL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Peripheral Chip Select Polarity&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;0 PCSx active low&lt;!-- raw HTML omitted --&gt;1 PCSx active high&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;NOSTALL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;NO STALL&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;当 Tx FIFO 为空或者 Rx FIFO 为满时通常会停止&lt;!-- raw HTML omitted --&gt;0 停止&lt;!-- raw HTML omitted --&gt;1 不停止&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;AUTOPCS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Automatic PCS&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;自动被片选，主机模式下无效&lt;!-- raw HTML omitted --&gt;0 禁用&lt;!-- raw HTML omitted --&gt;1 启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SAMPLE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Sample Point&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;0 Input data sampled on SCK edge.&lt;!-- raw HTML omitted --&gt;0 禁用&lt;!-- raw HTML omitted --&gt;1 Input data sampled on delayed SCK edge&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;MASTER&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Master Mode&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;0 Slave mode&lt;!-- raw HTML omitted --&gt;1 Master mode&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;data-match-register-01-lpspix-dmr01&#34;&gt;Data Match Register 0/1 (LPSPIx_DMR0/1)&lt;/h3&gt;
&lt;p&gt;之前说的 匹配值 寄存器，有两个分别是 0/1。&lt;/p&gt;
&lt;h3 id=&#34;clock-configuration-register-lpspix-ccr&#34;&gt;Clock Configuration Register (LPSPIx_CCR)&lt;/h3&gt;
&lt;p&gt;一些与时序有关的设置。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;31-24&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SCKPCS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;SCK to PCS Delay&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;主机模式下的最后一个 SCK 沿和 PCS 无效态的延时&lt;!-- raw HTML omitted --&gt;Delay=(SCKPCS+1)*波特率时钟周期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;23-16&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PCSSCK&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;PCS to SCK Delay&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;主机模式下的 PCS 有效态和 第一个 SCK 沿的延时&lt;!-- raw HTML omitted --&gt;Delay=(PCSSCK+1)*波特率时钟周期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;15-8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DBT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Delay Between Transfers&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;PCS 无效态到下个有效态的间隔&lt;!-- raw HTML omitted --&gt;Delay=(DBT+2)*波特率时钟周期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;7-0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SCKDIV&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;SCK Divider&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;设置 SCK 的分频时钟&lt;!-- raw HTML omitted --&gt;Divider=(SCKDIV+2)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;fifo-control-register-lpspix-fcr&#34;&gt;FIFO Control Register (LPSPIx_FCR)&lt;/h3&gt;
&lt;p&gt;控制 FIFO 的准备标志位。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;23-16&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RXWATER&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Receive FIFO Watermark&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;当 Rx FIFO 中装的字多于这个值就会使 RDF(Receive Data Flag) 置位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;7-0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TXWATER&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Transmit FIFO Watermark&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;当 Tx FIFO 中装的字少于这个值就会使 TDF(Transmit Data Flag) 置位&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;transmit-command-register-lpspix-tcr&#34;&gt;Transmit Command Register (LPSPIx_TCR)&lt;/h3&gt;
&lt;p&gt;重头戏，这个寄存器控制发送数据的过程。这个叫做发送命令寄存器，好玩的是里面存的都是命令，当你写入命令的时候，这个命令会像数据一样被存入 Tx FIFO，当它被顶置到 FIFO 顶的时候，一般的数据帧会被发送出去，但它不会发送，相反的是，它会改变后续的发送数据的属性，这个特性使 LPSPI 可以在保持发送不断的情况下改变发送的属性（譬如片选和长度）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;31&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CPOL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Clock Polarity&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;0 不活跃 SCK 为 low&lt;!-- raw HTML omitted --&gt;1 不活跃 SCK 为 high&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;30&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CPHA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Clock Phase&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;0 数据在前沿捕获在后沿改变&lt;!-- raw HTML omitted --&gt;1 数据在后沿捕获在前沿改变&lt;!-- raw HTML omitted --&gt;&lt;em&gt;前沿是指从不活跃到活跃的跳变沿&lt;/em&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;29-27&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PRESCALE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Prescaler Value&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;预分频时钟&lt;!-- raw HTML omitted --&gt;分频因子=2^(&lt;code&gt;PRESCALE&lt;/code&gt;+1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;25-24&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PCS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Peripheral Chip Select&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;片选&lt;!-- raw HTML omitted --&gt;使用 PCS[&lt;code&gt;PCS&lt;/code&gt;]&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;23&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;LSBF&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;LSB First&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;定义发送数据的排序方式&lt;!-- raw HTML omitted --&gt;0 MSB 高字节优先&lt;!-- raw HTML omitted --&gt;1 LSB 低字节优先&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;22&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BYSW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Byte Swap&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;内容置换，开启后将[31:24]和[7:0]互换，[23:16]与[15:8]互换&lt;!-- raw HTML omitted --&gt;0 内容置换关闭&lt;!-- raw HTML omitted --&gt;1 内容置换开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;21&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CONT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Continuous Transfer&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;开启后一直保持 PCS 有效&lt;!-- raw HTML omitted --&gt;0 开启&lt;!-- raw HTML omitted --&gt;1 关闭&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;20&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CONTC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Continuing Command&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;这个是开启了 &lt;code&gt;CONT=1&lt;/code&gt; 后如果想要改变属性用的&lt;!-- raw HTML omitted --&gt;下一个命令必须和上一个命令规定的数据帧长度一样，并且将此位置 1&lt;!-- raw HTML omitted --&gt;0 开启一个新的传输过程&lt;!-- raw HTML omitted --&gt;1 继续不间断传输&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;19&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RXMSK&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Receive Data Mask&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;开启后不将接收到的数据存入FIFO&lt;!-- raw HTML omitted --&gt;0 禁用&lt;!-- raw HTML omitted --&gt;1 开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;18&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TXMSK&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Transmit Data Mask&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;开启后不能发送数据&lt;!-- raw HTML omitted --&gt;0 禁用&lt;!-- raw HTML omitted --&gt;1 开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;17-16&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;WIDTH&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Transfer Width&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;传输的位宽&lt;!-- raw HTML omitted --&gt;00 单位传输&lt;!-- raw HTML omitted --&gt;01 两位传输&lt;!-- raw HTML omitted --&gt;10 四位传输&lt;!-- raw HTML omitted --&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;11-0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;FRAMESZ&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Frame Size&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;帧的长度&lt;!-- raw HTML omitted --&gt;帧的长度=(&lt;code&gt;FRAMESZ&lt;/code&gt;+1)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;transmit-data-register-lpspix-tdr&#34;&gt;Transmit Data Register (LPSPIx_TDR)&lt;/h3&gt;
&lt;p&gt;32-bit 发送寄存器，当发送的数据不够 32 位时用 0 补齐。&lt;/p&gt;
&lt;p&gt;还有一些乱七八糟的寄存器像是 RDR 什么的，都和上面的类似，很好理解，就没有再给出了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>S32K144EVB Notes 6 DMA</title>
      <link>https://xiahualiu.github.io/posts/2017-10-19-s32k144_6/</link>
      <pubDate>Thu, 19 Oct 2017 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2017-10-19-s32k144_6/</guid>
      <description>&lt;p&gt;这一节的内容是根据对于例程的探索，了解 S32K 上的 DMA 功能的使用方法。&lt;/p&gt;
&lt;h3 id=&#34;heading&#34;&gt;本章的代码涉及的内容:&lt;/h3&gt;
&lt;p&gt;首先介绍一下，DMA 的主要结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-10-19-S32K144_6/DMA_layout.png&#34; alt=&#34;DMA_layout.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;本程序将初始化一个 eDMA 通道的 Transfer Control Descriptor (TCD) 传输一个字符串 &lt;code&gt;“Hello world”&lt;/code&gt; 从向量 SRAM 空间到特定的 RAM 地址。这个过程仿真了一个常见的 DMA 使用过程，将一串数据或者命令写入外围的寄存器，这个例程的目的是说明如何创建一个 DMA 传输过程。&lt;/p&gt;
&lt;p&gt;当使用外围元件和 DMA 进行交流的时候，需要设置 DMA MUX，对应的外围元件号在 RM 附录中可以查询到，当然在软件触发的传输过程中，不需要 DMA MUX 的设置。&lt;/p&gt;
&lt;p&gt;中断过程在这个例子中并没有使用，但是在常见的传输过程中，是非常有用的特别是当传输结束后或者进行中进行操作。其中的一个使用例子就是使用 ADC 之类的外围元件，在转换完成后产生于一个 DMA 请求，DMA 控制器就可以自动将转换结果传输至 SRAM。当经过了一段时间的传输之后，DMA 会产生中断通知 CPU 对于传输的数据进行操作。&lt;/p&gt;
&lt;p&gt;当然还有更高级的使用方法，例如 Channel linking 和 Scatter-Gather (SGA)，能够使一个 DMA 请求完成不同的传输任务，或者是使用不同的 TCD 针对每一个 DMA 请求，这些强大的特性可以使外围实现类似状态机器类型的子系统，一个输入的信号可以传输不同的数据，用于同时初始化多个外围元件。Minor loop mapping 一般不在 MCU 的层面上进行使用，但是在图像的 45° 旋转中非常有用。下面会介绍到这个功能。&lt;/p&gt;
&lt;p&gt;因为没有外围的元件参与这个例子，自动的 DMA 握手不会发生。相反的，这里使用的软件握手需要一些额外的设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发起一个 DMA 服务请求（将需要传输通道的 START 位置位）&lt;/li&gt;
&lt;li&gt;等待局部传输完毕&lt;/li&gt;
&lt;li&gt;重复以上的两个步骤直到主环循环结束&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个步骤比较麻烦，因为一次就传输一个字节，但是在使用外部元件的时候，软件并不需要完成以上的步骤，他们是被硬件自动完成的。&lt;/p&gt;
&lt;p&gt;START 位在一般情况下是被外围的元件请求服务置位的。只要 DMA 处理引擎在通道激活，ACTIVE 位就会被置位，如果 DMA 在忙碌的时候，清零 START 可以终止传输过程，再检查一遍 ACTIVE 确认没有服务正在执行。&lt;/p&gt;
&lt;p&gt;作为一个小的练习，TCD 可以被修改，所以如果想让目标地址是一个向量而不是一个字节地址。可以声明目标地址是一个数组并且修改 &lt;code&gt;DOFF=1&lt;/code&gt; 目标地址偏移量达到。&lt;/p&gt;
&lt;p&gt;再来说一下 TCD(DMA Transfer Control Descriptor) 是什么，TCD 就像是一个 DMA 任务说明，他控制被传输的数据和传输的过程，每一个 TCD 占据 8 个 32-bit 的位置在内存里面，并且具有以下的结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-10-19-S32K144_6/TCD.png&#34; alt=&#34;TCD.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;他的初始化方法有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-10-19-S32K144_6/TCD_init.png&#34; alt=&#34;TCD_init.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;可见使用 DMA 是多么的复杂。:sweat_smile:
不要觉得沮丧，其实上面这个图根本就不用详细了解。看完本篇文章你就知道了所有的 TCD 和 DMA 寄存器的设置，等到那个时候再看这个图就觉得简单了。&lt;/p&gt;
&lt;h3 id=&#34;heading-1&#34;&gt;步骤：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;关狗&lt;/li&gt;
&lt;li&gt;系统时钟设置， SOSC 8MHz，SYSCLK 80MHz，RUN mode&lt;/li&gt;
&lt;li&gt;初始化 DMA 控制器：
&lt;ul&gt;
&lt;li&gt;开启时钟到 DMA MUX 模块（其实在软件模拟中并不需要因为我们手动写入了 START 位）&lt;/li&gt;
&lt;li&gt;开启需要的通道（软件模拟中并不需要，因为我们手动写入了 START 位）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;初始化 DMA TCD（在这里只用到了 TCD0 也就是通道 0 对应的 TCD）：
&lt;ul&gt;
&lt;li&gt;数据来源
&lt;ul&gt;
&lt;li&gt;Source address (SADDR): Use address of a string “Hello World”&lt;/li&gt;
&lt;li&gt;Source offset (SOFF): Increment source address by 1 byte for each transfer&lt;/li&gt;
&lt;li&gt;Source modulo (SMOD): Feature not used here&lt;/li&gt;
&lt;li&gt;Source size (SSIZE): Read 1 byte at a time&lt;/li&gt;
&lt;li&gt;Source last address adjustment (SLAST): Decrement source address by 11 after major loop&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;目标
&lt;ul&gt;
&lt;li&gt;Destination address (DADDR): Use address of a single byte&lt;/li&gt;
&lt;li&gt;Destination offset (DOFF): Do not add offset to destination address after minor loop&lt;/li&gt;
&lt;li&gt;Destination modulo (DMOD): Feature not used here&lt;/li&gt;
&lt;li&gt;Destination size (DSIZE): Write 1 byte at a time&lt;/li&gt;
&lt;li&gt;Destination last address adjustment (DLAST): Do not adjust address after major loop&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每个 DMA 请求的传送字节数（minor lopps）
&lt;ul&gt;
&lt;li&gt;Number of bytes to be transferred per DMA request (NBYTES): One byte&lt;/li&gt;
&lt;li&gt;Number of iterations/minor loops in major loop (CITER and BITER): 11&lt;/li&gt;
&lt;li&gt;Channel to channel linking for additional iterations after minor loop (BITER ELINK and CITER ELINK): Disabled&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;控制与状态
&lt;ul&gt;
&lt;li&gt;Disable channel after major loop completes (DREQ): Disable channel&lt;/li&gt;
&lt;li&gt;Generate interrupt request half way through major loop (INTHALF): Disabled&lt;/li&gt;
&lt;li&gt;Generate interrupt request after completing major loop (INTMAJOR): Disabled&lt;/li&gt;
&lt;li&gt;Enable Scatter-Gather (ESG): Disabled. No other TCDs loaded to channel&lt;/li&gt;
&lt;li&gt;Enable channel link after major loop (MAJORLINK): Disabled&lt;/li&gt;
&lt;li&gt;Channel link number after major loop (MAJORLINKCH): Null - feature disabled&lt;/li&gt;
&lt;li&gt;Band Width Control (BWC): Set to 0 so there are no stalls after R/W&lt;/li&gt;
&lt;li&gt;Clear initial values of status flags (START, ACTIVE, DONE): Set to zero&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开启第一个传输过程（置 START 为 1），等待传输完成（START=0，ACTIVE=0）&lt;/li&gt;
&lt;li&gt;循环：当通道的 DONE 未置位：
&lt;ul&gt;
&lt;li&gt;开始下一个传输（置 START 为 1），等待传输完成（START=0，ACTIVE=0）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;清空频道的 DONE 状态位&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;heading-2&#34;&gt;代码&lt;/h3&gt;
&lt;h5 id=&#34;mainc&#34;&gt;main.c&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;S32K144.h&amp;#34; /* Include peripheral declarations S32K144 */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;dma.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;clocks_and_modes.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;WDOG_disable&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;){
WDOG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CNT&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0xD928C520&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Unlock watchdog */&lt;/span&gt;
WDOG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TOVAL&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0x0000FFFF&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Maximum timeout value */&lt;/span&gt;
WDOG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CS &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00002100&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Disable watchdog */&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
WDOG_disable();
SOSC_init_8MHz(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Initialize system oscillator for 8 MHz xtal */&lt;/span&gt;
SPLL_init_160MHz(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Initialize SPLL to 160 MHz with 8 MHz SOSC */&lt;/span&gt;
NormalRUNmode_80MHz(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Init clocks: 80 MHz SPLL &amp;amp; core, 40 MHz bus, 20 MHz flash */&lt;/span&gt;
DMA_init(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Init DMA controller */&lt;/span&gt;
DMA_TCD_init(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Init DMA Transfer Control Descriptor(s) */&lt;/span&gt;
DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SSRT &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Set chan 0 START bit to initiate first minor loop */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (((DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCD[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].CSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; DMA_TCD_CSR_START_SHIFT) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* Wait for START = 0 */&lt;/span&gt;
((DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCD[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].CSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; DMA_TCD_CSR_ACTIVE_SHIFT) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)) {} &lt;span style=&#34;color:#75715e&#34;&gt;/* and ACTIVE = 0 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* Now minor loop has completed */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;((DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCD[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].CSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; DMA_TCD_CSR_DONE_SHIFT) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) ) { &lt;span style=&#34;color:#75715e&#34;&gt;/* Loop till DONE = 1 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* Place breakpoint at next instruction &amp;amp; observe expressions TCD0_Source, TCD0_Dest */&lt;/span&gt;
DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SSRT &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Set chan 0 START bit to initiate next minor loop */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (((DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCD[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].CSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; DMA_TCD_CSR_START_SHIFT) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* Wait for START = 0 */&lt;/span&gt;
((DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCD[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].CSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; DMA_TCD_CSR_ACTIVE_SHIFT) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)) {} &lt;span style=&#34;color:#75715e&#34;&gt;/* and ACTIVE = 0 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* Now minor loop has completed */&lt;/span&gt;
}
DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCD[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].CSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;(DMA_TCD_CSR_DONE_MASK); &lt;span style=&#34;color:#75715e&#34;&gt;/* Clear DONE bit */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) {} &lt;span style=&#34;color:#75715e&#34;&gt;/* Wait forever */&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;dmac&#34;&gt;DMA.c&lt;/h5&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;S32K144.h&amp;#34; /* include peripheral declarations S32K144 */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;dma.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;uint8_t TCD0_Source[] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {&lt;span style=&#34;color:#e6db74&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;Hello World&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;}; &lt;span style=&#34;color:#75715e&#34;&gt;/* TCD 0 source (11 byte string) */&lt;/span&gt;
uint8_t &lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt; TCD0_Dest &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* TCD 0 destination (1 byte) */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DMA_init&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
&lt;span style=&#34;color:#75715e&#34;&gt;/* This is an initialization place holder for: */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 1. Enabling DMA MUX clock PCC_PCCn[PCC_DMAMUX_INDEX] (not needed when START bit used) */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* 2. Enabling desired channels by setting ERQ bit (not needed when START bit used) */&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DMA_TCD_init&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
&lt;span style=&#34;color:#75715e&#34;&gt;/* TCD0: Transfers string to a single memory location */&lt;/span&gt;
DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCD[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].SADDR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DMA_TCD_SADDR_SADDR((uint32_t &lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;TCD0_Source); &lt;span style=&#34;color:#75715e&#34;&gt;/* Src */&lt;/span&gt;
DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCD[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].SOFF &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DMA_TCD_SOFF_SOFF(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* Src addr add 1 byte after transfer*/&lt;/span&gt;
DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCD[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].ATTR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DMA_TCD_ATTR_SMOD(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* Src modulo feature not used */&lt;/span&gt;
DMA_TCD_ATTR_SSIZE(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* Src read 2**0 =1 byte per transfer*/&lt;/span&gt;
DMA_TCD_ATTR_DMOD(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* Dest modulo feature not used */&lt;/span&gt;
DMA_TCD_ATTR_DSIZE(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* Dest write 2**0 =1 byte per trans.*/&lt;/span&gt;
DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCD[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].NBYTES.MLNO &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DMA_TCD_NBYTES_MLNO_NBYTES(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* Transfer 1 byte /minor loop*/&lt;/span&gt;
DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCD[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].SLAST &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DMA_TCD_SLAST_SLAST(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* Src addr change after major loop*/&lt;/span&gt;
DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCD[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].DADDR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DMA_TCD_DADDR_DADDR((uint32_t &lt;span style=&#34;color:#66d9ef&#34;&gt;volatile&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;TCD0_Dest);&lt;span style=&#34;color:#75715e&#34;&gt;/* Dest. */&lt;/span&gt;
DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCD[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].DOFF &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DMA_TCD_DOFF_DOFF(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* No dest adr offset after transfer*/&lt;/span&gt;
DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCD[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].CITER.ELINKNO&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DMA_TCD_CITER_ELINKNO_CITER(&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* 11 minor loop iterations*/&lt;/span&gt;
DMA_TCD_CITER_ELINKNO_ELINK(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* No minor loop chan link */&lt;/span&gt;
DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCD[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].DLASTSGA &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DMA_TCD_DLASTSGA_DLASTSGA(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* No dest chg after major loop*/&lt;/span&gt;
DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCD[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].CSR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DMA_TCD_CSR_START(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* Clear START status flag */&lt;/span&gt;
DMA_TCD_CSR_INTMAJOR(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* No IRQ after major loop */&lt;/span&gt;
DMA_TCD_CSR_INTHALF(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* No IRQ after 1/2 major loop */&lt;/span&gt;
DMA_TCD_CSR_DREQ(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* Disable chan after major loop*/&lt;/span&gt;
DMA_TCD_CSR_ESG(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* Disable Scatter Gather */&lt;/span&gt;
DMA_TCD_CSR_MAJORELINK(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* No major loop chan link */&lt;/span&gt;
DMA_TCD_CSR_ACTIVE(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* Clear ACTIVE status flag */&lt;/span&gt;
DMA_TCD_CSR_DONE(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* Clear DONE status flag */&lt;/span&gt;
DMA_TCD_CSR_MAJORLINKCH(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* Chan # if major loop ch link */&lt;/span&gt;
DMA_TCD_CSR_BWC(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* No eDMA stalls after R/W */&lt;/span&gt;
DMA&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCD[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].BITER.ELINKNO&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DMA_TCD_BITER_ELINKNO_BITER(&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* Initial iteration count*/&lt;/span&gt;
DMA_TCD_BITER_ELINKNO_ELINK(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* No minor loop chan link */&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;哇，这个大家自己对照那个表来看吧，太麻烦了。
DMA 只要发出指令后，CPU 是不需要任何操作的，可以看到在主函数里面有几个空循环等待 DMA 完成。&lt;/p&gt;
&lt;p&gt;DMA 是个大工程，要是想理解的话需要一定的时间，一开始的时候我看这一节很头大，因为需要理解的东西太多了。&lt;/p&gt;
&lt;p&gt;首先先从硬件上的 DMA MUX 开始讲起，DMA MUX 是一个模块，它的作用就是用来路由一共 64 个 DMA 源，也叫做槽，到 16 个 DMA 通道的任意一个位置上面。在进行硬件 DMA 请求的时候，其实请求源是先经过 DMAMUX ，并被映射到 16 个 DMA 通道上面，所以我们要进行 DMA 操作的时候要首先设置 DMAMUX，不然 DMA 请求根本就无法到达 DMA。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-10-19-S32K144_6/DMAMUX.png&#34; alt=&#34;DMAMUX.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;dmamux-&#34;&gt;DMAMUX 的工作模式：&lt;/h3&gt;
&lt;h4 id=&#34;heading-3&#34;&gt;关闭模式&lt;/h4&gt;
&lt;p&gt;在这个模式下，DMA 通道是关闭的。因为关闭或者开启 DMA 通道是在修改 DMA 相关寄存器需要首先操作的，所以这个模式主要是用于将一个 DMA 通道的状态修改为默认状态。还有一个用途就是，当你重新设置系统设置时候用于暂时挂起一个 DMA 通道，如你要修改 DMA 触发器周期。&lt;/p&gt;
&lt;h4 id=&#34;heading-4&#34;&gt;正常模式&lt;/h4&gt;
&lt;p&gt;在这种状态下，DMA 源是被路由到特定的 DMA 通道上。在这个模式下的 DMA MUX 的路由功能是自动的，可以视作一个不存在的模块。&lt;/p&gt;
&lt;h4 id=&#34;heading-5&#34;&gt;周期触发模式&lt;/h4&gt;
&lt;p&gt;在这种状态下，DMA 源将会周期性请求一个 DMA 请求，例如是一个接收 Buffer 装满或者是发送 Buffer 已经被清空。&lt;/p&gt;
&lt;p&gt;设置周期是通过修改 LPIT 的寄存器数据进行修改的。这个模式仅仅能够在 0-3 这四个通道进行的。&lt;/p&gt;
&lt;h3 id=&#34;-dmamux&#34;&gt;设置 DMAMUX：&lt;/h3&gt;
&lt;h4 id=&#34;channel-configuration-register-dmamux-chcfgnn0-15&#34;&gt;Channel Configuration register (DMAMUX_CHCFGn)(n=0-15)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;每一个 DMA 通道都只能单独的对应一个源&lt;/strong&gt;。如果设置多个 CHCFG 寄存器的值对应同一个源的话会导致不可预料的错误，甚至是你将其中相同映射通道关闭还是会导致错误的出现。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ENBL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;DMA Channel Enable&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;通道是能开关&lt;!-- raw HTML omitted --&gt;0 是关闭通道，1 是开启通道&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;TRIG&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;DMA Channel Trigger Enable&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;开启周期性开关&lt;!-- raw HTML omitted --&gt;0 关闭周期性开关，通道将会正常开&lt;!-- raw HTML omitted --&gt;1 是开启触发模式，只有当接收到出发的时候，DMA MUX 才会正常工作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5-0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SOURCE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;此位用于设置对应源的序号&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;heading-6&#34;&gt;功能的描述：&lt;/h3&gt;
&lt;p&gt;DMAMUX 的功能是为了提供给系统灵活的 DMA 使用权，通过 DMA 通道。&lt;/p&gt;
&lt;p&gt;DMAMUX 的通道可以划分成为一下的几个类别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通道可以正常的在路由配置下进行路由&lt;/li&gt;
&lt;li&gt;通道只有在触发信号和路由配置下进行路由&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;而且 DMAMUX 有两个源地址是常开的，它的作用是一直允许数据传输，这个特性在读写 GPIO 数据，或者是为了保证数据传输速的情况下非常有用。（也可以使用软件激活 DMA 传输，不需要频繁的开关 DMA 通道）&lt;/p&gt;
&lt;h3 id=&#34;-dma-&#34;&gt;使用，控制 DMA 源的过程&lt;/h3&gt;
&lt;h4 id=&#34;heading-7&#34;&gt;使用一个周期性触发的源：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;决定使用哪一个 DMA 源，在这个时候应当注意只有前 4 个通道是周期性通道。&lt;/li&gt;
&lt;li&gt;清空对应通道的 &lt;code&gt;CHCFG[ENBL]&lt;/code&gt; 和 &lt;code&gt;CHCFG[TRIG]&lt;/code&gt;  。&lt;/li&gt;
&lt;li&gt;确定在 DMA 中，相应的通道已经被设置完成，这个时候可以控制开启 DMA 通道。&lt;/li&gt;
&lt;li&gt;设置对应的时钟。&lt;/li&gt;
&lt;li&gt;选择合适的源到 DMA 通道上面去，写入相对应的 &lt;code&gt;CHCFG[ENBL]&lt;/code&gt; 和 &lt;code&gt;CHCFG[TRIG]&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;heading-8&#34;&gt;举个例子以便于大家理解：&lt;/h5&gt;
&lt;p&gt;我们现在要设置 5# 源使用 DMA 通道 1，并且使用周期性触发的功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向 &lt;code&gt;CHCFG1&lt;/code&gt; 写入 0x00&lt;/li&gt;
&lt;li&gt;设置通道 1 在 DMA 设置中，包括开启该通道&lt;/li&gt;
&lt;li&gt;设置一个时钟给所需要的触发间隔&lt;/li&gt;
&lt;li&gt;向 &lt;code&gt;CHCFG1&lt;/code&gt; 写入相应的值&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后一步设置 DMAMUX 的代码可以写成如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DMAMUX_Init&lt;/span&gt; (uint8_t DMA_CH, uint8_t DMAMUX_SOURCE)
{
    DMAMUX_0.CHCFG[DMA_CH].B.SOURCE &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; DMAMUX_SOURCE;
    DMAMUX_0.CHCFG[DMA_CH].B.ENBL &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
    DMAMUX_0.CHCGF[DMA_CH].B.TRIG &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;heading-9&#34;&gt;使用一个不是周期性触发的通道：&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;决定使用哪一个 DMA 源，在这个时候应当注意只有前 4 个通道是周期性通道。&lt;/li&gt;
&lt;li&gt;清空对应通道的 &lt;code&gt;CHCFG[ENBL]&lt;/code&gt; 和 &lt;code&gt;CHCFG[TRIG]&lt;/code&gt;  。&lt;/li&gt;
&lt;li&gt;确定在 DMA 中，相应的通道已经被设置完成，这个时候可以控制开启 DMA 通道。&lt;/li&gt;
&lt;li&gt;选择合适的源到 DMA 通道上面去，写入相对应的 &lt;code&gt;CHCFG[ENBL]&lt;/code&gt; 和 &lt;code&gt;CHCFG[TRIG]&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;少了一个配置时钟的环节。&lt;/p&gt;
&lt;p&gt;以上是 DMAMUX 也即是 DMA 多路复用器的设置方法，下面我们介绍一下 eDMA(Enhanced Direct Memory Access) 模块，结构功能和使用方法。&lt;/p&gt;
&lt;h3 id=&#34;edma-&#34;&gt;eDMA 组件&lt;/h3&gt;
&lt;p&gt;eDMA 分为两个主要的模块，一个是 eDMA 引擎和 TCD。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-10-19-S32K144_6/DMA_module.png&#34; alt=&#34;DMA_module.png&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;edma--1&#34;&gt;eDMA 工作特点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据移动过程涉及到两个地址：从源地址读取数据，写入目标地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可控制的源地址和目标地址和传输数据大小&lt;/li&gt;
&lt;li&gt;支持加强的地址模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;16 通道执行器，可以实现复杂的数据传输&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部数据缓存器，可以暂时储存 16 或者 32 字节的传输&lt;/li&gt;
&lt;li&gt;连接在纵横开关（多端口选择开关）连接在占据总线和数据移动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Transfer control descriptor (TCD) 被升级成为支持两种内嵌的深度传输操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每一个通道都对应一个 32-byte TCD 储存在内存中&lt;/li&gt;
&lt;li&gt;内部数据传输副循环被定义&lt;/li&gt;
&lt;li&gt;外部数据传输主循环被定义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通道激活通过以下三种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接软件初始化&lt;/li&gt;
&lt;li&gt;通过通道连接机制激活&lt;/li&gt;
&lt;li&gt;外部步进请求硬件激活&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;固定优先级和轮询仲裁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通道数据传输完成后可产生中断请求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个通道一个中断源，可以实现在主循环完成后发起中断&lt;/li&gt;
&lt;li&gt;可编程错误终止，并且产生相应的中断给中断控制器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;dma-&#34;&gt;DMA 工作流程&lt;/h1&gt;
&lt;p&gt;首先，外围设备发出 DMA 请求要求通道 n 提供 DMA 服务。首先是通道激活阶段。 eDMA
请求的输入信号先做 DMA 的内部登记，然后被传送到 eDMA 引擎：首先通过控制模块，然
后进入编程模块进行裁决。下一步，开始根据固定优先级或轮流的方法对 DMA 请求裁决。
裁决完毕，被激活的通道号通过地址路径并被转换成访问内存的地址。下一步， TCD 存储器
被访问，对应的 TCD 描述符被读取并载入到 eDMA 引擎中。&lt;/p&gt;
&lt;h3 id=&#34;edma--2&#34;&gt;eDMA 相关的寄存器！重中之重&lt;/h3&gt;
&lt;p&gt;这个是 eDMA 的一个典型的工作流程，请先保证自己对于副循环和主循环有一个了解在进行寄存器方面的设置
&lt;img src=&#34;https://xiahualiu.github.io/img/2017-10-19-S32K144_6/DMA_process.png&#34; alt=&#34;DMA_process.png&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;control-register-dma-cr&#34;&gt;Control Register (DMA_CR)&lt;/h4&gt;
&lt;p&gt;这个寄存器定义了一些基本的设置。当写入这个寄存器的时候，请保证 DMA 通道不处于活跃状态。&lt;/p&gt;
&lt;p&gt;在此寄存器可以进行仲裁机制的设置，仲裁机制可以被设置成为使用一个固定的优先级的或者是轮询的方式。当时用轮询方式进行 DMA 仲裁的时候，优先级将会被忽略，按照通道的序号从高到低进行。&lt;/p&gt;
&lt;p&gt;副循环偏移量是指当副循环完成的时候，源地址或者是目标地址的偏移量，这个偏移量如果被开启的状态下，当一次副循环结束，TCD 内目标源地址 &lt;code&gt;TCDn_SADDR&lt;/code&gt; 或者是目标地址 &lt;code&gt;TCDn_DADDR&lt;/code&gt; 亦或是两者，都会在加上一个 minor loop offset (MLOFF) 后被送回内存。&lt;/p&gt;
&lt;p&gt;主循环偏移量，和副循环偏移量基本一致，但是要注意，主循环最后完成的副循环，其设置的副循环偏移量将会被忽视，取而代之的是主循环偏移量。&lt;/p&gt;
&lt;p&gt;其中副循环量就是在该寄存器的 7-EMLM 其中设置 1 开启 Mapping 功能。在一般的操作中，这个功能基本上用不到，但是必须知道，不然没法设置寄存器。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;17&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CX&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Cancel Transfer&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;此位写入 1 后将会强行停止通道并且强制副循环结束&lt;!-- raw HTML omitted --&gt;结束后，将会自动清零&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;16&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ECX&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Error Cancel Transfer&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;这位的功能和 CX 一致&lt;!-- raw HTML omitted --&gt;DMA 将会视作终止是由于错误产生的&lt;!-- raw HTML omitted --&gt;&lt;code&gt;Error Status register (DMAx_ES)&lt;/code&gt; 将会被置 1 并且可以产生一个中断&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;EMLM&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Enable Minor Loop Mapping&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;副循环偏移量使能位&lt;!-- raw HTML omitted --&gt;副循环偏移量使能位，当为 1 的时候，TCDn.word2 会有不同的内容，具体在下边&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CLM&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Continuous Link Mode&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;&lt;strong&gt;注意&lt;/strong&gt;：请不要设置主循环内只有一个副循环的通道成为连续模式&lt;!-- raw HTML omitted --&gt;如果置 1，则副循环结束后，可以不经过通道仲裁再次被激活 &lt;!-- raw HTML omitted --&gt;如果置 0，则副循环结束后，必须在经过一个通道仲裁才可以继续运行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;HALT&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Halt DMA Operations&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;置 1 后暂停所有新的通道&lt;!-- raw HTML omitted --&gt;执行中的通道将会继续运行至结束 &lt;!-- raw HTML omitted --&gt;再次置 0 可以恢复正常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;HOE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Halt On Error&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;和上边的 HALT 寄存器一致，但是拥有错误属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ERCA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Enable Round Robin Channel Arbitration&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;置 1 允许通道的轮询模式进行仲裁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;EDBG&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Enable Debug&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;置 1 后，新的通道请求将会被暂停，直到退出 Debug 模式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;error-status-register-dma-es&#34;&gt;Error Status Register (DMA_ES)&lt;/h4&gt;
&lt;p&gt;错误寄存器，储存各种 DMA 通道错误。我们可以用 OpenSDA 调试查看这个寄存器的值，平时用不到，先不介绍。错误类型一般有 非法 TCD，错误的优先级寄存器，总线读写错误。&lt;/p&gt;
&lt;h4 id=&#34;enable-request-register-dma-erq&#34;&gt;Enable Request Register (DMA_ERQ)&lt;/h4&gt;
&lt;p&gt;这个寄存器控制 16 个通道的请求信号是否被接收。写入这个寄存器中相应的位可以直接控制，也可以通过后续的 &lt;code&gt;DMA_SERQ&lt;/code&gt; 和 &lt;code&gt;DMA_CERQ&lt;/code&gt; 操作寄存器间接影响这个寄存器的值。&lt;/p&gt;
&lt;p&gt;但是如果没有 DMA 请求产生的 DMA 服务（譬如软件控制 DMA）则此位的状态无论如何都可以产生 DMA 服务。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ERQn&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Enable DMA Request n&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;置 1 开启相对应的通道请求接收&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;enable-error-interrupt-register-dma-eei&#34;&gt;Enable Error Interrupt Register (DMA_EEI)&lt;/h4&gt;
&lt;p&gt;这个寄存器控制 16 个通道是否产生错误中断。写入这个寄存器中相应的位可以直接控制，也可以通过后续的 &lt;code&gt;DMA_SEEI&lt;/code&gt; 和 &lt;code&gt;DMA_CEEI&lt;/code&gt; 操作寄存器间接影响这个寄存器的值。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;EEIn&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Enable Error Interrupt n&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;置 1 开启相对应的通道错误中断&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;interrupt-request-register-dma-int&#34;&gt;Interrupt Request Register (DMA_INT)&lt;/h5&gt;
&lt;p&gt;这个寄存器控制各个通道的中断请求是否产生，中断的产生条件是写在对应的通道的 TCD 中，然而在中断产生后，我们需要及时的关闭它，常常在 &lt;code&gt;CINT&lt;/code&gt; 操作寄存器中进行清零操作，在下面我们会介绍很多操作寄存器。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;n&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;INTn&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Interrupt Request n&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;1 目前通道的中断被激活&lt;!-- raw HTML omitted --&gt;0 目前通道中断未激活&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;channel-n-priority-register-dma-dchprin&#34;&gt;Channel n Priority Register (DMA_DCHPRIn)&lt;/h4&gt;
&lt;p&gt;DMA 通道优先级寄存器&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ECP&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Enable Channel Preemption&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;这个是被抢占的开关，也就是置 1 后，该通道会被更高优先级的通道抢断&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DPA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Disable Preempt Ability&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;这个是不能抢占的开关，也就是置 1 后，该通道被剥夺抢占低优先级通道的权利&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CHPRI&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Channel n Arbitration Priority&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;这个就是传统意义上的通道优先级了&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h1 id=&#34;-dma--1&#34;&gt;下面是 DMA 操作寄存器&lt;/h1&gt;
&lt;p&gt;这个寄存器有很多类似的，基本的功能不是 Clear 就是 Set，为什么我称之为操作寄存器就是修改里面的值，带来的结果是对应的配置寄存器的值的改变，其本身不对应配置。&lt;/p&gt;
&lt;h4 id=&#34;clear-enable-error-interrupt-register-dma-ceei&#34;&gt;Clear Enable Error Interrupt Register (DMA_CEEI)&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;NOP&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;No Op enable&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;置 1 后，该寄存器所有操作均被忽视&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CAFE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Clear All Enable Error Interrupt&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;置 1 后，&lt;code&gt;DMA_EEI&lt;/code&gt; 所有 EEI 位均被清零&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3-0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CEEI&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Clear Enable Error Interrupt&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;在这个域内填写（0-15）将会导致对应的 EEIn 清零&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;set-enable-error-interrupt-register-dma-seei&#34;&gt;Set Enable Error Interrupt Register (DMA_SEEI)&lt;/h4&gt;
&lt;p&gt;和上面的一样，只不过是清零改成置位。&lt;/p&gt;
&lt;h4 id=&#34;clear-enable-request-register-dma-cerq&#34;&gt;Clear Enable Request Register (DMA_CERQ)&lt;/h4&gt;
&lt;p&gt;清零 ERQ 位。&lt;/p&gt;
&lt;h4 id=&#34;set-enable-request-register-dma-serq&#34;&gt;Set Enable Request Register (DMA_SERQ)&lt;/h4&gt;
&lt;p&gt;置位 ERQ 位。&lt;/p&gt;
&lt;h4 id=&#34;clear-done-status-bit-register-dma-cdne&#34;&gt;Clear DONE Status Bit Register (DMA_CDNE)&lt;/h4&gt;
&lt;p&gt;清零通道的 TCD 中的 DONE 位。&lt;/p&gt;
&lt;h4 id=&#34;set-start-bit-register-dma-ssrt&#34;&gt;Set START Bit Register (DMA_SSRT)&lt;/h4&gt;
&lt;p&gt;将通道 TCD 中的 START 位置位。&lt;/p&gt;
&lt;h4 id=&#34;clear-error-register-dma-cerr&#34;&gt;Clear Error Register (DMA_CERR)&lt;/h4&gt;
&lt;p&gt;将通道中的错误寄存器清零。&lt;/p&gt;
&lt;h4 id=&#34;clear-interrupt-request-register-dma-cint&#34;&gt;Clear Interrupt Request Register (DMA_CINT)&lt;/h4&gt;
&lt;p&gt;将通道中的中断请求清零。&lt;/p&gt;
&lt;h2 id=&#34;tcd&#34;&gt;TCD相关寄存器&lt;/h2&gt;
&lt;p&gt;注意，以下寄存器均有 16 个，对应 16 个通道。&lt;/p&gt;
&lt;h3 id=&#34;tcd-source-address-dma-tcdn-saddr&#34;&gt;TCD Source Address (DMA_TCDn_SADDR)&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SADDR&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Source Address&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;存放指向源数据的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;tcd-signed-source-address-offset-dma-tcdn-soff&#34;&gt;TCD Signed Source Address Offset (DMA_TCDn_SOFF)&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SOFF&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Source address signed offset&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;每次读取源地址后产生的偏移量&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;tcd-transfer-attributes-dma-tcdn-attr&#34;&gt;TCD Transfer Attributes (DMA_TCDn_ATTR)&lt;/h3&gt;
&lt;p&gt;这个寄存器只有 16-bit，目的是确认一次性的 DMA 传输多少数据，应该和副循环中的 &lt;code&gt;NBYTES&lt;/code&gt; 区分开，一个副循环内部可能需要多次的读写过程。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;15-11&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SMOD&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Source Address Modulo&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;源地址模值 &lt;!-- raw HTML omitted --&gt;SMOD 定义了一个地址范围，该范围可用 2^SMOD 来表示 &lt;!-- raw HTML omitted --&gt;每次传送，也就是内部完成一次读/写 &lt;!-- raw HTML omitted --&gt;下一次读取源地址将从 SADDR+SOFF 开始&lt;!-- raw HTML omitted --&gt;如果这个地址到达了 SMOD 指定的范围，则将从头开始&lt;!-- raw HTML omitted --&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;10-8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SSIZE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Source data transfer size&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;源数据读取大小设置 &lt;!-- raw HTML omitted --&gt;000 - 8-bit&lt;!-- raw HTML omitted --&gt;001 - 16-bit&lt;!-- raw HTML omitted --&gt;010 - 32-bit &lt;!-- raw HTML omitted --&gt;011 - Reserved&lt;!-- raw HTML omitted --&gt;100 - 16-byte burst&lt;!-- raw HTML omitted --&gt;101 - 32-byte burst&lt;!-- raw HTML omitted --&gt;110 - Reserved&lt;!-- raw HTML omitted --&gt;111 - Reserved &lt;!-- raw HTML omitted --&gt;（请不要使用保留的值，会导致配置错误）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;7-3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DMOD&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Destination Address Modulo&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;看上面的 SMOD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2-0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DSIZE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Destination data transfer size&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;看上面的 SSIZE&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;tcd-minor-byte-count-minor-loop-mapping-disabled-dma-tcdn-nbytes-mlno&#34;&gt;TCD Minor Byte Count (Minor Loop Mapping Disabled) (DMA_TCDn_NBYTES_MLNO)&lt;/h3&gt;
&lt;p&gt;之前我写了一个有关的，在 &lt;code&gt;DMA_CR.MLME=1&lt;/code&gt; 会改变 TCDn.word2 的改变，这个就是当 &lt;code&gt;DMA_CR.MLME=0&lt;/code&gt;，也即是 Minor Loop Mapping 处于关闭状态下的 NBYTES 寄存器。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;NBYTES&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Minor Byte Transfer Count&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 这个寄存器里面的值就是一次副循环的 &lt;strong&gt;字节数&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 在 DMA 传输过程中，副循环是 &lt;strong&gt;最小&lt;/strong&gt; 的数据传输单位&lt;!-- raw HTML omitted --&gt;在主循环传输过程中不可打断&lt;!-- raw HTML omitted --&gt;当一个 DMA 通道被激活后，相关的 TCD 内容将会被加载进 eDMA 引擎中&lt;!-- raw HTML omitted --&gt;经过一段时间的读/写数据，直到传输了 NBYTES 个字节&lt;!-- raw HTML omitted --&gt;此时 一次副循环完成，主循环计数器减一存入 TCD&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;tcd-signed-minor-loop-offset-minor-loop-mapping-enabled-and-offset-disabled-dma-tcdn-nbytes-mloffno&#34;&gt;TCD Signed Minor Loop Offset (Minor Loop Mapping Enabled and Offset Disabled) (DMA_TCDn_NBYTES_MLOFFNO)&lt;/h3&gt;
&lt;p&gt;这个寄存器的形态条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Minor loop mapping 开启 (&lt;code&gt;CR[EMLM] = 1&lt;/code&gt;) 并且&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMLOE = 0&lt;/code&gt; &lt;strong&gt;and&lt;/strong&gt; &lt;code&gt;DMLOE = 0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;31&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SMLOE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Source Minor Loop Offset Enable&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 选择是否进行源地址副循环偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;30&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DMLOE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Destination Minor Loop Offset enable&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 选择是否进行目标地址副循环偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;29-0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;NBYTES&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Minor Byte Transfer Count&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 这个寄存器里面的值就是一次主循环的 &lt;strong&gt;字节数&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;tcd-signed-minor-loop-offset-minor-loop-mapping-and-offset-enabled-dma-tcdn-nbytes-mloffyes&#34;&gt;TCD Signed Minor Loop Offset (Minor Loop Mapping and Offset Enabled) (DMA_TCDn_NBYTES_MLOFFYES)&lt;/h3&gt;
&lt;p&gt;这个寄存器的形态条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Minor loop mapping 开启 (&lt;code&gt;CR[EMLM] = 1&lt;/code&gt;) 并且&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SMLOE = 1&lt;/code&gt; &lt;strong&gt;or&lt;/strong&gt; &lt;code&gt;DMLOE = 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;31&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SMLOE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Source Minor Loop Offset Enable&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 选择是否进行源地址副循环偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;30&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DMLOE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Destination Minor Loop Offset enable&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 选择是否进行目标地址副循环偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;29-10&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;MLOFF&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;拓展副循环偏移量设置&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 这个偏移量是同时作用在源地址和目标地址上的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;9-0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;NBYTES&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Minor Byte Transfer Count&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 这个寄存器里面的值就是一次主循环的 &lt;strong&gt;字节数&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;注意 MLOFF 和 SOFF DOFF 其实是一样功能的，只是 MLOFF 设置后会在副循环完成的时候叠在在地址上。&lt;/p&gt;
&lt;h3 id=&#34;tcd-last-source-address-adjustment-dma-tcdn-slast&#34;&gt;TCD Last Source Address Adjustment (DMA_TCDn_SLAST)&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SLAST&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Last Source Address Adjustment&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 最后源地址调整量 &lt;!-- raw HTML omitted --&gt; 当主循环结束后，将会在旧源地址上加入此调整量 &lt;!-- raw HTML omitted --&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;tcd-tcd-destination-address-dma-tcdn-daddr&#34;&gt;TCD TCD Destination Address (DMA_TCDn_DADDR)&lt;/h3&gt;
&lt;p&gt;这个跟上边那个 SADDR 一样，不详细写了。&lt;/p&gt;
&lt;h3 id=&#34;tcd-signed-destination-address-offset-dma-tcdn-doff&#34;&gt;TCD Signed Destination Address Offset (DMA_TCDn_DOFF)&lt;/h3&gt;
&lt;p&gt;决定当每个主循环结束后，目标地址的偏移量。16-bit&lt;/p&gt;
&lt;h3 id=&#34;tcd-current-minor-loop-link-major-loop-count-dma-tcdn-citer-elinkyes&#34;&gt;TCD Current Minor Loop Link, Major Loop Count (DMA_TCDn_CITER_ELINKYES)&lt;/h3&gt;
&lt;p&gt;该寄存器为 16-bit。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;15&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ELINK&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Enable channel-to-channel linking on minor-loop complete&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 开启后即是开启通道连接功能，当副循环完成的时候 &lt;!-- raw HTML omitted --&gt; 该位置 1 将会导致 &lt;code&gt;LINKCH&lt;/code&gt; 对应通道内的 &lt;code&gt;TCDn_CSR[START]=1&lt;/code&gt; 激活该通道&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;12-9&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;LINKCH&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Minor Loop Link Channel Number&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; &lt;code&gt;ELINK=1&lt;/code&gt; 的情况下，此寄存器才会存在 &lt;!-- raw HTML omitted --&gt; &lt;code&gt;ELINK=0&lt;/code&gt; 此寄存器的位置被 &lt;code&gt;CITER&lt;/code&gt; 占据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;(14-0) or (8-0)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CITER&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Current Major Iteration Count&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 主循环计数器 &lt;!-- raw HTML omitted --&gt; 15-bit —— &lt;code&gt;ELINK=0&lt;/code&gt; &lt;!-- raw HTML omitted --&gt;  9-bit —— &lt;code&gt;ELINK=1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;tcd-last-destination-address-adjustmentscatter-gather&#34;&gt;TCD Last Destination Address Adjustment/Scatter Gather&lt;/h3&gt;
&lt;p&gt;Address (DMA_TCDn_DLASTSGA)&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DLASTSGA&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;这个寄存其有两个含义&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 在 &lt;code&gt;TCDn_CSR[ESG] = 0&lt;/code&gt; 情况下，当做主循环目标地址偏移量 &lt;!-- raw HTML omitted --&gt;如果 &lt;code&gt;TCDn_CSR[ESG] != 0&lt;/code&gt; 则寄存器指向一个 TCD&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;tcd-control-and-status-dma-tcdn-csr&#34;&gt;TCD Control and Status (DMA_TCDn_CSR)&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;15-14&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;BWC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;带宽控制&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 00 无 eDMA 引擎停止 &lt;!-- raw HTML omitted --&gt;01 Reserved&lt;!-- raw HTML omitted --&gt;10 eDMA 引擎每 4 次读写停止&lt;!-- raw HTML omitted --&gt;11 eDMA 引擎每 8 次读写停止&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;11-8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;MAJORLINKCH&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;主循环通道连接序号&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 设置当主循环结束后，触发的另一个通道号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;7&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DONE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;通道完成位&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 当 CITER 计数器完成时自动置位&lt;!-- raw HTML omitted --&gt;软件清零或者当下一次激活通道的时候自动清零&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ACTIVE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;通道激活位&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 指示当前通道的执行状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;MAJORELINK&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;使能主循环通道连接位&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 0 关闭 &lt;!-- raw HTML omitted --&gt; 1 开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ESG&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;聚散处理使能位&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 0 关闭 TCD 正常 &lt;!-- raw HTML omitted --&gt; 1 开启 TCD.DLASTSGA 将会指向下一个 TCD&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DREQ&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;关闭请求位&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 1 通道 ERQ 位会在主循环后自动清零 &lt;!-- raw HTML omitted --&gt; 0 通道 ERQ 位不会自动清零&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;INTHALF&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;允许当主循环一半时发起中断&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 0 关闭 &lt;!-- raw HTML omitted --&gt; 1 开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;INTMAJOR&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;允许当主循环完成时发起中断&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 0 关闭 &lt;!-- raw HTML omitted --&gt; 1 开启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;START&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;通道开启位&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt; 0 关闭 &lt;!-- raw HTML omitted --&gt; 1 开启 &lt;!-- raw HTML omitted --&gt; 开启后硬件自动清零&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;最后，还有一个 BITER 寄存器，其结构和 CITER 平行，直接将 BITER 设置成为和 CITER 一样就可以了，但是要注意一定要设置 BITER 哦，不然会发生 DMA 设置错误。&lt;/p&gt;
&lt;p&gt;到这个时候，再看看例程，是不是觉得十分简单呢？&lt;/p&gt;</description>
    </item>
    <item>
      <title>S32K144EVB Notes 5 NVIC</title>
      <link>https://xiahualiu.github.io/posts/2017-10-17-s32k144_5/</link>
      <pubDate>Tue, 17 Oct 2017 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2017-10-17-s32k144_5/</guid>
      <description>&lt;p&gt;这一节的内容是根据对于例程的探索，了解 S32K 上的 ADC 模块的使用方法&lt;/p&gt;
&lt;h1 id=&#34;heading&#34;&gt;本节程序包含的步骤：&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;SOSC 8MHz，SPLL 160Mhz，系统时钟 80MHz，开启 RUN 模式。&lt;/li&gt;
&lt;li&gt;初始化管脚：
&lt;ul&gt;
&lt;li&gt;在 PCC 使能 Port D&lt;/li&gt;
&lt;li&gt;PTD0: GPIO output - connects to blue LED&lt;/li&gt;
&lt;li&gt;PTD15: GPIO output - connects to red LED&lt;/li&gt;
&lt;li&gt;PTD16: GPIO output - connects to green LED&lt;/li&gt;
&lt;li&gt;（因为重启后，模拟管脚不需要初始化）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;初始化 ADC：
&lt;ul&gt;
&lt;li&gt;选择 SOSCDIV2_CLK 作为功能始终并且在模块中启用它&lt;/li&gt;
&lt;li&gt;关闭模块并且关闭中断请求&lt;/li&gt;
&lt;li&gt;设置 ADC 模块为 12 位转换使用 SOSCDIV_CLK, 分频因子是 1&lt;/li&gt;
&lt;li&gt;设置取样时间是 13 ADCK 时钟周期&lt;/li&gt;
&lt;li&gt;设置软件触发转换，不适用比较功能，不使用 DMA 并且使用默认的电压值参考管脚 - 也就是 $V_{REFH}$ 和 $V_{REFL}$&lt;/li&gt;
&lt;li&gt;关闭连续转换（也就是一次转换使用一次软件触发），关闭硬件平均功能，关闭初始状态矫正。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;循环体：
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发出 ADC 转换指令给 通道 12（使用 &lt;code&gt;ADC_SC1[0]&lt;/code&gt; 作为软件触发）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待转换完成标志&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取结果并且将其转换成为 0-5000mv 的范围（对于所有的软件触发带来的结果都在 &lt;code&gt;ADC_R[0]&lt;/code&gt; 内）&lt;/li&gt;
&lt;li&gt;根据电压范围点亮 LED&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发出 ADC 转换指令读取 ADC 高参考电压（使用 &lt;code&gt;ADC_SC1[0]&lt;/code&gt; 作为软件触发）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待转换完成标志，当转换完成的时候&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取结果并且将其转换成为 0-5000mv 的范围（对于所有的软件触发带来的结果都在 &lt;code&gt;ADC_R[0]&lt;/code&gt; 内）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;heading-1&#34;&gt;代码：&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;S32K144.h&amp;#34; /* include peripheral declarations S32K144 */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;clocks_and_modes.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;ADC.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PTD15 15 &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* RED LED*/&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PTD16 16 &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* GREEN LED*/&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PTD0 0 &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* BLUE LED */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PORT_init&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
PCC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCCn[PCC_PORTD_INDEX ]&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;PCC_PCCn_CGC_MASK; &lt;span style=&#34;color:#75715e&#34;&gt;/* Enable clock for PORTD */&lt;/span&gt;
PORTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCR[PTD0] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000100&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Port D0: MUX = GPIO */&lt;/span&gt;
PORTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCR[PTD15] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000100&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Port D15: MUX = GPIO */&lt;/span&gt;
PORTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCR[PTD16] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000100&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Port D16: MUX = GPIO */&lt;/span&gt;
PTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PDDR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTD0; &lt;span style=&#34;color:#75715e&#34;&gt;/* Port D0: Data Direction= output */&lt;/span&gt;
PTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PDDR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTD15; &lt;span style=&#34;color:#75715e&#34;&gt;/* Port D15: Data Direction= output */&lt;/span&gt;
PTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PDDR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTD16; &lt;span style=&#34;color:#75715e&#34;&gt;/* Port D16: Data Direction= output */&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;WDOG_disable&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;){
WDOG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CNT&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0xD928C520&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Unlock watchdog */&lt;/span&gt;
WDOG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TOVAL&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0x0000FFFF&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Maximum timeout value */&lt;/span&gt;
WDOG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CS &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00002100&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Disable watchdog */&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;)
{
uint32_t adcResultInMv&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
WDOG_disable(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Disable WDOG*/&lt;/span&gt;
SOSC_init_8MHz(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Initialize system oscillator for 8 MHz xtal */&lt;/span&gt;
SPLL_init_160MHz(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Initialize SPLL to 160 MHz with 8 MHz SOSC */&lt;/span&gt;
NormalRUNmode_80MHz(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Init clocks: 80 MHz sysclk &amp;amp; core, 40 MHz bus, 20 MHz flash */&lt;/span&gt;
PORT_init(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Init port clocks and gpio outputs */&lt;/span&gt;
ADC_init(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Init ADC resolution 12 bit*/&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(;;) {
convertAdcChan(&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* Convert Channel AD12 to pot on EVB */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(adc_complete()&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;){} &lt;span style=&#34;color:#75715e&#34;&gt;/* Wait for conversion complete flag */&lt;/span&gt;
adcResultInMv &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; read_adc_chx(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Get channel&amp;#39;s conversion results in mv */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (adcResultInMv &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3750&lt;/span&gt;) { &lt;span style=&#34;color:#75715e&#34;&gt;/* If result &amp;gt; 3.75V */&lt;/span&gt;
PTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PSOR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTD0 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTD16; &lt;span style=&#34;color:#75715e&#34;&gt;/* turn off blue, green LEDs */&lt;/span&gt;
PTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCOR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTD15; &lt;span style=&#34;color:#75715e&#34;&gt;/* turn on red LED */&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (adcResultInMv &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2500&lt;/span&gt;) { &lt;span style=&#34;color:#75715e&#34;&gt;/* If result &amp;gt; 3.75V */&lt;/span&gt;
PTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PSOR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTD0 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTD15; &lt;span style=&#34;color:#75715e&#34;&gt;/* turn off blue, red LEDs */&lt;/span&gt;
PTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCOR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTD16; &lt;span style=&#34;color:#75715e&#34;&gt;/* turn on green LED */&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (adcResultInMv &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1250&lt;/span&gt;) { &lt;span style=&#34;color:#75715e&#34;&gt;/* If result &amp;gt; 3.75V */&lt;/span&gt;
PTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PSOR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTD15 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTD16; &lt;span style=&#34;color:#75715e&#34;&gt;/* turn off red, green LEDs */&lt;/span&gt;
PTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCOR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTD0; &lt;span style=&#34;color:#75715e&#34;&gt;/* turn on blue LED */&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
PTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PSOR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTD0 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; PTD15 &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTD16; &lt;span style=&#34;color:#75715e&#34;&gt;/* Turn off all LEDs */&lt;/span&gt;
}
convertAdcChan(&lt;span style=&#34;color:#ae81ff&#34;&gt;29&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* Convert chan 29, Vrefsh */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(adc_complete()&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;){} &lt;span style=&#34;color:#75715e&#34;&gt;/* Wait for conversion complete flag */&lt;/span&gt;
adcResultInMv &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; read_adc_chx(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Get channel&amp;#39;s conversion results in mv */&lt;/span&gt;
}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;ADC 子函数部分：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;ADC.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ADC_init&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
PCC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCCn[PCC_ADC0_INDEX] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt; PCC_PCCn_CGC_MASK; &lt;span style=&#34;color:#75715e&#34;&gt;/* Disable clock to change PCS */&lt;/span&gt;
PCC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCCn[PCC_ADC0_INDEX] &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PCC_PCCn_PCS(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* PCS=1: Select SOSCDIV2 */&lt;/span&gt;
PCC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCCn[PCC_ADC0_INDEX] &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PCC_PCCn_CGC_MASK; &lt;span style=&#34;color:#75715e&#34;&gt;/* Enable bus clock in ADC */&lt;/span&gt;
ADC0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SC1[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00001F&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* ADCH=1F: Module is disabled for conversions*/&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* AIEN=0: Interrupts are disabled */&lt;/span&gt;
ADC0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CFG1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x000000004&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* ADICLK=0: Input clk=ALTCLK1=SOSCDIV2 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* ADIV=0: Prescaler=1 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* MODE=1: 12-bit conversion */&lt;/span&gt;
ADC0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CFG2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000000C&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* SMPLTS=12(default): sample time is 13 ADC clks */&lt;/span&gt;
ADC0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SC2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000000&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* ADTRG=0: SW trigger */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* ACFE,ACFGT,ACREN=0: Compare func disabled */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* DMAEN=0: DMA disabled */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* REFSEL=0: Voltage reference pins= VREFH, VREEFL */&lt;/span&gt;
ADC0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SC3 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000000&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* CAL=0: Do not start calibration sequence */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* ADCO=0: One conversion performed */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* AVGE,AVGS=0: HW average function disabled */&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;convertAdcChan&lt;/span&gt;(uint16_t adcChan) { &lt;span style=&#34;color:#75715e&#34;&gt;/* For SW trigger mode, SC1[0] is used */&lt;/span&gt;
ADC0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SC1[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;ADC_SC1_ADCH_MASK; &lt;span style=&#34;color:#75715e&#34;&gt;/* Clear prior ADCH bits */&lt;/span&gt;
ADC0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SC1[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ADC_SC1_ADCH(adcChan); &lt;span style=&#34;color:#75715e&#34;&gt;/* Initiate Conversion*/&lt;/span&gt;
}
uint8_t &lt;span style=&#34;color:#a6e22e&#34;&gt;adc_complete&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; ((ADC0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SC1[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; ADC_SC1_COCO_MASK)&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;ADC_SC1_COCO_SHIFT); &lt;span style=&#34;color:#75715e&#34;&gt;/* Wait for completion */&lt;/span&gt;
}
uint32_t &lt;span style=&#34;color:#a6e22e&#34;&gt;read_adc_chx&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
uint16_t adc_result&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
adc_result&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;ADC0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;R[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]; &lt;span style=&#34;color:#75715e&#34;&gt;/* For SW trigger mode, R[0] is used */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; (uint32_t) ((&lt;span style=&#34;color:#ae81ff&#34;&gt;5000&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;adc_result)&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0xFFF&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* Convert result to mv for 0-5V range */&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关于程序部分，需要注意的就是 ADC 初始化过程中使用的一系列寄存器，比较多比较复杂，我在这里简单介绍一下本程序涉及的寄存器。&lt;/p&gt;
&lt;h3 id=&#34;adc-status-and-control-registers-1-adc1-sc1n&#34;&gt;ADC Status and Control Registers 1 (ADC1_SC1n)&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;ADC0-&amp;gt;SC1[n]&lt;/code&gt; 访问，n 数字对应字母 ABCDEFG&amp;hellip;P。&lt;/p&gt;
&lt;p&gt;这个寄存器一共有 16 个，在参考手册上面分别叫做 ADC1_SC1(A-P), 我刚开始看的时候对于这一点非常困惑，因为这 16 个寄存器的定义一模一样，而且只能有一个寄存器内部的配置是在工作的，最后在网上另外一款的飞思卡尔单片机中找的了为什么有平行的寄存器。这 16 个寄存器对应 16 个配置，就像是存档一样，我们知道该款 ADC 一共有 16 个通道，而由于模块的硬件因素，ADC 在同一时间只能处理一个通道中断，如果想要切换通道就要频繁切换配置，所以这里我们可以提前直接写好各个要使用到的通道的采样配置，这样在使用触发命令（trigger 和 pre-trigger）时，只要指定是按照 ADC 哪一个配置采样就可以了。&lt;/p&gt;
&lt;p&gt;这个也提醒了我，这个配置和对应的结果寄存器，也是相互对应的，也就是说这，一共有 16 个结果寄存器，也是按照 A-P 排列的，哪一个配置产生的结果就放在哪一个寄存器里面，这也就解释了为什么软件触发的结果都在 0 号寄存器里面的了，因为软件只能触发 A 配置。
（下列标题中的数字为对应的寄存器地址段，未注明的地址段为 Reserved 地址段）&lt;/p&gt;
&lt;h5 id=&#34;7---cococonversion-complete-flag&#34;&gt;7 - COCO(Conversion Complete Flag):&lt;/h5&gt;
&lt;p&gt;这是一个只能读取的寄存器，这个寄存器在转换完成的时候会置 1，当下列的某一个或者多个条件成立的时候：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比较功能已经关闭&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SC2[ACFE]=0&lt;/code&gt; 并且硬件平均功能已经关闭&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SC3[AVGE]=0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果比较结果是真的情况下，COCO 寄存器在转换完成的时候会置 1，当下列的某一个或者多个条件成立的时候：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;比较功能已经开启&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SC2[ACFE]=1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;COCO 也可以进行在选定的转换完成的时候进行置位（由 &lt;code&gt;AVGS&lt;/code&gt; 决定）如果下列的一个或者多个条件成立的时候:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;硬件的平均功能已经开启&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SC3[AVGE]=1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 &lt;code&gt;SC1A&lt;/code&gt; 中的 COCO 还会在校准序列结束后置位&lt;/p&gt;
&lt;p&gt;COCO 寄存器会在以下条件达成的时候被复位：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对应的 &lt;code&gt;SC1n&lt;/code&gt; 寄存器被写入&lt;/li&gt;
&lt;li&gt;对应的 &lt;code&gt;Rn&lt;/code&gt; 寄存器被读取&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;6---aieninterrupt-enable&#34;&gt;6 - AIEN(Interrupt Enable)&lt;/h5&gt;
&lt;p&gt;使能位，允许转换完成的时候发起中断，当此位被置 1，且当 COCO 置 1 的时候，一个中断就会被生成。&lt;/p&gt;
&lt;h5 id=&#34;4-0---adchinput-channel-select&#34;&gt;(4-0) - ADCH(Input channel select)&lt;/h5&gt;
&lt;p&gt;输入通道选择，在新的参考手册中这个一共有 6 位。在老版本的 RM 中，这个位只有 5 位，但是老版本的该寄存器地址段只有 4 位，不知道编这个 RM 的作者是想表达什么意思。&lt;br&gt;
最后我参考了一下头文件里面的声明：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define ADC_SC1_ADCH_WIDTH    5u&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;所以应该是 5 位的宽度，我们就按照老的 RM 的数据来进行解读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;00000 AD0 is selected as input.&lt;/li&gt;
&lt;li&gt;00001 AD1 is selected as input.&lt;/li&gt;
&lt;li&gt;00010 AD2 is selected as input.&lt;/li&gt;
&lt;li&gt;00011 AD3 is selected as input.&lt;/li&gt;
&lt;li&gt;00100 AD4 is selected as input.&lt;/li&gt;
&lt;li&gt;00101 AD5 is selected as input.&lt;/li&gt;
&lt;li&gt;00110 AD6 is selected as input.&lt;/li&gt;
&lt;li&gt;00111 AD7 is selected as input.&lt;/li&gt;
&lt;li&gt;01000 AD8 is selected as input.&lt;/li&gt;
&lt;li&gt;01001 AD9 is selected as input.&lt;/li&gt;
&lt;li&gt;01010 AD10 is selected as input.&lt;/li&gt;
&lt;li&gt;01011 AD11 is selected as input.&lt;/li&gt;
&lt;li&gt;01100 AD12 is selected as input.&lt;/li&gt;
&lt;li&gt;01101 AD13 is selected as input.&lt;/li&gt;
&lt;li&gt;01110 AD14 is selected as input.&lt;/li&gt;
&lt;li&gt;01111 AD15 is selected as input.&lt;/li&gt;
&lt;li&gt;10000 Reserved.&lt;/li&gt;
&lt;li&gt;10001 Reserved.&lt;/li&gt;
&lt;li&gt;10010 AD18 is selected as input.&lt;/li&gt;
&lt;li&gt;10011 AD19 is selected as input.&lt;/li&gt;
&lt;li&gt;10100 Reserved.&lt;/li&gt;
&lt;li&gt;10101 AD21 is selected as input.&lt;/li&gt;
&lt;li&gt;10110 AD22 is selected as input.&lt;/li&gt;
&lt;li&gt;10111 AD23 is selected as input.&lt;/li&gt;
&lt;li&gt;11000 ATX Force&lt;/li&gt;
&lt;li&gt;11001 ATX Sense&lt;/li&gt;
&lt;li&gt;11010 Temp Sensor&lt;/li&gt;
&lt;li&gt;11011 Band Gap&lt;/li&gt;
&lt;li&gt;11100 AD28 is selected as input.&lt;/li&gt;
&lt;li&gt;11101 VREFSH is selected as input. Voltage reference selected is determined by SC2[REFSEL].&lt;/li&gt;
&lt;li&gt;11110 VREFSL is selected as input. Voltage reference selected is determined by SC2[REFSEL].&lt;/li&gt;
&lt;li&gt;11111 Module is disabled.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只要牢记一件事就是这个寄存器如果全部取 1 的时候，相当于关闭 ADC 模块。其他的选择通道时使用 &lt;code&gt;ADC_SC1_ADCH(x)&lt;/code&gt; 这个定义在头文件的函数可以直接将通道改为对应的 ADCH 值。&lt;/p&gt;
&lt;h3 id=&#34;adc-configuration-register-1-adcx-cfg1&#34;&gt;ADC Configuration Register 1 (ADCx_CFG1)&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;ADC0-&amp;gt;CFG1&lt;/code&gt; 访问。主要涉及的内容有，ADC 工作模式，时钟源，时钟分频。&lt;/p&gt;
&lt;p&gt;（下列标题中的数字为对应的寄存器地址段，未注明的地址段为保留 0 段）&lt;/p&gt;
&lt;h5 id=&#34;6-5---adivclock-divide-select&#34;&gt;(6-5) - ADIV(Clock Divide Select)&lt;/h5&gt;
&lt;p&gt;选择 ADC 的时钟分频，用于产生 ADCK 内部时钟。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;00 时钟分频为 1 ，时钟速度就是输入时钟的速度&lt;/li&gt;
&lt;li&gt;01 时钟分频为 2 ，时钟速度就是输入时钟的 1/2&lt;/li&gt;
&lt;li&gt;10 时钟分频为 4 ，时钟速度就是输入时钟的 1/4&lt;/li&gt;
&lt;li&gt;11 时钟分频为 8 ，时钟速度就是输入时钟的 1/8&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;3-2---modeconversion-mode-selection&#34;&gt;(3-2) - MODE(Conversion mode selection)&lt;/h5&gt;
&lt;p&gt;选择 ADC 的分辨率。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;00 8-bit 转换&lt;/li&gt;
&lt;li&gt;01 12-bit 转换&lt;/li&gt;
&lt;li&gt;10 10-bit 转换&lt;/li&gt;
&lt;li&gt;11 Reserved&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;1-0---adiclkinput-clock-select&#34;&gt;(1-0) - ADICLK(Input Clock Select)&lt;/h5&gt;
&lt;p&gt;选择输入时钟源来产生内部时钟 ADCK。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;00 Alternate clock 1 (ADC_ALTCLK1)&lt;/li&gt;
&lt;li&gt;01 Alternate clock 2 (ADC_ALTCLK2)&lt;/li&gt;
&lt;li&gt;10 Alternate clock 3 (ADC_ALTCLK3)&lt;/li&gt;
&lt;li&gt;11 Alternate clock 4 (ADC_ALTCLK4)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;adc-configuration-register-2-adcx-cfg2&#34;&gt;ADC Configuration Register 2 (ADCx_CFG2)&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;ADC0-&amp;gt;CFG2&lt;/code&gt; 访问。 主要涉及的内容有，在“长取样模式”下选择取样时长。&lt;/p&gt;
&lt;h5 id=&#34;7-0-smpltssample-time-select&#34;&gt;(7-0) SMPLTS(Sample Time Select)&lt;/h5&gt;
&lt;p&gt;选其一系列从 2-256 个 ADCK 周期的取样时长，在这个 8 位的寄存器中写的值加一就是相应的取样时长，长的取样时间可以有效提高精确性，但是短的取样时间可以加快取样速度并且减少取样消耗的功率。在单次采样的时候，建议采用长时间采样，如果是连续采样，建议选择一个较短的采样时间。&lt;/p&gt;
&lt;h3 id=&#34;adc-data-result-register-adcx-rn&#34;&gt;ADC Data Result Register (ADCx_Rn)&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;ADC0-&amp;gt;R[n]&lt;/code&gt; 访问。
这个就是 ADC 结果寄存器了，跟配置寄存器对应，使用哪一个配置的 &lt;code&gt;SC[n]&lt;/code&gt;, 结果就保存在 对应的 &lt;code&gt;R[n]&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id=&#34;11-0-data-result-d&#34;&gt;(11-0) Data result (D)&lt;/h5&gt;
&lt;p&gt;一共有 12 位，在使用 12-bit 转换的时候就是全部使用，在使用 10-bit 或者 8-bit 转换的时候只使用到了最低的 10,8 位。&lt;/p&gt;
&lt;h3 id=&#34;compare-value-registers-adcx-cvn&#34;&gt;Compare Value Registers (ADCx_CVn)&lt;/h3&gt;
&lt;p&gt;这个的寄存器配置和 Rn 一样，唯一的区别就是里面存放的是一个需要比较的数值。使用这个寄存器需要打开 ADC 的比较功能，也即是 &lt;code&gt;SC2[ACREN]=1&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;status-and-control-register-2-adcx-sc2&#34;&gt;Status and Control Register 2 (ADCx_SC2)&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;ADC0-&amp;gt;SC2&lt;/code&gt; 访问。
这个寄存器虽然叫 SC2，但是和 SC1 完全不一样，每个 ADC 只有 1 个配置。它涉及的内容有：转换状态显示，软/硬转换触发选择，以及比较功能的开关，还有超级比较功能开关（可以比较范围之外的电压），比较模式的电压范围，DMA 功能开启，参考电压的选择。&lt;/p&gt;
&lt;p&gt;具体寄存器内容请查阅 RM。太多了不好写。&lt;/p&gt;
&lt;h3 id=&#34;status-and-control-register-3-adcx-sc3&#34;&gt;Status and Control Register 3 (ADCx_SC3)&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;ADC0-&amp;gt;SC3&lt;/code&gt; 访问。
本寄存器主要涉及，校准序列的开启，连续转换开关的开启，硬件平均功能的开启，硬件平均采取的被平均取样量选择。&lt;/p&gt;
&lt;p&gt;其他的寄存器都和校准有关系，但是我感觉校准现在也用不太到，所以准备到时候使用到的时候在进行研究。&lt;/p&gt;
&lt;p&gt;使用过程，如果使用软件出发的时候就只能使用 &lt;code&gt;SC1A&lt;/code&gt; 配置，因为软件触发源是向 &lt;code&gt;SC1A&lt;/code&gt; 写入的时候自动触发 ADC 转换。&lt;/p&gt;
&lt;p&gt;读取 ADC ，如果没有中断的话就是等待对应的配置 COCO 位变成 1 之后再读取对应的 &lt;code&gt;R[n]&lt;/code&gt; 里面的数值，如果有中断的话就可以直接在中断服务程序中取下对应的 &lt;code&gt;R[n]&lt;/code&gt; 值。&lt;/p&gt;</description>
    </item>
    <item>
      <title>S32K144EVB Notes 4</title>
      <link>https://xiahualiu.github.io/posts/2017-10-16-s32k144_4/</link>
      <pubDate>Mon, 16 Oct 2017 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2017-10-16-s32k144_4/</guid>
      <description>&lt;p&gt;这一节的主要内容是在（三）的基础上实现 NVIC 中断控制和处理&lt;/p&gt;
&lt;h1 id=&#34;heading&#34;&gt;本节程序包含的步骤：&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;初始化 NVIC 需要写入三次：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;清楚所有的悬置中断（以防有）, 写 1 到 ICPR(Interrupt Clear Pending Register)&lt;/li&gt;
&lt;li&gt;开启需要的中断位, 写 1 到需要的 ISER(Interrupt Set Enable Register) 位&lt;/li&gt;
&lt;li&gt;设置中断优先级, 在 IP(Interrupt Priority register) 中写 0 - 15 优先级，该芯片的IP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化 PORT D 使之成为 GPIO output 状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化 SOSC 为 8MHz：
-初始化需要的 SOSC 分频器&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置范围，低增益，参考晶振为内部输入&lt;/li&gt;
&lt;li&gt;确认 SOSC 状态寄存器解锁&lt;/li&gt;
&lt;li&gt;在 SOSCCSR 中使能&lt;/li&gt;
&lt;li&gt;等待 SOSCCSR_SOSCVLD 有效位等于 1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化 SPLL 到 160MHz 使用 8MHz 的 SOSC&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确认 SPLL 处于关闭状态&lt;/li&gt;
&lt;li&gt;初始化 SPLL 的分频器&lt;/li&gt;
&lt;li&gt;初始化 SPLL Pef 分频器和 SPLL 倍率&lt;/li&gt;
&lt;li&gt;确认 SPLLCSR 解锁&lt;/li&gt;
&lt;li&gt;使能 SPLL&lt;/li&gt;
&lt;li&gt;等待 SPLL 有效&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化 LPIT0 通道 0:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 PCC 中选择时钟为 SPLL_DIV2_CLK&lt;/li&gt;
&lt;li&gt;在 PCC 中开启 LPIT0 Gate&lt;/li&gt;
&lt;li&gt;在 MCR 中开启 M_EN 开启 LPIT0 模块&lt;/li&gt;
&lt;li&gt;在 MIER 寄存器中开启中断功能&lt;/li&gt;
&lt;li&gt;在 TMR[n].TVAL 和 TMR[n].TCTRL (也可以在 TVAL0 或者 TCTRL0) 中设置初值和工作模式并开启T_EN&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开启 RUN 模式给 SPLL&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化 COREDIV, BUSDIV, SLOWDIV 给目标频率&lt;/li&gt;
&lt;li&gt;将系统时钟源输出至 SPLL&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LPIT_0 通道 0 NVIC 中断处理程序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加中断计数器&lt;/li&gt;
&lt;li&gt;翻转 GPIO PTD0 输出&lt;/li&gt;
&lt;li&gt;清空通道中断标志位 MSR 中的 TIF0 位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;heading-1&#34;&gt;代码:&lt;/h1&gt;
&lt;h3 id=&#34;heading-2&#34;&gt;主体：&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;S32K144.h&amp;#34; /* include peripheral declarations S32K144 */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;clocks_and_modes.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; idle_counter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* main loop idle counter */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; lpit0_ch0_flag_counter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* LPIT0 chan 0 timeout counter */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NVIC_init_IRQs&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
FSL_NVIC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;ICPR[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;48&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* IRQ48-LPIT0 ch0: clr any pending IRQ*/&lt;/span&gt;
FSL_NVIC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;ISER[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;48&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;32&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* IRQ48-LPIT0 ch0: enable IRQ */&lt;/span&gt;
FSL_NVIC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;IP[&lt;span style=&#34;color:#ae81ff&#34;&gt;48&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0x0A&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* IRQ48-LPIT0 ch0: priority 10 of 0-15*/&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PORT_init&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
PCC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; PCCn[PCC_PORTD_INDEX] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PCC_PCCn_CGC_MASK; &lt;span style=&#34;color:#75715e&#34;&gt;/* Enable clock for PORT D */&lt;/span&gt;
PTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PDDR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Port D0: Data Direction= output */&lt;/span&gt;
PORTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCR[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000100&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Port D0: MUX = ALT1, GPIO (to blue LED on EVB) */&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LPIT0_init&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
PCC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCCn[PCC_LPIT0_INDEX] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PCC_PCCn_PCS(&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;); &lt;span style=&#34;color:#75715e&#34;&gt;/* Clock Src = 6 (SPLL2_DIV2_CLK)*/&lt;/span&gt;
PCC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCCn[PCC_LPIT0_INDEX] &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PCC_PCCn_CGC_MASK; &lt;span style=&#34;color:#75715e&#34;&gt;/* Enable clk to LPIT0 regs */&lt;/span&gt;
LPIT0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;MCR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000001&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* DBG_EN-0: Timer chans stop in Debug mode */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* DOZE_EN=0: Timer chans are stopped in DOZE mode */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* SW_RST=0: SW reset does not reset timer chans, regs */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* M_CEN=1: enable module clk (allow writing other LPIT0 regs) */&lt;/span&gt;
LPIT0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;MIER &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000001&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* TIE0=1: Timer Interrupt Enabled fot Chan 0 */&lt;/span&gt;
LPIT0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TVAL0 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;80000000&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Chan 0 Timeout period: 80M clocks */&lt;/span&gt;
LPIT0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TCTRL0 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000001&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* T_EN=1: Timer channel is enabled */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* CHAIN=0: channel chaining is disabled */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* MODE=0: 32 periodic counter mode */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* TSOT=0: Timer decrements immediately based on restart */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* TSOI=0: Timer does not stop after timeout */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* TROT=0 Timer will not reload on trigger */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* TRG_SRC=0: External trigger source */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* TRG_SEL=0: Timer chan 0 trigger source is selected*/&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;WDOG_disable&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;){
WDOG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CNT&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0xD928C520&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/*Unlock watchdog*/&lt;/span&gt;
WDOG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TOVAL&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0x0000FFFF&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/*Maximum timeout value*/&lt;/span&gt;
WDOG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CS &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00002100&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/*Disable watchdog*/&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
WDOG_disable();
PORT_init(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Configure ports */&lt;/span&gt;
SOSC_init_8MHz(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Initialize system oscillator for 8 MHz xtal */&lt;/span&gt;
SPLL_init_160MHz(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Initialize SPLL to 160 MHz with 8 MHz SOSC */&lt;/span&gt;
NormalRUNmode_80MHz(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Init clocks: 80 MHz sysclk &amp;amp; core, 40 MHz bus, 20 MHz flash */&lt;/span&gt;
NVIC_init_IRQs(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Enable desired interrupts and priorities */&lt;/span&gt;
LPIT0_init(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Initialize PIT0 for 1 second timeout */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (;;) {
idle_counter&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;;
}
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LPIT0_Ch0_IRQHandler&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
lpit0_ch0_flag_counter&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Increment LPIT0 timeout counter */&lt;/span&gt;
PTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PTOR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Toggle output on port D0 (blue LED) */&lt;/span&gt;
LPIT0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;MSR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; LPIT_MSR_TIF0_MASK; &lt;span style=&#34;color:#75715e&#34;&gt;/* Clear LPIT0 timer flag 0 */&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;heading-3&#34;&gt;使用的子函数文件：&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;S32K144.h&amp;#34; /* include peripheral declarations S32K144 */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;clocks_and_modes.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SOSC_init_8MHz&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SOSCDIV&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000101&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* SOSCDIV1 &amp;amp; SOSCDIV2 =1: divide by 1 */&lt;/span&gt;
SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SOSCCFG&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000024&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Range=2: Medium freq (SOSC between 1MHz-8MHz)*/&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* HGO=0: Config xtal osc for low power */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* EREFS=1: Input is external XTAL */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SOSCCSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; SCG_SOSCCSR_LK_MASK); &lt;span style=&#34;color:#75715e&#34;&gt;/* Ensure SOSCCSR unlocked */&lt;/span&gt;
SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SOSCCSR&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000001&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* LK=0: SOSCCSR can be written */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* SOSCCMRE=0: OSC CLK monitor IRQ if enabled */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* SOSCCM=0: OSC CLK monitor disabled */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* SOSCERCLKEN=0: Sys OSC 3V ERCLK output clk disabled */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* SOSCLPEN=0: Sys OSC disabled in VLP modes */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* SOSCSTEN=0: Sys OSC disabled in Stop modes */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* SOSCEN=1: Enable oscillator */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;(SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SOSCCSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; SCG_SOSCCSR_SOSCVLD_MASK)); &lt;span style=&#34;color:#75715e&#34;&gt;/* Wait for sys OSC clk valid */&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SPLL_init_160MHz&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SPLLCSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; SCG_SPLLCSR_LK_MASK); &lt;span style=&#34;color:#75715e&#34;&gt;/* Ensure SPLLCSR unlocked */&lt;/span&gt;
SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SPLLCSR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000000&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* SPLLEN=0: SPLL is disabled (default) */&lt;/span&gt;
SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SPLLDIV &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000302&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* SPLLDIV1 divide by 2; SPLLDIV2 divide by 4 */&lt;/span&gt;
SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SPLLCFG &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00180000&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* PREDIV=0: Divide SOSC_CLK by 0+1=1 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* MULT=24: Multiply sys pll by 4+24=40 */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* SPLL_CLK = 8MHz / 1 * 40 / 2 = 160 MHz */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SPLLCSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; SCG_SPLLCSR_LK_MASK); &lt;span style=&#34;color:#75715e&#34;&gt;/* Ensure SPLLCSR unlocked */&lt;/span&gt;
SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SPLLCSR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000001&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* LK=0: SPLLCSR can be written */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* SPLLCMRE=0: SPLL CLK monitor IRQ if enabled */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* SPLLCM=0: SPLL CLK monitor disabled */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* SPLLSTEN=0: SPLL disabled in Stop modes */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* SPLLEN=1: Enable SPLL */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;(SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SPLLCSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; SCG_SPLLCSR_SPLLVLD_MASK)); &lt;span style=&#34;color:#75715e&#34;&gt;/* Wait for SPLL valid */&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NormalRUNmode_80MHz&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) { &lt;span style=&#34;color:#75715e&#34;&gt;/* Change to normal RUN mode with 8MHz SOSC, 80 MHz PLL*/&lt;/span&gt;
SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;RCCR&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;SCG_RCCR_SCS(&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;) &lt;span style=&#34;color:#75715e&#34;&gt;/* PLL as clock source*/&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;SCG_RCCR_DIVCORE(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;b01) &lt;span style=&#34;color:#75715e&#34;&gt;/* DIVCORE=1, div. by 2: Core clock = 160/2 MHz = 80 MHz*/&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;SCG_RCCR_DIVBUS(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;b01) &lt;span style=&#34;color:#75715e&#34;&gt;/* DIVBUS=1, div. by 2: bus clock = 40 MHz*/&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;SCG_RCCR_DIVSLOW(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;b10); &lt;span style=&#34;color:#75715e&#34;&gt;/* DIVSLOW=2, div. by 3: SCG slow, flash clock= 26 2/3 MHz*/&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (((SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; SCG_CSR_SCS_MASK) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; SCG_CSR_SCS_SHIFT ) &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;) {}
&lt;span style=&#34;color:#75715e&#34;&gt;/* Wait for sys clk src = SPLL */&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;heading-4&#34;&gt;代码详解：&lt;/h3&gt;
&lt;p&gt;这个程序代码和上一个例程给出的代码非常类似，只增加了 LPIT0 模块中的 MIER 寄存器修改和 NVIC 的一个初始化和 IRQ Handler 函数。&lt;/p&gt;
&lt;p&gt;在这里我想详细介绍一下本款芯片内置的 &lt;strong&gt;NVIC&lt;/strong&gt;(Nested Vectored Interrupt Controller) 的工作原理，该模块被内置于内核之中，在 S32K 的参考手册中，而且在最新的参考手册中，这部分内容被删去了，不知道是为什么，导致我根本无法找到相关资料，浪费了我好几个小时的时间，最后还是在老版本的参考手册中找到了相关的内容。&lt;/p&gt;
&lt;p&gt;NVIC 全名是&lt;strong&gt;中断向量嵌套控制器&lt;/strong&gt;，从这个名字上我们可以看出来，这是个控制中断的优先级的模块，它的主要功能是接收其他中断请求，判断各个中断的优先级，然后向内核发起中断服务。在 ARM Cortex M4 这个芯片中，NVIC 一共有 256 路，支持外接 256 个中断源，但是在 S32K 中，仅仅用到了 123 个中断通道，而每一个中断发生端口，都对应着一个 IRQ 值，这个值是固定的，就像是 IP 地址一样，用于区分各个中断请求的来源，而每一个 IRQ 值呢，又对应一个中断的优先级，但是优先级对应的 IPR 寄存器，只有高四位对应优先级，也就是优先级只有 16 个等级（0 - 15），优先级数值越低优先级越高，高优先级的中断可以打断低的优先级中断，从而实现中断嵌套，而优先级相等的两个中断请求，则无法打断中断。&lt;/p&gt;
&lt;p&gt;这个地方有点意思啊，在 S32K 中的 IPR 只有高四位对应优先级，那低四位是干嘛的呢，这里就要谈一谈优先级组别的问题了。以下内容仅供想要深入理解的人查看，在 S32 IDE 中，修改 IPR 只能给其赋值 0 - 15。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其实在 IPR 寄存器中，每个中断对应 &lt;strong&gt;8&lt;/strong&gt; 个位，这 8 个位可以分割成为&lt;strong&gt;两个&lt;/strong&gt;位段（[1;7]或者[2;6]或者[3;5]或者[4;4]一直到[7;1]）其中，高的位段，被称之为&lt;strong&gt;组优先级&lt;/strong&gt;，低的位段，被称之为&lt;strong&gt;子优先级&lt;/strong&gt;。最常见的做法就是如 S32K 这样，4 位对应组优先级，4 位对应子优先级，这样会获得 &lt;strong&gt;16 个组中断等级和 16 个子中断等级&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-10-02-S32K144_4/ipr.png&#34; alt=&#34;ipr.png&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;heading-5&#34;&gt;组优先级和子优先级的作用：&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;即高的组优先级中断（数值低）可以中断低的组优先级（数值高）中断的，实现中断嵌套。&lt;/li&gt;
&lt;li&gt;组优先级一样的中断，子优先级高的不能中断低的组优先级中断，新中断等待。&lt;/li&gt;
&lt;li&gt;两个中断同时发生，组优先级高的可以优先进行；组优先级相同的中断同时发生，根据子优先级的高低排队进行中断。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;nvic-&#34;&gt;NVIC 中断向量表：&lt;/h5&gt;
&lt;p&gt;NVIC 的每个中断都有一个向量值，和 IRQ 一样，一个中断的 IRQ 值加 16 就是该中断的向量值。在 IDE 中，中断有关的 &lt;code&gt;ICPR&lt;/code&gt; &lt;code&gt;ISER&lt;/code&gt; 寄存器都是一个数组，每个元素都是 32 位的无符号整形，数组有 4 个，一共是 128 位，也就是说，要打开 IRQ 值为 48 的 LPIT Channel 0 中断通道，要 &lt;code&gt;FSL_NVIC-&amp;gt;ISER[1] |= 1&amp;lt;&amp;lt; (48 % 32);&lt;/code&gt; 很反人类的设定，要注意。&lt;/p&gt;
&lt;p&gt;内核中断的 IRQ，在表中并没有给出，但是在实际运用中要使用内核中断该怎么办呢，这时候我们可以按照 向量值减去 16 的法则进行计算 IRQ，最后的实际 IRQ 值都是负的，譬如 Systick 中断，对应的 IRQ 值为 -1。在配置的时候，对应的数组下标为负。&lt;/p&gt;
&lt;p&gt;最后，在中断服务程序结束后，一定要清中断标志位，中断标志位不在 NVIC 的寄存器中，而在各个中断发生源的寄存器中，大家要注意。&lt;/p&gt;
&lt;h3 id=&#34;-s32k144--irq-&#34;&gt;附录: S32K144 的 IRQ 表：&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/**
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @brief Defines the Interrupt Numbers definitions
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * This enumeration is used to configure the interrupts.
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; *
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * Implements : IRQn_Type_Class
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt;
{
  &lt;span style=&#34;color:#75715e&#34;&gt;/* Auxiliary constants */&lt;/span&gt;
  NotAvail_IRQn                &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;128&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Not available device specific interrupt */&lt;/span&gt;

  &lt;span style=&#34;color:#75715e&#34;&gt;/* Core interrupts */&lt;/span&gt;
  NonMaskableInt_IRQn          &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;14&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Non Maskable Interrupt */&lt;/span&gt;
  HardFault_IRQn               &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;13&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Cortex-M4 SV Hard Fault Interrupt */&lt;/span&gt;
  MemoryManagement_IRQn        &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Cortex-M4 Memory Management Interrupt */&lt;/span&gt;
  BusFault_IRQn                &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;11&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Cortex-M4 Bus Fault Interrupt */&lt;/span&gt;
  UsageFault_IRQn              &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Cortex-M4 Usage Fault Interrupt */&lt;/span&gt;
  SVCall_IRQn                  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;,               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Cortex-M4 SV Call Interrupt */&lt;/span&gt;
  DebugMonitor_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;,               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Cortex-M4 Debug Monitor Interrupt */&lt;/span&gt;
  PendSV_IRQn                  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Cortex-M4 Pend SV Interrupt */&lt;/span&gt;
  SysTick_IRQn                 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Cortex-M4 System Tick Interrupt */&lt;/span&gt;

  &lt;span style=&#34;color:#75715e&#34;&gt;/* Device specific interrupts */&lt;/span&gt;
  DMA0_IRQn                    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0u&lt;/span&gt;,               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; DMA channel 0 transfer complete */&lt;/span&gt;
  DMA1_IRQn                    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1u&lt;/span&gt;,               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; DMA channel 1 transfer complete */&lt;/span&gt;
  DMA2_IRQn                    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2u&lt;/span&gt;,               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; DMA channel 2 transfer complete */&lt;/span&gt;
  DMA3_IRQn                    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3u&lt;/span&gt;,               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; DMA channel 3 transfer complete */&lt;/span&gt;
  DMA4_IRQn                    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4u&lt;/span&gt;,               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; DMA channel 4 transfer complete */&lt;/span&gt;
  DMA5_IRQn                    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;5u&lt;/span&gt;,               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; DMA channel 5 transfer complete */&lt;/span&gt;
  DMA6_IRQn                    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6u&lt;/span&gt;,               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; DMA channel 6 transfer complete */&lt;/span&gt;
  DMA7_IRQn                    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;7u&lt;/span&gt;,               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; DMA channel 7 transfer complete */&lt;/span&gt;
  DMA8_IRQn                    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;8u&lt;/span&gt;,               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; DMA channel 8 transfer complete */&lt;/span&gt;
  DMA9_IRQn                    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;9u&lt;/span&gt;,               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; DMA channel 9 transfer complete */&lt;/span&gt;
  DMA10_IRQn                   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; DMA channel 10 transfer complete */&lt;/span&gt;
  DMA11_IRQn                   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;11u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; DMA channel 11 transfer complete */&lt;/span&gt;
  DMA12_IRQn                   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;12u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; DMA channel 12 transfer complete */&lt;/span&gt;
  DMA13_IRQn                   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;13u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; DMA channel 13 transfer complete */&lt;/span&gt;
  DMA14_IRQn                   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;14u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; DMA channel 14 transfer complete */&lt;/span&gt;
  DMA15_IRQn                   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;15u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; DMA channel 15 transfer complete */&lt;/span&gt;
  DMA_Error_IRQn               &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;16u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; DMA error interrupt channels 0-15 */&lt;/span&gt;
  MCM_IRQn                     &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;17u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FPU sources */&lt;/span&gt;
  FTFC_IRQn                    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;18u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTFC Command complete */&lt;/span&gt;
  Read_Collision_IRQn          &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;19u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTFC Read collision */&lt;/span&gt;
  LVD_LVW_IRQn                 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;20u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; PMC Low voltage detect interrupt */&lt;/span&gt;
  FTFC_Fault_IRQn              &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;21u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTFC Double bit fault detect */&lt;/span&gt;
  WDOG_EWM_IRQn                &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;22u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Single interrupt vector for WDOG and EWM */&lt;/span&gt;
  RCM_IRQn                     &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;23u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; RCM Asynchronous Interrupt */&lt;/span&gt;
  LPI2C0_Master_IRQn           &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;24u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; LPI2C0 Master Interrupt */&lt;/span&gt;
  LPI2C0_Slave_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;25u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; LPI2C0 Slave Interrupt */&lt;/span&gt;
  LPSPI0_IRQn                  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;26u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; LPSPI0 Interrupt */&lt;/span&gt;
  LPSPI1_IRQn                  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;27u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; LPSPI1 Interrupt */&lt;/span&gt;
  LPSPI2_IRQn                  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;28u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; LPSPI2 Interrupt */&lt;/span&gt;
  LPUART0_RxTx_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;31u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; LPUART0 Transmit / Receive Interrupt */&lt;/span&gt;
  LPUART1_RxTx_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;33u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; LPUART1 Transmit / Receive  Interrupt */&lt;/span&gt;
  LPUART2_RxTx_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;35u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; LPUART2 Transmit / Receive  Interrupt */&lt;/span&gt;
  ADC0_IRQn                    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;39u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; ADC0 interrupt request. */&lt;/span&gt;
  ADC1_IRQn                    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;40u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; ADC1 interrupt request. */&lt;/span&gt;
  CMP0_IRQn                    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;41u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; CMP0 interrupt request */&lt;/span&gt;
  ERM_single_fault_IRQn        &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;44u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; ERM single bit error correction */&lt;/span&gt;
  ERM_double_fault_IRQn        &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;45u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; ERM double bit error non-correctable */&lt;/span&gt;
  RTC_IRQn                     &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;46u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; RTC alarm interrupt */&lt;/span&gt;
  RTC_Seconds_IRQn             &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;47u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; RTC seconds interrupt */&lt;/span&gt;
  LPIT0_Ch0_IRQn               &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;48u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; LPIT0 channel 0 overflow interrupt */&lt;/span&gt;
  LPIT0_Ch1_IRQn               &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;49u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; LPIT0 channel 1 overflow interrupt */&lt;/span&gt;
  LPIT0_Ch2_IRQn               &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;50u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; LPIT0 channel 2 overflow interrupt */&lt;/span&gt;
  LPIT0_Ch3_IRQn               &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;51u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; LPIT0 channel 3 overflow interrupt */&lt;/span&gt;
  PDB0_IRQn                    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;52u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; PDB0 interrupt */&lt;/span&gt;
  SCG_IRQn                     &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;57u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; SCG bus interrupt request */&lt;/span&gt;
  LPTMR0_IRQn                  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;58u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; LPTIMER interrupt request */&lt;/span&gt;
  PORTA_IRQn                   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;59u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Port A pin detect interrupt */&lt;/span&gt;
  PORTB_IRQn                   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;60u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Port B pin detect interrupt */&lt;/span&gt;
  PORTC_IRQn                   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;61u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Port C pin detect interrupt */&lt;/span&gt;
  PORTD_IRQn                   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;62u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Port D pin detect interrupt */&lt;/span&gt;
  PORTE_IRQn                   &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;63u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Port E pin detect interrupt */&lt;/span&gt;
  SWI_IRQn                     &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;64u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Software interrupt */&lt;/span&gt;
  PDB1_IRQn                    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;68u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; PDB1 interrupt */&lt;/span&gt;
  FLEXIO_IRQn                  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;69u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FlexIO Interrupt */&lt;/span&gt;
  CAN0_ORed_IRQn               &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;78u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; CAN0 OR&amp;#39;ed [Bus Off OR Transmit Warning OR Receive Warning] */&lt;/span&gt;
  CAN0_Error_IRQn              &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;79u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; CAN0 Interrupt indicating that errors were detected on the CAN bus */&lt;/span&gt;
  CAN0_Wake_Up_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;80u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; CAN0 Interrupt asserted when Pretended Networking operation is enabled, and a valid message matches the selected filter criteria during Low Power mode */&lt;/span&gt;
  CAN0_ORed_0_15_MB_IRQn       &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;81u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; CAN0 OR&amp;#39;ed Message buffer (0-15) */&lt;/span&gt;
  CAN0_ORed_16_31_MB_IRQn      &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;82u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; CAN0 OR&amp;#39;ed Message buffer (16-31) */&lt;/span&gt;
  CAN1_ORed_IRQn               &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;85u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; CAN1 OR&amp;#39;ed [Bus Off OR Transmit Warning OR Receive Warning] */&lt;/span&gt;
  CAN1_Error_IRQn              &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;86u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; CAN1 Interrupt indicating that errors were detected on the CAN bus */&lt;/span&gt;
  CAN1_ORed_0_15_MB_IRQn       &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;88u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; CAN1 OR&amp;#39;ed Interrupt for Message buffer (0-15) */&lt;/span&gt;
  CAN2_ORed_IRQn               &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;92u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; CAN2 OR&amp;#39;ed [Bus Off OR Transmit Warning OR Receive Warning] */&lt;/span&gt;
  CAN2_Error_IRQn              &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;93u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; CAN2 Interrupt indicating that errors were detected on the CAN bus */&lt;/span&gt;
  CAN2_ORed_0_15_MB_IRQn       &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;95u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; CAN2 OR&amp;#39;ed Message buffer (0-15) */&lt;/span&gt;
  FTM0_Ch0_Ch1_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;99u&lt;/span&gt;,              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM0 Channel 0 and 1 interrupt */&lt;/span&gt;
  FTM0_Ch2_Ch3_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;100u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM0 Channel 2 and 3 interrupt */&lt;/span&gt;
  FTM0_Ch4_Ch5_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;101u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM0 Channel 4 and 5 interrupt */&lt;/span&gt;
  FTM0_Ch6_Ch7_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;102u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM0 Channel 6 and 7 interrupt */&lt;/span&gt;
  FTM0_Fault_IRQn              &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;103u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM0 Fault interrupt */&lt;/span&gt;
  FTM0_Ovf_Reload_IRQn         &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;104u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM0 Counter overflow and Reload interrupt */&lt;/span&gt;
  FTM1_Ch0_Ch1_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;105u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM1 Channel 0 and 1 interrupt */&lt;/span&gt;
  FTM1_Ch2_Ch3_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;106u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM1 Channel 2 and 3 interrupt */&lt;/span&gt;
  FTM1_Ch4_Ch5_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;107u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM1 Channel 4 and 5 interrupt */&lt;/span&gt;
  FTM1_Ch6_Ch7_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;108u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM1 Channel 6 and 7 interrupt */&lt;/span&gt;
  FTM1_Fault_IRQn              &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;109u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM1 Fault interrupt */&lt;/span&gt;
  FTM1_Ovf_Reload_IRQn         &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;110u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM1 Counter overflow and Reload interrupt */&lt;/span&gt;
  FTM2_Ch0_Ch1_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;111u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM2 Channel 0 and 1 interrupt */&lt;/span&gt;
  FTM2_Ch2_Ch3_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;112u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM2 Channel 2 and 3 interrupt */&lt;/span&gt;
  FTM2_Ch4_Ch5_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;113u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM2 Channel 4 and 5 interrupt */&lt;/span&gt;
  FTM2_Ch6_Ch7_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;114u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM2 Channel 6 and 7 interrupt */&lt;/span&gt;
  FTM2_Fault_IRQn              &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;115u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM2 Fault interrupt */&lt;/span&gt;
  FTM2_Ovf_Reload_IRQn         &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;116u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM2 Counter overflow and Reload interrupt */&lt;/span&gt;
  FTM3_Ch0_Ch1_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;117u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM3 Channel 0 and 1 interrupt */&lt;/span&gt;
  FTM3_Ch2_Ch3_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;118u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM3 Channel 2 and 3 interrupt */&lt;/span&gt;
  FTM3_Ch4_Ch5_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;119u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM3 Channel 4 and 5 interrupt */&lt;/span&gt;
  FTM3_Ch6_Ch7_IRQn            &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;120u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM3 Channel 6 and 7 interrupt */&lt;/span&gt;
  FTM3_Fault_IRQn              &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;121u&lt;/span&gt;,             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM3 Fault interrupt */&lt;/span&gt;
  FTM3_Ovf_Reload_IRQn         &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;122u&lt;/span&gt;              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; FTM3 Counter overflow and Reload interrupt */&lt;/span&gt;
} IRQn_Type;

&lt;span style=&#34;color:#75715e&#34;&gt;/*!
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; * @}
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt; */&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;/* end of group Interrupt_vector_numbers_S32K144 */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之前找内核那几个中断的 IRQn 找的好久，最后在头文件里面发现了这个表，在这里就先记录下来方便以后的查阅。&lt;/p&gt;</description>
    </item>
    <item>
      <title>S32K144EVB Notes 3 Clock Configuration Continue</title>
      <link>https://xiahualiu.github.io/posts/2017-10-02-s32k144_3/</link>
      <pubDate>Mon, 02 Oct 2017 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2017-10-02-s32k144_3/</guid>
      <description>&lt;p&gt;让我们继续上一节的内容&lt;/p&gt;
&lt;h3 id=&#34;fast-irc-control-status-register-scg-firccsr&#34;&gt;Fast IRC Control Status Register (SCG_FIRCCSR)&lt;/h3&gt;
&lt;p&gt;这个寄存器展示并且控制 FIRC 的工作状态&lt;/p&gt;
&lt;h3 id=&#34;fast-irc-divide-register-scg-fircdiv&#34;&gt;Fast IRC Divide Register (SCG_FIRCDIV)&lt;/h3&gt;
&lt;p&gt;这个寄存器控制 FIRC 的分频器的值&lt;/p&gt;
&lt;h3 id=&#34;fast-irc-configuration-register-scg-firccfg&#34;&gt;Fast IRC Configuration Register (SCG_FIRCCFG)&lt;/h3&gt;
&lt;p&gt;这个寄存器控制 FIRC 的基础设置，不能在 FIRC 开启的时候修改&lt;/p&gt;
&lt;h3 id=&#34;system-pll-control-status-register-scg-spllcsr&#34;&gt;System PLL Control Status Register (SCG_SPLLCSR)&lt;/h3&gt;
&lt;h3 id=&#34;system-pll-divide-register-scg-splldiv&#34;&gt;System PLL Divide Register (SCG_SPLLDIV)&lt;/h3&gt;
&lt;h3 id=&#34;system-pll-configuration-register-scg-spllcfg&#34;&gt;System PLL Configuration Register (SCG_SPLLCFG)&lt;/h3&gt;
&lt;p&gt;以上的几个寄存器基本设置都类似，但是具体到写程序的时候，一定要对照寄存器的表来写，因为他们之间都有一些不同&lt;/p&gt;
&lt;h2 id=&#34;-scg-&#34;&gt;不同工作模式中 SCG 的工作流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;启动的时候，’Reset’ 会直接传递给 Run 模式下的 FIRC，Run 模式下 FIRC，SOSC，SPLL，SIRC 共同工作，可以互相传递时钟&lt;/li&gt;
&lt;li&gt;启动完成后，如果单片机进入 &lt;strong&gt;High Speed Mode&lt;/strong&gt; 则会直接将 FIRC 时钟和 SPLL 相互传递&lt;/li&gt;
&lt;li&gt;启动完成后，如果单片机进入 &lt;strong&gt;Very Slow Power Mode&lt;/strong&gt; 则只启用 SIRC 时钟。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;heading&#34;&gt;查看代码对应的时钟寄存器&lt;/h1&gt;
&lt;h4 id=&#34;void-sosc-init-8mhzvoid-&#34;&gt;&lt;code&gt;void SOSC_init_8MHz(void)&lt;/code&gt; :&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SCG-&amp;gt;SOSCDIV=0x00000101;&lt;/code&gt; 设置对应的两路 DIV&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SCG-&amp;gt;SOSCCFG=0x00000024;&lt;/code&gt; 设置SOSC的硬件属性，晶振频率选择，可以看出来 1MHz ~ 8Mhz 是中频的范围，这个值在 Reference Manual 中并未给出。HGO 中高增益意味着高功率，在这里我们不需要高增益。&lt;/li&gt;
&lt;li&gt;循环，等 &lt;code&gt;SOSCCSR&lt;/code&gt; 状态寄存器解锁&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;SOSCCSR&lt;/code&gt;  状态寄存器，这里什么都没有开启，只给了使能。&lt;/li&gt;
&lt;li&gt;循环，等待 &lt;code&gt;SOSCCSR&lt;/code&gt; 有效&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，这个函数应该在启用 &lt;strong&gt;锁相环&lt;/strong&gt; 前设定完成，而且要保证使能步骤在函数内部的最后一步完成。&lt;/p&gt;
&lt;h4 id=&#34;void-spll-init-160mhzvoid-&#34;&gt;&lt;code&gt;void SPLL_init_160MHz(void)&lt;/code&gt; :&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;循环，等 &lt;code&gt;SPLLCSR&lt;/code&gt; 状态寄存器解锁&lt;/li&gt;
&lt;li&gt;设置 &lt;code&gt;SPLLCSR&lt;/code&gt; 先关闭锁相环，&lt;code&gt;SPLLDIV&lt;/code&gt; 设置两路 DIV，&lt;code&gt;SPLLCFG&lt;/code&gt; 设置 MULT 和 PREDIV 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-10-02-S32K144_3/SPLLCalculation.png&#34; alt=&#34;1&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;循环，等待 &lt;code&gt;SPLLCSR&lt;/code&gt; 状态寄存器 解锁&lt;/li&gt;
&lt;li&gt;使能&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;void-normalrunmode-80mhz-void-&#34;&gt;&lt;code&gt;void NormalRUNmode_80MHz (void)&lt;/code&gt; :&lt;/h4&gt;
&lt;p&gt;这个其实就是设置 SCG_RCCR 的值，这个值在 RUN 模式下是用于设定一些分频器（&lt;code&gt;DIVSLOW&lt;/code&gt; &lt;code&gt;DIVBUS&lt;/code&gt; &lt;code&gt;DIVCORE&lt;/code&gt;） 和选择时钟源（&lt;code&gt;SCS&lt;/code&gt;）的。&lt;/p&gt;
&lt;h1 id=&#34;lpit&#34;&gt;低功率中断计时器（LPIT）设置&lt;/h1&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;S32K144中有一个 LPIT 模块 &lt;code&gt;LPIT0&lt;/code&gt; 和四个通道，低泄露模式和等待模式不被该芯片支持，修改 LPIT 在其功能时钟在关闭的时候会导致赋值错误。&lt;/li&gt;
&lt;li&gt;LPIT 每个通道会给 DMAMUX 周期性触发&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;LPIT 被设计为捕捉脉冲在其输入引脚，并不需要和其时钟频率有关，但是为了保证可靠性，连续的触发操作应该至少间隔 10 个 LPIT 总线时钟周期。&lt;/p&gt;
&lt;h3 id=&#34;tval-&#34;&gt;TVAL 是初值寄存器：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在 LPIT 比较模式中&lt;/strong&gt;：其中储存的值会逐渐减少到 0，之后会产生中断并且将初值恢复，写入一个新的值不会立刻修改初值，必须要到当前的值到零重装才能生效，如果想要立即生效请在 TCRTL 寄存器中关闭该模块再重新打开。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在 LPIT 捕捉模式中&lt;/strong&gt;：其中储存的值是计数值的相反值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tctrl-&#34;&gt;TCTRL 是控制寄存器：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;工作模式有：
&lt;ul&gt;
&lt;li&gt;32-bit 周期计数&lt;/li&gt;
&lt;li&gt;双 16-bit 周期计数&lt;/li&gt;
&lt;li&gt;32-bit 触发积累&lt;/li&gt;
&lt;li&gt;32-bit 输入捕捉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TSOT（Timer Start On Trigger），TROT（Timer Reset On Trigger） 和 TSOI（Timer Stop On Interrupt） ，CHAIN 设置请参考 Reference Manual，不难，根据名字就可以理解。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lpit-&#34;&gt;LPIT 使用的步骤：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;PCC 选择 LPIT 的时钟源，然后使用 &lt;code&gt;PCC_PCCn_CGC_MASK&lt;/code&gt; 取或打开 LPIT 。&lt;/li&gt;
&lt;li&gt;首先使用 LPIT0 指针赋值 MCR 寄存器，默认赋值 &lt;code&gt;0x00000001&lt;/code&gt; 即可，仅仅打开 &lt;code&gt;M_CEN&lt;/code&gt; 开关，此开关未打开前后续的寄存器处于锁定状态，赋值以及读取均会报错。&lt;/li&gt;
&lt;li&gt;LPIT0 指针赋值 &lt;code&gt;TMR[n].TVAL&lt;/code&gt; 和 &lt;code&gt;TMR[n].TCTRL&lt;/code&gt;, TVAL 控制 timeout 周期，TCTRL 控制开启对应的通道。并且确定工作模式。&lt;/li&gt;
&lt;li&gt;检测 MSR 寄存器中的 TIFn 是否产生 flag（1）。&lt;/li&gt;
&lt;/ol&gt;</description>
    </item>
    <item>
      <title>S32K144EVB Notes 2 Clock Configurations</title>
      <link>https://xiahualiu.github.io/posts/2017-09-29-s32k144_2/</link>
      <pubDate>Fri, 29 Sep 2017 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2017-09-29-s32k144_2/</guid>
      <description>&lt;h1 id=&#34;heading&#34;&gt;本文简介&lt;/h1&gt;
&lt;p&gt;本文主要详细叙述了 S32K144 的时钟模块相关内容。本文代码包含以下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一般的时钟初始化流程&lt;/li&gt;
&lt;li&gt;LPIT 通道计数器设置&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;heading-1&#34;&gt;时钟结构图&lt;/h1&gt;
&lt;p&gt;在看代码之前，首先要熟悉时钟系统，下图为本程序所用到的时钟和模块示意图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-9-29-S32K144_2/hello_clock.png&#34; alt=&#34;hello_clock.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以看到外部晶振输入 &lt;strong&gt;XTAL(External Crystal Oscillator)&lt;/strong&gt; 和震荡器 &lt;strong&gt;OSC(System Oscillator)&lt;/strong&gt; 相连，产生了一个时钟信号为 &lt;strong&gt;SOSC_CLK&lt;/strong&gt; 该信号被 &lt;strong&gt;SCG_SOSCDIV&lt;/strong&gt; 分频成为两个 &lt;strong&gt;SOSC_DIV1_CLK&lt;/strong&gt; 和 &lt;strong&gt;SOSC_DIV2_CLK&lt;/strong&gt; 时钟信号。&lt;strong&gt;SOSC_CLK&lt;/strong&gt; 又被锁相环 &lt;strong&gt;PLL&lt;/strong&gt; 升频到 &lt;strong&gt;SPLL_CLK&lt;/strong&gt; 信号，&lt;strong&gt;SPLL_CLK&lt;/strong&gt; 被 &lt;strong&gt;SCG_SPLLDIV&lt;/strong&gt; 分频得到 &lt;strong&gt;SPLL_DIV1_CLK&lt;/strong&gt; 或者得到 &lt;strong&gt;SPLL_DIV2_CLK&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FIRC(Fast Internal Reference Clock)&lt;/strong&gt; 产生一个 48HMz 的时钟 &lt;strong&gt;FIRC_CLK&lt;/strong&gt;, &lt;strong&gt;SIRC(Slow Internal Reference Clock)&lt;/strong&gt; 产生一个 8MHz 的信号 &lt;strong&gt;SIRC_SLK&lt;/strong&gt;, &lt;strong&gt;FIRC_CLK&lt;/strong&gt; 和 &lt;strong&gt;SIRC_SLK&lt;/strong&gt; 和 &lt;strong&gt;SPLL_CLK&lt;/strong&gt; 和 &lt;strong&gt;SOSC_CLK&lt;/strong&gt; 被 &lt;strong&gt;SCG_RCCR[SCS]&lt;/strong&gt; 选择器选择信号，使用 &lt;strong&gt;DIVCORE&lt;/strong&gt; 分频得到 &lt;strong&gt;CORE_CLK&lt;/strong&gt;,&lt;strong&gt;SYSCLK&lt;/strong&gt; ；使用 &lt;strong&gt;DIVBUS&lt;/strong&gt; 分频得到 &lt;strong&gt;BUS_CLK&lt;/strong&gt; ，使用 &lt;strong&gt;DIVSLOW&lt;/strong&gt; 分频得到 &lt;strong&gt;FLASH_CLK&lt;/strong&gt; 和 &lt;strong&gt;SCG_SLOW_CLK&lt;/strong&gt; 在这个地方，分频器的倍率选择是有要求的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-9-29-S32K144_2/DIV_Requirement.png&#34; alt=&#34;DIV_Requirement.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;主要是由于结构限制导致的。注意在设置分频器的时候，请在时钟源开启前进行，否则无法改变，分频器在时钟开启后才会被改变其值。&lt;/p&gt;
&lt;p&gt;Manual上关于该芯片的时钟模块描述：&lt;/p&gt;
&lt;h3 id=&#34;1--system-clock-generator-scg&#34;&gt;1. 系统时钟发生器 System clock generator (SCG)&lt;/h3&gt;
&lt;p&gt;系统时钟发生器（下称 SCG ）给单片机提供了不同的时钟源，包含三个时钟分支：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SPLL(System Phase-locked Loop)&lt;/strong&gt; 系统锁相环，一个压控震荡器。在其他地方也被称作 &lt;strong&gt;PLL&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;电压控制振荡器 VCO(Voltage-controlled oscillator)&lt;/li&gt;
&lt;li&gt;外部参考时钟是锁相环的时钟源&lt;/li&gt;
&lt;li&gt;模数 VCO 分频器&lt;/li&gt;
&lt;li&gt;相位/频率探测器&lt;/li&gt;
&lt;li&gt;可以被选做单片机的系统时钟源&lt;/li&gt;
&lt;li&gt;双路可编程控制的时钟输出，可以提供给片内外围器件时钟源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FIRC/SIRC(Fast/Slow Internal Reference Clock)&lt;/strong&gt; 两个内部参考时钟 IRC 发生器：
&lt;ul&gt;
&lt;li&gt;快速内部参考时钟 FIRC 可以程序控制高/低频率范围, 高为 48Mhz。&lt;/li&gt;
&lt;li&gt;快速内部参考时钟 FIRC 和慢速内部参考时钟 SIRC 都可以被选做单片机的系统时钟源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SOSC(System Crystal Oscillator)&lt;/strong&gt; 系统晶振振荡器，在其他地方也被称作 &lt;strong&gt;OSC&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;被当做系统 PLL 的时钟源&lt;/li&gt;
&lt;li&gt;可以被当做单片机的时钟源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;heading-2&#34;&gt;注意：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;SPLL，SOSC 时钟可以被时钟监测器检测，提供重启和中断请求。&lt;/li&gt;
&lt;li&gt;SPLL 可以被锁定监测器检测，提供中断请求。&lt;/li&gt;
&lt;li&gt;每一个时钟源都有一个参考分频器，给片内模块和外围器件提供分频功能，故时钟名中都有 DIV ，譬如：
&lt;ul&gt;
&lt;li&gt;SPLLDIV1_CLK / SPLLDIV2_CLK&lt;/li&gt;
&lt;li&gt;FIRCDIV1_CLK / SCG_FIRCDIV2_CLK&lt;/li&gt;
&lt;li&gt;SIRCDIV1_CLK / SIRCDIV2_CLK&lt;/li&gt;
&lt;li&gt;SOSCDIV1_CLK / SOSCDIV2_CLK&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2--low-power-oscillator-lpo&#34;&gt;2. 低功率振荡器 Low Power Oscillator (LPO)&lt;/h3&gt;
&lt;p&gt;一个内部的低功率时钟，可以给工作在低功率模式下的器件提供时钟源。&lt;/p&gt;
&lt;h3 id=&#34;3--peripheral-clock-control-pcc&#34;&gt;3. 外围时钟控制器 Peripheral Clock Control (PCC)&lt;/h3&gt;
&lt;p&gt;在上一节详细介绍过这个控制器，用于控制大多数器件的时钟选择。&lt;/p&gt;
&lt;h1 id=&#34;heading-3&#34;&gt;代码&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; hello_clocks.c              Copyright NXP &lt;span style=&#34;color:#ae81ff&#34;&gt;2016&lt;/span&gt;
 &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; Description: Example clock and LPIT channel initializations
 &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2016&lt;/span&gt; Mar &lt;span style=&#34;color:#ae81ff&#34;&gt;04&lt;/span&gt; S Mihalik &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; Initial version
 &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2016&lt;/span&gt; Oct &lt;span style=&#34;color:#ae81ff&#34;&gt;27&lt;/span&gt; SM &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; Updated &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; new header files in S32DS v &lt;span style=&#34;color:#ae81ff&#34;&gt;1.3&lt;/span&gt;

&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;S32K144.h&amp;#34;            /* include peripheral declarations S32K144 */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;clocks_and_modes.h&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; lpit0_ch0_flag_counter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* LPIT0 timeout counter */&lt;/span&gt;

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;PORT_init&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
  PCC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; PCCn[PCC_PORTD_INDEX] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PCC_PCCn_CGC_MASK; &lt;span style=&#34;color:#75715e&#34;&gt;/* Enable clock for PORT D */&lt;/span&gt;
  PTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PDDR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;            &lt;span style=&#34;color:#75715e&#34;&gt;/* Port D0:  Data Direction= output */&lt;/span&gt;
  PORTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCR[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;  &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000100&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;/* Port D0:  MUX = ALT1, GPIO (to blue LED on EVB) */&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;LPIT0_init&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
  PCC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCCn[PCC_LPIT_INDEX] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PCC_PCCn_PCS(&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;);    &lt;span style=&#34;color:#75715e&#34;&gt;/* Clock Src = 6 (SPLL2_DIV2_CLK)*/&lt;/span&gt;
  PCC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCCn[PCC_LPIT_INDEX] &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PCC_PCCn_CGC_MASK; &lt;span style=&#34;color:#75715e&#34;&gt;/* Enable clk to LPIT0 regs */&lt;/span&gt;
  LPIT0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;MCR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000001&lt;/span&gt;;    &lt;span style=&#34;color:#75715e&#34;&gt;/* DBG_EN-0: Timer chans stop in Debug mode */&lt;/span&gt;
                              &lt;span style=&#34;color:#75715e&#34;&gt;/* DOZE_EN=0: Timer chans are stopped in DOZE mode */&lt;/span&gt;
                              &lt;span style=&#34;color:#75715e&#34;&gt;/* SW_RST=0: SW reset does not reset timer chans, regs */&lt;/span&gt;
                              &lt;span style=&#34;color:#75715e&#34;&gt;/* M_CEN=1: enable module clk (allows writing other LPIT0 regs) */&lt;/span&gt;
  LPIT0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TMR[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].TVAL &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;40000000&lt;/span&gt;;    &lt;span style=&#34;color:#75715e&#34;&gt;/* Chan 0 Timeout period: 40M clocks */&lt;/span&gt;
  LPIT0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TMR[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;].TCTRL &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000001&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* T_EN=1: Timer channel is enabled */&lt;/span&gt;
                              &lt;span style=&#34;color:#75715e&#34;&gt;/* CHAIN=0: channel chaining is disabled */&lt;/span&gt;
                              &lt;span style=&#34;color:#75715e&#34;&gt;/* MODE=0: 32 periodic counter mode */&lt;/span&gt;
                              &lt;span style=&#34;color:#75715e&#34;&gt;/* TSOT=0: Timer decrements immediately based on restart */&lt;/span&gt;
                              &lt;span style=&#34;color:#75715e&#34;&gt;/* TSOI=0: Timer does not stop after timeout */&lt;/span&gt;
                              &lt;span style=&#34;color:#75715e&#34;&gt;/* TROT=0 Timer will not reload on trigger */&lt;/span&gt;
                              &lt;span style=&#34;color:#75715e&#34;&gt;/* TRG_SRC=0: External trigger soruce */&lt;/span&gt;
                              &lt;span style=&#34;color:#75715e&#34;&gt;/* TRG_SEL=0: Timer chan 0 trigger source is selected*/&lt;/span&gt;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SOSC_init_8MHz&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
  SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SOSCDIV&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000101&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;/* SOSCDIV1 &amp;amp; SOSCDIV2 =1: divide by 1 */&lt;/span&gt;
  SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SOSCCFG&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000024&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;/* Range=2: Medium freq (SOSC betw 1MHz-8MHz)*/&lt;/span&gt;
                            &lt;span style=&#34;color:#75715e&#34;&gt;/* HGO=0:   Config xtal osc for low power */&lt;/span&gt;
                            &lt;span style=&#34;color:#75715e&#34;&gt;/* EREFS=1: Input is external XTAL */&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SOSCCSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; SCG_SOSCCSR_LK_MASK); &lt;span style=&#34;color:#75715e&#34;&gt;/* Ensure SOSCCSR unlocked */&lt;/span&gt;
  SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SOSCCSR&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000001&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;/* LK=0:          SOSCCSR can be written */&lt;/span&gt;
                            &lt;span style=&#34;color:#75715e&#34;&gt;/* SOSCCMRE=0:    OSC CLK monitor IRQ if enabled */&lt;/span&gt;
                            &lt;span style=&#34;color:#75715e&#34;&gt;/* SOSCCM=0:      OSC CLK monitor disabled */&lt;/span&gt;
                            &lt;span style=&#34;color:#75715e&#34;&gt;/* SOSCERCLKEN=0: Sys OSC 3V ERCLK output clk disabled */&lt;/span&gt;
                            &lt;span style=&#34;color:#75715e&#34;&gt;/* SOSCLPEN=0:    Sys OSC disabled in VLP modes */&lt;/span&gt;
                            &lt;span style=&#34;color:#75715e&#34;&gt;/* SOSCSTEN=0:    Sys OSC disabled in Stop modes */&lt;/span&gt;
                            &lt;span style=&#34;color:#75715e&#34;&gt;/* SOSCEN=1:      Enable oscillator */&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;(SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SOSCCSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; SCG_SOSCCSR_SOSCVLD_MASK)); &lt;span style=&#34;color:#75715e&#34;&gt;/* Wait for sys OSC clk valid */&lt;/span&gt;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SPLL_init_160MHz&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SPLLCSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; SCG_SPLLCSR_LK_MASK); &lt;span style=&#34;color:#75715e&#34;&gt;/* Ensure SPLLCSR unlocked */&lt;/span&gt;
  SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SPLLCSR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000000&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;/* SPLLEN=0: SPLL is disabled (default) */&lt;/span&gt;
  SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SPLLDIV &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000302&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;/* SPLLDIV1 divide by 2; SPLLDIV2 divide by 4 */&lt;/span&gt;
  SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SPLLCFG &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00180000&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;/* PREDIV=0: Divide SOSC_CLK by 0+1=1 */&lt;/span&gt;
                              &lt;span style=&#34;color:#75715e&#34;&gt;/* MULT=24:  Multiply sys pll by 4+24=40 */&lt;/span&gt;
                              &lt;span style=&#34;color:#75715e&#34;&gt;/* SPLL_CLK = 8MHz / 1 * 40 / 2 = 160 MHz */&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SPLLCSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; SCG_SPLLCSR_LK_MASK); &lt;span style=&#34;color:#75715e&#34;&gt;/* Ensure SPLLCSR unlocked */&lt;/span&gt;
  SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SPLLCSR &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000001&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* LK=0:        SPLLCSR can be written */&lt;/span&gt;
                             &lt;span style=&#34;color:#75715e&#34;&gt;/* SPLLCMRE=0:  SPLL CLK monitor IRQ if enabled */&lt;/span&gt;
                             &lt;span style=&#34;color:#75715e&#34;&gt;/* SPLLCM=0:    SPLL CLK monitor disabled */&lt;/span&gt;
                             &lt;span style=&#34;color:#75715e&#34;&gt;/* SPLLSTEN=0:  SPLL disabled in Stop modes */&lt;/span&gt;
                             &lt;span style=&#34;color:#75715e&#34;&gt;/* SPLLEN=1:    Enable SPLL */&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;(SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;SPLLCSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; SCG_SPLLCSR_SPLLVLD_MASK)); &lt;span style=&#34;color:#75715e&#34;&gt;/* Wait for SPLL valid */&lt;/span&gt;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;NormalRUNmode_80MHz&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {  &lt;span style=&#34;color:#75715e&#34;&gt;/* Change to normal RUN mode with 8MHz SOSC, 80 MHz PLL*/&lt;/span&gt;
  SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;RCCR&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;SCG_RCCR_SCS(&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;)      &lt;span style=&#34;color:#75715e&#34;&gt;/* PLL as clock source*/&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;SCG_RCCR_DIVCORE(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;b01)      &lt;span style=&#34;color:#75715e&#34;&gt;/* DIVCORE=1, div. by 2: Core clock = 160/2 MHz = 80 MHz*/&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;SCG_RCCR_DIVBUS(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;b01)       &lt;span style=&#34;color:#75715e&#34;&gt;/* DIVBUS=1, div. by 2: bus clock = 40 MHz*/&lt;/span&gt;
    &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;SCG_RCCR_DIVSLOW(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;b10);     &lt;span style=&#34;color:#75715e&#34;&gt;/* DIVSLOW=2, div. by 2: SCG slow, flash clock= 26 2/3 MHz*/&lt;/span&gt;
  &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (((SCG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; SCG_CSR_SCS_MASK) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; SCG_CSR_SCS_SHIFT ) &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;) {}
                                 &lt;span style=&#34;color:#75715e&#34;&gt;/* Wait for sys clk src = SPLL */&lt;/span&gt;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;WDOG_disable&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;){
    WDOG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CNT&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0xD928C520&lt;/span&gt;;   &lt;span style=&#34;color:#75715e&#34;&gt;/*Unlock watchdog*/&lt;/span&gt;
    WDOG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TOVAL&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0x0000FFFF&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/*Maximum timeout value*/&lt;/span&gt;
    WDOG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CS &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00002100&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;/*Disable watchdog*/&lt;/span&gt;
}


&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
  WDOG_disable();
  PORT_init();            &lt;span style=&#34;color:#75715e&#34;&gt;/* Configure ports */&lt;/span&gt;
  SOSC_init_8MHz();       &lt;span style=&#34;color:#75715e&#34;&gt;/* Initialize system oscilator for 8 MHz xtal */&lt;/span&gt;
  SPLL_init_160MHz();     &lt;span style=&#34;color:#75715e&#34;&gt;/* Initialize SPLL to 160 MHz with 8 MHz SOSC */&lt;/span&gt;
  NormalRUNmode_80MHz();  &lt;span style=&#34;color:#75715e&#34;&gt;/* Init clocks: 80 MHz sysclk &amp;amp; core, 40 MHz bus, 20 MHz flash */&lt;/span&gt;
  LPIT0_init();           &lt;span style=&#34;color:#75715e&#34;&gt;/* Initialize PIT0 for 1 second timeout  */&lt;/span&gt;

  &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (;;) {                     &lt;span style=&#34;color:#75715e&#34;&gt;/* Toggle output to LED every LPIT0 timeout */&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (LPIT0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;MSR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; LPIT_MSR_TIF0_MASK)) {} &lt;span style=&#34;color:#75715e&#34;&gt;/* Wait for LPIT0 CH0 Flag */&lt;/span&gt;
    lpit0_ch0_flag_counter&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;;         &lt;span style=&#34;color:#75715e&#34;&gt;/* Increment LPIT0 timeout counter */&lt;/span&gt;
    PTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PTOR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;                &lt;span style=&#34;color:#75715e&#34;&gt;/* Toggle output on port D0 (blue LED) */&lt;/span&gt;
    LPIT0&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;MSR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; LPIT_MSR_TIF0_MASK; &lt;span style=&#34;color:#75715e&#34;&gt;/* Clear LPIT0 timer flag 0 */&lt;/span&gt;
  }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h1 id=&#34;heading-4&#34;&gt;代码详解&lt;/h1&gt;
&lt;p&gt;老样子，还是从 &lt;code&gt;main()&lt;/code&gt; 内开始：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;PORT_init();    &lt;span style=&#34;color:#75715e&#34;&gt;/* Configure ports */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这一行用于初始化端口，函数内部打开 CGC，配置 GPIO ,设置 PCR MUX 和被动滤波。由于第一节已经有了详细介绍，在这里不做过多描述。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;SOSC_init_8MHz();   &lt;span style=&#34;color:#75715e&#34;&gt;/* Initialize system oscilator for 8 MHz xtal */&lt;/span&gt;
SPLL_init_160MHz(); &lt;span style=&#34;color:#75715e&#34;&gt;/* Initialize SPLL to 160 MHz with 8 MHz SOSC */&lt;/span&gt;
NormalRUNmode_80MHz();  &lt;span style=&#34;color:#75715e&#34;&gt;/* Init clocks: 80 MHz sysclk &amp;amp; core, 40 MHz bus, 20 MHz flash */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这三个放在一起，因为他们都用到了一个指针来进行修改，这个指针就是 &lt;code&gt;SCG&lt;/code&gt; , 在头文件中 &lt;code&gt;SCG&lt;/code&gt; 有以下的含义：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/** SCG - Register Layout Typedef */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
  __I  uint32_t VERID;                             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Version ID Register, offset: 0x0 */&lt;/span&gt;
  __I  uint32_t PARAM;                             &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Parameter Register, offset: 0x4 */&lt;/span&gt;
       uint8_t RESERVED_0[&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;];
  __I  uint32_t CSR;                               &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Clock Status Register, offset: 0x10 */&lt;/span&gt;
  __IO uint32_t RCCR;                              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Run Clock Control Register, offset: 0x14 */&lt;/span&gt;
  __IO uint32_t VCCR;                              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; VLPR Clock Control Register, offset: 0x18 */&lt;/span&gt;
  __IO uint32_t HCCR;                              &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; HSRUN Clock Control Register, offset: 0x1C */&lt;/span&gt;
  __IO uint32_t CLKOUTCNFG;                        &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; SCG CLKOUT Configuration Register, offset: 0x20 */&lt;/span&gt;
       uint8_t RESERVED_1[&lt;span style=&#34;color:#ae81ff&#34;&gt;220&lt;/span&gt;];
  __IO uint32_t SOSCCSR;                           &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; System OSC Control Status Register, offset: 0x100 */&lt;/span&gt;
  __IO uint32_t SOSCDIV;                           &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; System OSC Divide Register, offset: 0x104 */&lt;/span&gt;
  __IO uint32_t SOSCCFG;                           &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; System Oscillator Configuration Register, offset: 0x108 */&lt;/span&gt;
       uint8_t RESERVED_2[&lt;span style=&#34;color:#ae81ff&#34;&gt;244&lt;/span&gt;];
  __IO uint32_t SIRCCSR;                           &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Slow IRC Control Status Register, offset: 0x200 */&lt;/span&gt;
  __IO uint32_t SIRCDIV;                           &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Slow IRC Divide Register, offset: 0x204 */&lt;/span&gt;
  __IO uint32_t SIRCCFG;                           &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Slow IRC Configuration Register, offset: 0x208 */&lt;/span&gt;
       uint8_t RESERVED_3[&lt;span style=&#34;color:#ae81ff&#34;&gt;244&lt;/span&gt;];
  __IO uint32_t FIRCCSR;                           &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Fast IRC Control Status Register, offset: 0x300 */&lt;/span&gt;
  __IO uint32_t FIRCDIV;                           &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Fast IRC Divide Register, offset: 0x304 */&lt;/span&gt;
  __IO uint32_t FIRCCFG;                           &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Fast IRC Configuration Register, offset: 0x308 */&lt;/span&gt;
       uint8_t RESERVED_4[&lt;span style=&#34;color:#ae81ff&#34;&gt;756&lt;/span&gt;];
  __IO uint32_t SPLLCSR;                           &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; System PLL Control Status Register, offset: 0x600 */&lt;/span&gt;
  __IO uint32_t SPLLDIV;                           &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; System PLL Divide Register, offset: 0x604 */&lt;/span&gt;
  __IO uint32_t SPLLCFG;                           &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; System PLL Configuration Register, offset: 0x608 */&lt;/span&gt;
} SCG_Type, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;SCG_MemMapPtr;

&lt;span style=&#34;color:#75715e&#34;&gt;/** Peripheral SCG base address */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define SCG_BASE    (0x40064000u)&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/** Peripheral SCG base pointer */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define SCG    ((SCG_Type *)SCG_BASE)&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这是一个相当庞大的结构，翻阅 Manual 瞅一瞅各个小寄存器吧。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Register name&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Width&lt;!-- raw HTML omitted --&gt;(in bits)&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Access&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Version ID Register (SCG_VERID)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Parameter Register (SCG_PARAM)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Clock Status Register (SCG_CSR)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;R&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Run Clock Control Register (SCG_RCCR)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;VLPR Clock Control Register (SCG_VCCR)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;HSRUN Clock Control Register (SCG_HCCR)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;SCG CLKOUT Configuration Register (SCG_CLKOUTCNFG)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;System OSC Control Status Register (SCG_SOSCCSR)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;System OSC Divide Register (SCG_SOSCDIV)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;System Oscillator Configuration Register (SCG_SOSCCFG)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Slow IRC Control Status Register (SCG_SIRCCSR)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Slow IRC Divide Register (SCG_SIRCDIV)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Slow IRC Configuration Register (SCG_SIRCCFG)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Fast IRC Control Status Register (SCG_FIRCCSR)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Fast IRC Divide Register (SCG_FIRCDIV)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;Fast IRC Configuration Register (SCG_FIRCCFG)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;System PLL Control Status Register (SCG_SPLLCSR)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;System PLL Divide Register (SCG_SPLLDIV)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;System PLL Configuration Register (SCG_SPLLCFG)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;version-id-register-scg-verid&#34;&gt;Version ID Register (SCG_VERID)&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;VERSION&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SCG Version Number&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;SCG 的版本号&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;parameter-register-scg-param&#34;&gt;Parameter Register (SCG_PARAM)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写入会导致错误。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;字面意思是参数寄存器，其中 32 位的定义如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;31-27&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DIVPRES&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;指示现在的 SCG 分频器使用状态&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;&lt;code&gt;DIVPRES[27]=1&lt;/code&gt; DIVSLOW 正在被使用&lt;!-- raw HTML omitted --&gt;&lt;code&gt;DIVPRES[28]=1&lt;/code&gt; DIVBUS 正在被使用&lt;!-- raw HTML omitted --&gt;&lt;code&gt;DIVPRES[31]=1&lt;/code&gt; DIVCORE 正在被使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;7-0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;CLKPRES&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;指示当前状态下哪个时钟正在被当做 SCG 时钟源&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;CLKPRES[0] Reserved&lt;!-- raw HTML omitted --&gt;CLKPRES&lt;a href=&#34;https://xiahualiu.github.io/img/2017-9-29-S32K144_2/hello_clock.png&#34;&gt;1&lt;/a&gt;=1 System OSC (SOSC) 正在被使用&lt;!-- raw HTML omitted --&gt;CLKPRES&lt;a href=&#34;https://xiahualiu.github.io/img/2017-9-29-S32K144_2/DIV_Requirement.png&#34;&gt;2&lt;/a&gt;=1 Slow IRC (SIRC) 正在被使用&lt;!-- raw HTML omitted --&gt;CLKPRES[3]=1 Fast IRC (FIRC) 正在被使用&lt;!-- raw HTML omitted --&gt;CLKPRES[6]=1 System PLL (SPLL) 正在被使用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;clock-status-register-scg-csr&#34;&gt;Clock Status Register (SCG_CSR)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;写入会导致错误。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个寄存器返回当前的系统时钟源和系统时钟分频器配置，镜像 SCG_RCCR, SCG_VCCR, SCG_HCCR 三个时钟控制器其中之一的配置。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;27-24&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SCS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;返回当前配置的系统时钟发生器来源&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;0001 System OSC (SOSC_CLK)&lt;!-- raw HTML omitted --&gt;0010 Slow IRC (SIRC_CLK)&lt;!-- raw HTML omitted --&gt;0011 Fast IRC (FIRC_CLK)&lt;!-- raw HTML omitted --&gt;0110 System PLL (SPLL_CLK)&lt;!-- raw HTML omitted --&gt;其余的值无效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;19-16&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DIVCORE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;指示现在的核心时钟分频比率&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;* 若 SPLL 被选做时钟源，则最大比率是 4&lt;!-- raw HTML omitted --&gt; 分频比率 = &lt;code&gt;DIVCORE+1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;7-4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DIVBUS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;返回现在的总线（BUS）时钟分频比率&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;分频比率 = &lt;code&gt;DIVBUS+1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3-0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DIVSLOW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;返回现在的慢速时钟分频比率&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;分频比率 = &lt;code&gt;DIVSLOW+1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;run-clock-control-register-scg-rccr&#34;&gt;Run Clock Control Register (SCG_RCCR)&lt;/h3&gt;
&lt;p&gt;这个寄存器给核心，平台，外围，总线控制系统时钟源和系统时钟分频器，只在 Run 模式下起作用，这个寄存器写入的时候只能一次写入 32 位。在 Run 模式下选择一个不同的时钟源需要时钟源在系统时钟调整到时钟源前就要开启并且保证有效。如果系统时钟分频器比率改变的同时选择了一个不同的时钟模式，则新的分频器比率只有在新的时钟源有效后才会发生改变。&lt;/p&gt;
&lt;p&gt;寄存器见 &lt;code&gt;SCG_CSR&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;vlpr-clock-control-register-scg-vccr&#34;&gt;VLPR Clock Control Register (SCG_VCCR)&lt;/h3&gt;
&lt;p&gt;SCG_VCCR 控制的是 VLPR 模式下的，而不是 Run 模式下的，其他的寄存器地图什么的和 SCG_RCCR 一样。写入的时候只能一次写入 32 位。&lt;/p&gt;
&lt;p&gt;寄存器见 &lt;code&gt;SCG_CSR&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;hsrun-clock-control-register-scg-hccr&#34;&gt;HSRUN Clock Control Register (SCG_HCCR)&lt;/h3&gt;
&lt;p&gt;在 HSRUN 模式下的时钟控制寄存器，同上。&lt;/p&gt;
&lt;p&gt;寄存器见 &lt;code&gt;SCG_CSR&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;scg-clkout-configuration-register-scg-clkoutcnfg&#34;&gt;SCG CLKOUT Configuration Register (SCG_CLKOUTCNFG)&lt;/h3&gt;
&lt;p&gt;这个寄存器控制哪一个 SCG 时钟源被输出到 &lt;strong&gt;CLKOUT&lt;/strong&gt; 管脚。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;27-24&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SCS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;选择 SCG 系统时钟作为 CLKOUT&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;0001 System OSC (SOSC_CLK)&lt;!-- raw HTML omitted --&gt;0010 Slow IRC (SIRC_CLK)&lt;!-- raw HTML omitted --&gt;0011 Fast IRC (FIRC_CLK)&lt;!-- raw HTML omitted --&gt;0110 System PLL (SPLL_CLK)&lt;!-- raw HTML omitted --&gt;其余的值无效&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;system-osc-control-status-register-scg-sosccsr&#34;&gt;System OSC Control Status Register (SCG_SOSCCSR)&lt;/h3&gt;
&lt;p&gt;这个寄存器控制 SCG 模块中的 SOSC 工作状态。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;26&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SOSCERR&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;System OSC Clock Error&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;此位只能被单片机的上电复位重置，但是软件也可以通过向此位写入 1 清零&lt;!-- raw HTML omitted --&gt;0 SOSC 检测器被关闭或者没有检测到错误&lt;!-- raw HTML omitted --&gt;1 SOSC  检测器被开启并且检测到一个错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;25&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SOSCSEL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;System OSC Selected 此位不可写入&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;0 SOSC 不是系统时钟源&lt;!-- raw HTML omitted --&gt;1 SOSC 是系统时钟源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;24&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SOSCVLD&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;System OSC Valid 此位不可写入&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;0 SOSC 无效或者没有启用&lt;!-- raw HTML omitted --&gt;1 SOSC 有效并且输出有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;23&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;LK&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Lock Register&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;此位可以在任何时候清零或者置 1 &lt;!-- raw HTML omitted --&gt;0 CSR 寄存器可以写入&lt;!-- raw HTML omitted --&gt;1 CSR 寄存器不可以写入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;17&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SOSCCMRE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;System OSC Clock Monitor Reset Enable&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;SOSC 监测器中断/重置开关&lt;!-- raw HTML omitted --&gt;0 当错误被检测，监测器产生中断&lt;!-- raw HTML omitted --&gt;1 当错误被检测，监测器产生重启&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;16&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SOSCCM&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;System OSC Clock Monitor&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;SOSC 监测器开关&lt;!-- raw HTML omitted --&gt;0 SOSC 监测器关&lt;!-- raw HTML omitted --&gt;1 SOSC 监测器开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SOSCEN&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;System OSC Enable&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;SOSC 使能&lt;!-- raw HTML omitted --&gt;0 SOSC 关&lt;!-- raw HTML omitted --&gt;1 SOSC 开&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;system-osc-divide-register-scg-soscdiv&#34;&gt;System OSC Divide Register (SCG_SOSCDIV)&lt;/h3&gt;
&lt;p&gt;这个寄存器控制两个时钟输出，既可以用作外围器件的功能时钟，也可以作为时钟模块使用，每一路输出都有分频器提供分频，应该在 SOSC 被关闭的情况下更改该寄存器的值以避免输出的值出现错误。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;10-8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SOSCDIV2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;System OSC Clock Divide 2&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;设置 SOSC 第二路输出的分频比率&lt;!-- raw HTML omitted --&gt;分频比率 = &lt;code&gt;2^(SOSCDIV2-1)&lt;/code&gt; &lt;!-- raw HTML omitted --&gt; 0 时关闭时钟输出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2-1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SOSCDIV1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;System OSC Clock Divide 1&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;设置 SOSC 第一路输出的分频比率&lt;!-- raw HTML omitted --&gt;分频比率 = &lt;code&gt;2^(SOSCDIV1-1)&lt;/code&gt; &lt;!-- raw HTML omitted --&gt; 0 时关闭时钟输出&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;system-oscillator-configuration-register-scg-sosccfg&#34;&gt;System Oscillator Configuration Register (SCG_SOSCCFG)&lt;/h3&gt;
&lt;p&gt;此寄存器控制振荡器的工作状态，在 SOSC 运行的时候无法被写入，强行写入会被忽略并不会报赋值错误。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;5-4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RANGE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;System OSC Range Select&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;选择 SOSC 外接晶振的频率范围&lt;!-- raw HTML omitted --&gt;10 中频 (4 MHz to 8MHz)&lt;!-- raw HTML omitted --&gt;11 高频 (8 MHz to 40 MHz)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;3&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;HGO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;High Gain Oscillator Select&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;高增益振荡器选择&lt;!-- raw HTML omitted --&gt;0 低增益运行振荡器&lt;!-- raw HTML omitted --&gt;1 高增益运行振荡器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;EREFS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;External Reference Select&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;外部参考时钟选择&lt;!-- raw HTML omitted --&gt;0 外部参考时钟&lt;!-- raw HTML omitted --&gt;1 SOSC 内部晶体振荡器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;slow-irc-control-status-register-scg-sirccsr&#34;&gt;Slow IRC Control Status Register (SCG_SIRCCSR)&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;25&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SIRCSEL&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Slow IRC Selected&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;选择 SIRC 是否作为系统时钟源&lt;!-- raw HTML omitted --&gt;0 Slow IRC 是系统时钟源&lt;!-- raw HTML omitted --&gt;1 Slow IRC 不是系统时钟源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;24&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SIRCVLD&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Slow IRC Valid&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;Slow IRC 有效位&lt;!-- raw HTML omitted --&gt;0 Slow IRC 无效或者没有启动&lt;!-- raw HTML omitted --&gt;1 Slow IRC 启动并且有效&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SIRCLPEN&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Slow IRC Low Power Enable&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;Slow IRC 低功率模式开关&lt;!-- raw HTML omitted --&gt;0 Slow IRC 在 VLP 模式不启动下&lt;!-- raw HTML omitted --&gt;1 Slow IRC 在 VLP 模式下启动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SIRCSTEN&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Slow IRC Stop Enable&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;Slow IRC 停止模式开关&lt;!-- raw HTML omitted --&gt;0 Slow IRC 在 Stop modes 下不工作&lt;!-- raw HTML omitted --&gt;1 Slow IRC 在 Stop modes 下工作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SIRCEN&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Slow IRC Enable&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;Slow IRC 使能&lt;!-- raw HTML omitted --&gt;0 Slow IRC 关闭&lt;!-- raw HTML omitted --&gt;1 Slow IRC 开启&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;slow-irc-divide-register-scg-sircdiv&#34;&gt;Slow IRC Divide Register (SCG_SIRCDIV)&lt;/h3&gt;
&lt;p&gt;该寄存器控制 SIRC 的分频器工作状态，请确保该寄存器在改变前，SIRC 是关闭着的，以防止出现错误。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;10-8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SIRCDIV2&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Slow IRC Clock Divide 2&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;提供给需要异步时钟的模块的分频器 2&lt;!-- raw HTML omitted --&gt;分频比率 = &lt;code&gt;2^(SIRCDIV2-1)&lt;/code&gt; &lt;!-- raw HTML omitted --&gt; 0 时关闭时钟输出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2-0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;SIRCDIV1&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Slow IRC Clock Divide 1&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;提供给需要异步时钟的模块的分频器 1&lt;!-- raw HTML omitted --&gt;分频比率 = &lt;code&gt;2^(SIRCDIV1-1)&lt;/code&gt; &lt;!-- raw HTML omitted --&gt; 0 时关闭时钟输出&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;slow-irc-configuration-register-scg-sirccfg&#34;&gt;Slow IRC Configuration Register (SCG_SIRCCFG)&lt;/h3&gt;
&lt;p&gt;此寄存器控制振荡器的工作状态，在 SIRC 运行的时候无法被写入，强行写入会被忽略并不会报赋值错误。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RANGE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Frequency Range&lt;/strong&gt;&lt;!-- raw HTML omitted --&gt;频率范围&lt;!-- raw HTML omitted --&gt;0 Slow IRC low range clock (2 MHz)&lt;!-- raw HTML omitted --&gt;1 Slow IRC high range clock (8 MHz)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;剩余的 FIRC 跟这个差不多，但是有一部分细微的变化，到用的时候请查询对应的用户手册。&lt;/p&gt;</description>
    </item>
    <item>
      <title>S32K144EVB Notes 1 GPIO</title>
      <link>https://xiahualiu.github.io/posts/2017-09-28-s32k144_1/</link>
      <pubDate>Thu, 28 Sep 2017 00:00:00 +0000</pubDate>
      <guid>https://xiahualiu.github.io/posts/2017-09-28-s32k144_1/</guid>
      <description>&lt;h1 id=&#34;heading&#34;&gt;前言&lt;/h1&gt;
&lt;p&gt;本文主要介绍了本人在学习使用 &lt;a href=&#34;https://www.nxp.com/cn/products/microcontrollers-and-processors/arm-processors/s32-arm-processors-microcontrollers/32-bit-automotive-general-purpose-microcontrollers:S32K#overviewExpand?cid=ps_cn_baidu_cpc_B_AUTO_S32K_Phrase_bd20170620002&#34;&gt;S32K144EVB&lt;/a&gt;中遇到的问题和解决办法，由于本芯片是 &lt;a href=&#34;https://www.nxp.com/&#34;&gt;NXP&lt;/a&gt;(原 freescale) 生产的基于 ARM M4F 内核的32位芯片，主要适用对象是汽车 。目前在网络上该芯片还没有相关的中文学习资料，到笔者写本文目前，网络上能够找到的资料只有开发板的电路图和 Reference Manual 和该芯片配套的 IDE 内置头文件以及给出的 cookbook 例程，笔者也是在一步步摸索学习，故本文为一个记录性质的文章。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;本文阅读需要 C 语言基础和一些简单的单片机知识，笔者在之前曾经开发过51单片机和 freescale 公司的 HC08GP32 单片机，故可能会跳过一些基础说明。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;由于该芯片的 Manual 文件长达 1929 页，全读完肯定要浪费很多时间，为了节约时间，我就针对例程中给出的部分内容查询手册相关内容，进行分析。&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;本文针对 S32K144EVB-Q100X 开发板，但基本原理都是相同的。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;hello-world&#34;&gt;Hello World&lt;/h1&gt;
&lt;h2 id=&#34;1-&#34;&gt;1. 本例程主要包含以下部分的操作：&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;配置 GPIO&lt;/li&gt;
&lt;li&gt;根据按键状态输出 LED 灯信号&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-&#34;&gt;2. 使用到的电路图：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://xiahualiu.github.io/img/2017-09-28-S32K144_1/helloworld1.png&#34; alt=&#34;Hello World block diagram&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-&#34;&gt;3. 第一个例程的代码如下：&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;include&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;&amp;#34;S32K144.h&amp;#34; /* include peripheral declarations S32K144 */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PTD0 0 &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* Port PTD0, bit 0: FRDM EVB output to blue LED */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PTC12 12 &lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* Port PTC12, bit 12: FRDM EVB input from BTN0 [SW2] */&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;WDOG_disable&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;){
WDOG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CNT&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0xD928C520&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/*Unlock watchdog*/&lt;/span&gt;
WDOG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;TOVAL&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0x0000FFFF&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/*Maximum timeout value*/&lt;/span&gt;
WDOG&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;CS &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00002100&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/*Disable watchdog*/&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#66d9ef&#34;&gt;void&lt;/span&gt;) {
&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; counter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;
WDOG_disable();
&lt;span style=&#34;color:#75715e&#34;&gt;/* Enable clocks to peripherals (PORT modules) */&lt;/span&gt;
PCC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; PCCn[PCC_PORTC_INDEX] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PCC_PCCn_CGC_MASK; &lt;span style=&#34;color:#75715e&#34;&gt;/* Enable clock to PORT C */&lt;/span&gt;
PCC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; PCCn[PCC_PORTD_INDEX] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; PCC_PCCn_CGC_MASK; &lt;span style=&#34;color:#75715e&#34;&gt;/* Enable clock to PORT D */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* Configure port C12 as GPIO input (BTN 0 [SW2] on EVB) */&lt;/span&gt;
PTC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PDDR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;~&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTC12); &lt;span style=&#34;color:#75715e&#34;&gt;/* Port C12: Data Direction= input (default) */&lt;/span&gt;
PORTC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCR[&lt;span style=&#34;color:#ae81ff&#34;&gt;12&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000110&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Port C12: MUX = GPIO, input filter enabled */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/* Configure port D0 as GPIO output (LED on EVB) */&lt;/span&gt;
PTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PDDR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTD0; &lt;span style=&#34;color:#75715e&#34;&gt;/* Port D0: Data Direction= output */&lt;/span&gt;
PORTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PCR[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0x00000100&lt;/span&gt;; &lt;span style=&#34;color:#75715e&#34;&gt;/* Port D0: MUX = GPIO */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt;(;;) {
&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (PTC&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;PDIR &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt; (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTC12)) { &lt;span style=&#34;color:#75715e&#34;&gt;/* If Pad Data Input = 1 (BTN0 [SW2] pushed) */&lt;/span&gt;
PTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; PCOR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTD0; &lt;span style=&#34;color:#75715e&#34;&gt;/* Clear Output on port D0 (LED on) */&lt;/span&gt;
}
&lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; { &lt;span style=&#34;color:#75715e&#34;&gt;/* If BTN0 was not pushed */&lt;/span&gt;
PTD&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; PSOR &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;PTD0; &lt;span style=&#34;color:#75715e&#34;&gt;/* Set Output on port D0 (LED off) */&lt;/span&gt;
}
counter&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;4-&#34;&gt;4. 代码详解&lt;/h2&gt;
&lt;p&gt;主要关注 main() 内部&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PCC-&amp;gt; PCCn[PCC_PORTC_INDEX] = PCC_PCCn_CGC_MASK; /* Enable clock to PORT C */
PCC-&amp;gt; PCCn[PCC_PORTD_INDEX] = PCC_PCCn_CGC_MASK; /* Enable clock to PORT D */
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这两句话使用的 &lt;code&gt;PCC&lt;/code&gt; 等变量名都是在头文件 &lt;code&gt;&amp;quot;S32K144.h&amp;quot;&lt;/code&gt; 中定义的：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/** PCC - Size of Registers Arrays */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PCC_PCCn_COUNT 116u&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;/** PCC - Register Layout Typedef */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
  __IO uint32_t PCCn[PCC_PCCn_COUNT];   &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; PCC Reserved Register 0..PCC CMP0 Register, array offset: 0x0, array step: 0x4 */&lt;/span&gt;
} PCC_Type, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;PCC_MemMapPtr;

&lt;span style=&#34;color:#75715e&#34;&gt;/** Peripheral PCC base address */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PCC_BASE (0x40065000u)&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/** Peripheral PCC base pointer */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PCC ((PCC_Type *)PCC_BASE)&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;PCC&lt;/code&gt; 是一个指向固定地址的 &lt;code&gt;PCC_Type&lt;/code&gt;结构体指针，他的固定地址是 &lt;code&gt;(0x40065000u)&lt;/code&gt; 它对应的 &lt;code&gt;PCC_Type&lt;/code&gt; 结构拥有一个116个无符号整型变量的数组 &lt;code&gt;PCCn&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据注释内容判断，这个指针的主要作用是用来改变 PCC (Peripheral Clock Controller)控制器内部寄存器的值（下称 PCC ），PCC 控制有关外部时钟频率相关的设置。&lt;br&gt;
查询了 Reference Manual 后得知，PCC 有三个功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;时钟界面开闭控制 CGC (Clock Gating Controller)&lt;/li&gt;
&lt;li&gt;*功能性时钟源选择控制（如果对应模块有时钟源）&lt;/li&gt;
&lt;li&gt;*功能性时钟分频值控制（如果对应模块有分频器）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这个地方，我们仅仅用到第一个功能，也就是时钟界面开关功能。在本文文末，我将给出 PCC 的内存地图。
PCC 模块给芯片上面每一个外围模块都设置了独自的 PCC 内部寄存器地址，用于控制以上的三个功能，PCC 内的每一个寄存器都有一个时钟界面开闭位 (CGC)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在每一个模块使用前，必须打开该模块的CGC (CGC = 1)，才能使用该模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何打开？首先是寻址，在头文件 &lt;code&gt;&amp;quot;S32K144.h&amp;quot;&lt;/code&gt; 中已经将 PCC 控制器的各个寄存器地址全部用宏定义了：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/* PCC index offsets */&lt;/span&gt;
...
&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PCC_PORTA_INDEX 73&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PCC_PORTB_INDEX 74&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PCC_PORTC_INDEX 75&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PCC_PORTD_INDEX 76&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PCC_PORTE_INDEX 77&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以看到 GPIO A/B/C/D/E 对应的地址。将其赋值为 &lt;code&gt;PCC_PCCn_CGC_MASK&lt;/code&gt; 即可打开 CGC。&lt;code&gt;PCC_PCCn_CGC_MASK&lt;/code&gt; 在头文件中定义为：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PCC_PCCn_CGC_MASK 0x40000000u&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;后面的 GPIO 端口方向控制类似 PCC 的控制，在这里使用了一个 PTC 和 PTD 指针，指向两个固定地址的结构体 &lt;code&gt;GPIO_Type&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/** GPIO - Register Layout Typedef */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
  __IO uint32_t PDOR;   &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Port Data Output Register, offset: 0x0 */&lt;/span&gt;
  __O  uint32_t PSOR;   &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Port Set Output Register, offset: 0x4 */&lt;/span&gt;
  __O  uint32_t PCOR;   &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Port Clear Output Register, offset: 0x8 */&lt;/span&gt;
  __O  uint32_t PTOR;   &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Port Toggle Output Register, offset: 0xC */&lt;/span&gt;
  __I  uint32_t PDIR;   &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Port Data Input Register, offset: 0x10 */&lt;/span&gt;
  __IO uint32_t PDDR;   &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Port Data Direction Register, offset: 0x14 */&lt;/span&gt;
  __IO uint32_t PIDR;   &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Port Input Disable Register, offset: 0x18 */&lt;/span&gt;
} GPIO_Type, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;GPIO_MemMapPtr;

&lt;span style=&#34;color:#75715e&#34;&gt;/** Peripheral PTC base address */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PTC_BASE (0x400FF080u)&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/** Peripheral PTC base pointer */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PTC ((GPIO_Type *)PTC_BASE)&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/** Peripheral PTD base address */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PTD_BASE (0x400FF0C0u)&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/** Peripheral PTD base pointer */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PTD ((GPIO_Type *)PTD_BASE)&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;gpio-&#34;&gt;GPIO 的控制器：&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Width&lt;!-- raw HTML omitted --&gt;(in bits)&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Access&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Port Data Output Register (PDOR)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Port Set Output Register (PSOR)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;W&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Port Clear Output Register (PCOR)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;W&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Port Toggle Output Register (PTOR)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;W&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Port Data Input Register (PDIR)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;R&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Port Data Direction Register (PDDR)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;Port Input Disable Register (PIDR)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;RW&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;port-data-output-register-pdor&#34;&gt;Port Data Output Register (PDOR)&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PDO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Port Data Output&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;输出管脚的值，对应逻辑值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;port-set-output-register-psor&#34;&gt;Port Set Output Register (PSOR)&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PTSO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Port Set Output&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;将指定管脚的值置 1&lt;!-- raw HTML omitted --&gt;读取恒为零&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;port-clear-output-register-pcor&#34;&gt;Port Clear Output Register (PCOR)&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PTCO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Port Clear Output&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;将指定管脚的值置 0&lt;!-- raw HTML omitted --&gt;读取恒为零&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;port-toggle-output-register-ptor&#34;&gt;Port Toggle Output Register (PTOR)&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PTTO&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Port Toggle Output&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;将指定管脚的值反转&lt;!-- raw HTML omitted --&gt;读取恒为零&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;port-data-input-register-pdir&#34;&gt;Port Data Input Register (PDIR)&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PDI&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Port Data Input&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;读取指定管脚的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;port-data-direction-register-pddr&#34;&gt;Port Data Direction Register (PDDR)&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PDD&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Port Data Direction&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;0 Input&lt;!-- raw HTML omitted --&gt;1 Output&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;port-input-disable-register-pidr&#34;&gt;Port Input Disable Register (PIDR)&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;-&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PID&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Port Input Disable&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;0 管脚正常输入&lt;!-- raw HTML omitted --&gt;1 管脚不能输入&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;-port-controller-register&#34;&gt;端口功能控制 PORT Controller Register&lt;/h3&gt;
&lt;p&gt;我做个比喻，在 ARM 中，各个管脚就像是一个个等待工作的银行柜台窗口，可以存钱，也可以取钱，也可以借贷款，也可以办理理财业务，银行不能一个业务开一个窗口，所以每个窗口必须可以做很多事情，ARM 也是这样，在有限的管脚上，需要进行中断，PWM，GPIO，UART串口，SPI，I2C，CAN 信息交流功能，所以&lt;strong&gt;有些&lt;/strong&gt;管脚有很多功能可以选择，我们要使用某个功能就要自己进行设置，设置的地方呢就在 &lt;strong&gt;PCR(Pin Controller Register)&lt;/strong&gt; 这个寄存器里面。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/** PORT - Register Layout Typedef */&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;typedef&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {
  __IO uint32_t PCR[PORT_PCR_COUNT];    &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Pin Control Register n, array offset: 0x0, array step: 0x4 */&lt;/span&gt;
  __O  uint32_t GPCLR;  &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Global Pin Control Low Register, offset: 0x80 */&lt;/span&gt;
  __O  uint32_t GPCHR;  &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Global Pin Control High Register, offset: 0x84 */&lt;/span&gt;
       uint8_t RESERVED_0[&lt;span style=&#34;color:#ae81ff&#34;&gt;24&lt;/span&gt;];
  __IO uint32_t ISFR;   &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Interrupt Status Flag Register, offset: 0xA0 */&lt;/span&gt;
       uint8_t RESERVED_1[&lt;span style=&#34;color:#ae81ff&#34;&gt;28&lt;/span&gt;];
  __IO uint32_t DFER;   &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Digital Filter Enable Register, offset: 0xC0 */&lt;/span&gt;
  __IO uint32_t DFCR;   &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Digital Filter Clock Register, offset: 0xC4 */&lt;/span&gt;
  __IO uint32_t DFWR;   &lt;span style=&#34;color:#75715e&#34;&gt;/**&amp;lt; Digital Filter Width Register, offset: 0xC8 */&lt;/span&gt;
} PORT_Type, &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;PORT_MemMapPtr;

&lt;span style=&#34;color:#75715e&#34;&gt;/** Peripheral PORTC base address */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PORTC_BASE (0x4004B000u)&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/** Peripheral PORTC base pointer */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PORTC ((PORT_Type *)PORTC_BASE)&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/** Peripheral PORTD base address */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PORTD_BASE (0x4004C000u)&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;/** Peripheral PORTD base pointer */&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;define PORTD ((PORT_Type *)PORTD_BASE)&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;同样每个 PCR 都有 32 位，与之前不同的是，这 32 位仅仅设置了一个管脚，而不是 32 个个，这 32 位的功能如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;Field&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;24&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;ISF&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Interrupt Status Flag&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;0&lt;!-- raw HTML omitted --&gt; 管脚未检测中断&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;1&lt;!-- raw HTML omitted --&gt; 管脚检测到中断&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;19-16&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;IRQC&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Interrupt Configuration&lt;/strong&gt; 对应管脚的设置如下&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;0000&lt;!-- raw HTML omitted --&gt; ISF 关闭&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;0001&lt;!-- raw HTML omitted --&gt; ISF标志 和 DMA 请求，产生在上升沿&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;0010&lt;!-- raw HTML omitted --&gt; ISF标志 和 DMA 请求，产生在下降沿&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;0011&lt;!-- raw HTML omitted --&gt; ISF标志 和 DMA 请求，既在上升沿也在下降沿产生&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;0100&lt;!-- raw HTML omitted --&gt; 保留&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;0101&lt;!-- raw HTML omitted --&gt; 保留&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;0110&lt;!-- raw HTML omitted --&gt; 保留&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;0111&lt;!-- raw HTML omitted --&gt; 保留&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;1000&lt;!-- raw HTML omitted --&gt; ISF 标志和中断，产生于逻辑 0&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;1001&lt;!-- raw HTML omitted --&gt; ISF 标志和中断，产生于上升沿&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;1010&lt;!-- raw HTML omitted --&gt; ISF 标志和中断，产生于下降沿&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;1100&lt;!-- raw HTML omitted --&gt; ISF 标志和中断，产生于两个沿&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;1100&lt;!-- raw HTML omitted --&gt; ISF 标志和中断，产生于逻辑 1&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;1101&lt;!-- raw HTML omitted --&gt; 保留&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;1110&lt;!-- raw HTML omitted --&gt; 保留&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;1111&lt;!-- raw HTML omitted --&gt; 保留&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;15&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;LK&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Lock Register&lt;/strong&gt; &lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;0&lt;!-- raw HTML omitted --&gt; PCR 寄存器 0 到 15 位值不锁定&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;1&lt;!-- raw HTML omitted --&gt; PCR 寄存器 0 - 15 位值锁定，直到下次重新启动才能够更改&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;10-8&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;MUX&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Pin Mux Control&lt;/strong&gt; 管脚复用控制&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;不是所有的管脚都支持管脚复用，若支持，则可以有以下的设置：&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;000&lt;!-- raw HTML omitted --&gt; 关闭管脚复用&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;001&lt;!-- raw HTML omitted --&gt; 功能 1 ，GPIO&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;010&lt;!-- raw HTML omitted --&gt; 功能 2 ，芯片特定功能&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;011&lt;!-- raw HTML omitted --&gt; 功能 3 ，芯片特定功能&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;100&lt;!-- raw HTML omitted --&gt; 功能 4 ，芯片特定功能&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;101&lt;!-- raw HTML omitted --&gt; 功能 5 ，芯片特定功能&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;110&lt;!-- raw HTML omitted --&gt; 功能 6 ，芯片特定功能&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;111&lt;!-- raw HTML omitted --&gt; 功能 7 ，芯片特定功能&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;6&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;DSE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Drive Strength Enable&lt;/strong&gt; DSE 驱动力加强设置，此位在各种复用模式下都有效&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;0&lt;!-- raw HTML omitted --&gt; 低驱动力模式，如果管脚处于输出模式&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;1&lt;!-- raw HTML omitted --&gt; 高驱动力模式，如果管脚处于输出模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;4&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PFE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Passive Filter Enable&lt;/strong&gt; 被动滤波功能，此位在各复用状态下都有效&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;0&lt;!-- raw HTML omitted --&gt; 关闭被动滤波&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;1&lt;!-- raw HTML omitted --&gt; 开启被动滤波，工作在输入状态下，详情参考滤波说明&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PE&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Pull Enable&lt;/strong&gt; PE 使能上下拉电阻&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;0&lt;!-- raw HTML omitted --&gt; 无内部上下拉电阻&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;1&lt;!-- raw HTML omitted --&gt; 有上下拉电阻&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;0&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;PS&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;strong&gt;Pull Select&lt;/strong&gt; PE 选择上下拉电阻&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;0&lt;!-- raw HTML omitted --&gt; 有上拉电阻&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;1&lt;!-- raw HTML omitted --&gt; 有下拉电阻&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;heading-1&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;如果要使用某个 GPIO 端口，需要的准备工作是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用 PCC 指针打开对应的 PCCn[] 对应的CGC ，PCCn是 PCC 所指向的结构体内部的数组，固定地址，包含一共有116个 uint32 类型寄存器，将对应的寄存器赋值为 &lt;code&gt;PCC_PCCn_CGC_MASK&lt;/code&gt; 即可打开 CGC = 1 。&lt;/li&gt;
&lt;li&gt;设置 GPIO 的控制器中的 PDDR 寄存器，用于调整输入/输出方向。此寄存器在一个类型为 &lt;code&gt;GPIO_Type&lt;/code&gt; 的结构中，一共有 5 个固定地址的结构，使用 PTA/PTB/PTC/PTD/PTE 访问。&lt;/li&gt;
&lt;li&gt;设置 PORT.PCR 控制器，关闭中断，MUX 设置成为 &lt;strong&gt;001&lt;/strong&gt;，是否开启被动滤波。使用 PORTA/PORTB/PORTC/PORTD/PORTE 访问。&lt;/li&gt;
&lt;li&gt;读取对应的 PDIR （输入），或者给 PDOR 赋值 （输出）。使用 PTA/PTB/PTC/PTD/PTE 访问。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;pcc-&#34;&gt;附录：PCC 各个寄存器地图&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;偏移地址&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;寄存器名称&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;长度/位 (bit)&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;权限&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;重启默认值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;80h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC FTFC Register (PCC_FTFC)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;C000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;84h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC DMAMUX Register (PCC_DMAMUX)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;90h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC FlexCAN0 Register (PCC_FlexCAN0)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;94h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC FlexCAN1 Register (PCC_FlexCAN1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;98h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC FTM3 Register (PCC_FTM3)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;9Ch&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC ADC1 Register (PCC_ADC1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;ACh&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC FlexCAN2 Register (PCC_FlexCAN2)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;B0h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC LPSPI0 Register (PCC_LPSPI0)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;B4h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC LPSPI1 Register (PCC_LPSPI1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;B8h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC LPSPI2 Register (PCC_LPSPI2)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;C4h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC PDB1 Register (PCC_PDB1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;C8h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC CRC Register (PCC_CRC)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;D8h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC PDB0 Register (PCC_PDB0)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;DCh&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC LPIT Register (PCC_LPIT)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;E0h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC FTM0 Register (PCC_FTM0)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;E4h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC FTM1 Register (PCC_FTM1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;E8h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC FTM2 Register (PCC_FTM2)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;ECh&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC ADC0 Register (PCC_ADC0)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;F4h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC RTC Register (PCC_RTC)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;100h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC LPTMR0 Register (PCC_LPTMR0)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;124h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC PORTA Register (PCC_PORTA)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;128h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC PORTB Register (PCC_PORTB)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;12Ch&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC PORTC Register (PCC_PORTC)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;130h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC PORTD Register (PCC_PORTD)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;134h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC PORTE Register (PCC_PORTE)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;150h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC SAI0 Register (PCC_SAI0)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;154h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC SAI1 Register (PCC_SAI1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;168h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC FlexIO Register (PCC_FlexIO)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;184h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC EWM Register (PCC_EWM)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;198h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC LPI2C0 Register (PCC_LPI2C0)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;19Ch&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC LPI2C1 Register (PCC_LPI2C1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1A8h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC LPUART0 Register (PCC_LPUART0)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1ACh&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC LPUART1 Register (PCC_LPUART1)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1B0h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC LPUART2 Register (PCC_LPUART2)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1B8h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC FTM4 Register (PCC_FTM4)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1BCh&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC FTM5 Register (PCC_FTM5)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1C0h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC FTM6 Register (PCC_FTM6)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1C4h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC FTM7 Register (PCC_FTM7)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1CCh&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC CMP0 Register (PCC_CMP0)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1D8h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC QSPI Register (PCC_QSPI)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1E4h&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;PCC ENET Register (PCC_ENET)&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;32&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;RW&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;8000_0000h&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;</description>
    </item>
  </channel>
</rss>
