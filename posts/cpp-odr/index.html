<!DOCTYPE html>
<html lang="en-us">

<head>
  
  <meta charset="utf-8">



<meta name="viewport" content="width=device-width, initial-scale=1.0">


  
    <meta name="description" content="This post talks about the odr (one defintion rule) rule in the C&#43;&#43;23 standard draft. This posit is based on the N4917 draft that is published on 2022-09-05.
All text from the standard will have a quote block around, and my explanations (using informal language) are below next to the quote block.
First we need to understand the boundary between a declaration and a definition, according to the traditional way of thinking C&#43;&#43;, the declaration introduces symbols with types, and definition allocates memory for the symbols declared in the same translation unit.">
  


<meta name="color-scheme" content="light dark">


  <meta itemprop="name" content="ODR (One Definition Rule) in C&#43;&#43;23">
<meta itemprop="description" content="This post talks about the odr (one defintion rule) rule in the C&#43;&#43;23 standard draft. This posit is based on the N4917 draft that is published on 2022-09-05.
All text from the standard will have a quote block around, and my explanations (using informal language) are below next to the quote block.
First we need to understand the boundary between a declaration and a definition, according to the traditional way of thinking C&#43;&#43;, the declaration introduces symbols with types, and definition allocates memory for the symbols declared in the same translation unit."><meta itemprop="datePublished" content="2023-08-12T00:00:00+00:00" />
<meta itemprop="dateModified" content="2023-08-12T00:00:00+00:00" />
<meta itemprop="wordCount" content="2114">
<meta itemprop="keywords" content="C&#43;&#43;," />



  <meta property="og:title" content="ODR (One Definition Rule) in C&#43;&#43;23" />
<meta property="og:description" content="This post talks about the odr (one defintion rule) rule in the C&#43;&#43;23 standard draft. This posit is based on the N4917 draft that is published on 2022-09-05.
All text from the standard will have a quote block around, and my explanations (using informal language) are below next to the quote block.
First we need to understand the boundary between a declaration and a definition, according to the traditional way of thinking C&#43;&#43;, the declaration introduces symbols with types, and definition allocates memory for the symbols declared in the same translation unit." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://xiahualiu.github.io/posts/cpp-odr/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-12T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-08-12T00:00:00+00:00" />





<meta name="generator" content="Hugo 0.115.3">
  <title>ODR (One Definition Rule) in C&#43;&#43;23 | Xiahua 夏华</title>
  <link rel="canonical" href="https://xiahualiu.github.io/posts/cpp-odr/">


  








  
    
  
  
  <link rel="stylesheet" href="/css/base.min.46252abbb05e0e8b64454afeb4bcc04bb84cf7f9456ef5c3135eec688032f1c1.css" integrity="sha256-RiUqu7BeDotkRUr&#43;tLzAS7hM9/lFbvXDE17saIAy8cE=" crossorigin="anonymous">



</head>

<body>
  <nav class="u-background">
  <div class="u-wrapper">
    <ul class="Banner">
      <li class="Banner-item Banner-item--title">
        <h1 class="Banner-heading">
          <a class="Banner-link u-clickable" href="/">Xiahua 夏华</a>
        </h1>
      </li>
      
        <li class="Banner-item">
          <a class="Banner-link u-clickable" href="/about/">About</a>
        </li>
      
        <li class="Banner-item">
          <a class="Banner-link u-clickable" href="/posts/">Posts</a>
        </li>
      
        <li class="Banner-item">
          <a class="Banner-link u-clickable" href="/tags/">Tags</a>
        </li>
      
        <li class="Banner-item">
          <a class="Banner-link u-clickable" href="/index.xml">RSS</a>
        </li>
      
    </ul>
  </div>
</nav>

  <main>
    <div class="u-wrapper">
      <div class="u-padding">
        

  <article>
    <header class="Heading">
  <h2 class="Heading-title">
    <a class="Heading-link u-clickable" href="/posts/cpp-odr/" rel="bookmark">ODR (One Definition Rule) in C&#43;&#43;23</a>
  </h2>
  
    <time datetime="2023-08-12T00:00:00Z">12 August, 2023</time>
  
</header>
    <p>This post talks about the odr (one defintion rule) rule in the C++23 standard draft. This posit is based on the N4917 draft that is published on 2022-09-05.</p>
<p>All text from the standard will have a quote block around, and my explanations (using informal language) are below next to the quote block.</p>
<p>First we need to understand the boundary between a declaration and a definition, according to the traditional way of thinking C++, the declaration introduces symbols with types, and definition allocates memory for the symbols declared in the same translation unit.</p>
<h2 id="preamble">
  <a class="Heading-link u-clickable" href="/posts/cpp-odr/#preamble">Preamble</a>
</h2>
<blockquote>
<p>An entity is a value, object, reference, structured binding, function, enumerator, type, class member, bit-field, template, template specialization, namespace, or pack.</p>
</blockquote>
<p>This is the definition of <strong>entities</strong> in C++. Basically everything in C++ that is not an expression, is a entity.</p>
<blockquote>
<p>A name is an identifier (5.10),operator-function-id (12.4), literal-operator-id (12.6), or conversion-function-id (11.4.8.3).</p>
</blockquote>
<p>Definition of <strong>names</strong> in C++. Please be aware that it is different from <strong>entities</strong>, a name is more like the label on a entity not the entity itself.</p>
<blockquote>
<p>Every name is introduced by a declaration, which is a</p>
<ul>
<li><em>declaration</em>, <em>block-declaration</em>, or <em>member-declaration</em> (9.1, 11.4),</li>
</ul>
</blockquote>
<p>This is the typical types of declarations, for examples:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">/* Declaration */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a; <span style="color:#75715e">// This declare name a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">[[noreturn]]</span> <span style="color:#66d9ef">void</span> f (); <span style="color:#75715e">// Declare f() with noreturn attribute
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Block Declaration */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">A</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">int</span>; <span style="color:#75715e">// Opaque enum declaration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span>; <span style="color:#75715e">// Declare class B
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">namespace</span> C; <span style="color:#75715e">//Declare namespace C
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Member Declaration */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">// Declare D::a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">foo</span>(); <span style="color:#75715e">// Declare virtual method D::foo()
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<blockquote>
<ul>
<li><em>init-declarator</em> (9.3),</li>
</ul>
</blockquote>
<blockquote>
<p>Each <em>init-declarator</em> or <em>member-declarator</em> in a declaration is analyzed separately as if it were in a declaration by itself.</p>
</blockquote>
<p>Example:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a, b, c<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>; <span style="color:#75715e">// Equals to int a, int b, int c = 0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">S</span> { <span style="color:#75715e">/* */</span> };
</span></span><span style="display:flex;"><span>S S, T; <span style="color:#75715e">// Declare two instances of struct S
</span></span></span></code></pre></div>
<blockquote>
<ul>
<li><em>identifier</em> in a structured binding declaration (9.6),</li>
</ul>
</blockquote>
<p>Structured binding declaration is new in C++ 2017.</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>}; 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> [x, y] <span style="color:#f92672">=</span> a;    <span style="color:#75715e">// creates e[2], copies a into e,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#75715e">// then x refers to e[0], y refers to e[1]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> [xr, yr] <span style="color:#f92672">=</span> a; <span style="color:#75715e">// xr refers to a[0], yr refers to a[1]
</span></span></span></code></pre></div>
<p>For more information, check <a href="https://en.cppreference.com/w/cpp/language/structured_binding">cppreference - Structured Binding Declaration</a>.</p>
<blockquote>
<ul>
<li><em>init-capture</em> (7.5.5.3),</li>
</ul>
</blockquote>
<p>This is used in the lambda expression.</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">auto</span> z <span style="color:#f92672">=</span> [a <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span>] (<span style="color:#66d9ef">int</span> b) { <span style="color:#66d9ef">return</span> a<span style="color:#f92672">+</span>b; }</span></span></code></pre></div>
<blockquote>
<ul>
<li><em>condition</em> with a <em>declarator</em> (8.1),</li>
</ul>
</blockquote>
<p>Basically you can declare a thing in a <em>condition</em> statement</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#66d9ef">int</span> a<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>; a)
</span></span><span style="display:flex;"><span><span style="color:#75715e">// This equals to
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> a<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span>(a)</span></span></code></pre></div>
<blockquote>
<ul>
<li><em>member-declarator</em> (11.4),</li>
</ul>
</blockquote>
<p>A declarator is the name being declared.</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>b; <span style="color:#75715e">// *b is a member-declarator 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<blockquote>
<ul>
<li><em>using-declarator</em> (9.9),</li>
</ul>
</blockquote>
<p>Example:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">button</span> {up, down};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">S</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> button<span style="color:#f92672">::</span>up; <span style="color:#75715e">// button::up is the using declarator
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    button b<span style="color:#f92672">=</span>up;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<blockquote>
<ul>
<li><em>parameter-declaration</em> (9.3.4.6),</li>
</ul>
</blockquote>
<p>This is the declaration that happens inside the <code>()</code> when declaring a function.</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">foo</span>(<span style="color:#66d9ef">int</span> a) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> a;
</span></span><span style="display:flex;"><span>} <span style="color:#75715e">// Declaring parameter a
</span></span></span></code></pre></div>
<blockquote>
<ul>
<li><em>type-parameter</em> (13.2)</li>
</ul>
</blockquote>
<p>Example:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> <span style="color:#75715e">// Declare T
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">foo</span> {
</span></span><span style="display:flex;"><span>    T a;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<blockquote>
<ul>
<li><em>elaborated-type-specifier</em> that introduces a name (9.2.9.4),</li>
</ul>
</blockquote>
<p>Elaborated type specifiers may be used to refer to a previously-declared class name (class, struct, or union) or to a previously-declared enum name even if the name was hidden by a non-type declaration. They may also be used to declare new class names.</p>
<p>If the name lookup does not find a previously declared type name,</p>
<ul>
<li>The the elaborated-type-specifier is a declaration that introduces the class-name if both of the following are true:
<ul>
<li>the elaborated-type-specifier is introduced by the <em>class-key</em>.</li>
<li><em>class-name</em> is an identifier</li>
</ul>
</li>
<li>Otherwise the program is ill-formed (a compile error is produced).</li>
</ul>
<p>Example</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span><span style="color:#f92672">*</span> Next; <span style="color:#75715e">// OK: lookup of Node finds the injected-class-name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Data</span><span style="color:#f92672">*</span> Data; <span style="color:#75715e">// OK: declares type Data at global scope
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                       <span style="color:#75715e">// and also declares the data member Data
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">class</span> <span style="color:#960050;background-color:#1e0010">::</span><span style="color:#a6e22e">List</span>; <span style="color:#75715e">// error: cannot introduce a qualified name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Kind</span><span style="color:#f92672">*</span> kind; <span style="color:#75715e">// error: cannot introduce an enum
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>Data<span style="color:#f92672">*</span> p; <span style="color:#75715e">// OK: struct Data has been declaredclass A { /* */};
</span></span></span></code></pre></div>
<p><code>struct Data* Data</code> introduces the type Data at global scope also the data member data.</p>
<blockquote>
<ul>
<li>class-specifier (11.1),</li>
</ul>
</blockquote>
<p>This is how you declare a class name.</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> { <span style="color:#75715e">/* Members */</span> };</span></span></code></pre></div>
<blockquote>
<ul>
<li><code>enum-specifier</code> or <code>enumerator-definition</code> (9.7.1),</li>
</ul>
</blockquote>
<p>This is how you declare a enum name.</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">E</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">int</span> { <span style="color:#75715e">/* Enum members */</span> };</span></span></code></pre></div>
<blockquote>
<p><em>exception-declaration</em> (14.1), or</p>
</blockquote>
<p>This is used in the exception handler.</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">throw</span> <span style="color:#e6db74">&#34;Help!&#34;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">try</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>} <span style="color:#66d9ef">catch</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> p) { <span style="color:#75715e">// Declare p
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#75715e">// handle character string exceptions here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<blockquote>
<p>implicit declaration of an injected-class-name (11.1).</p>
</blockquote>
<p>The injected-class-name is the unqualified name of a class within the scope of said class.</p>
<p>In a class template, the injected-class-name can be used either as a template name that refers to the current template, or as a class name that refers to the current instantiation.</p>
<p>In a class scope, the name of the current class is treated as if it were a public member name; this is called injected-class-name. The point of declaration of the name is immediately following the opening brace of the class definition.</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> X;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">X</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>()
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        X<span style="color:#f92672">*</span> p;   <span style="color:#75715e">// OK. X refers to the injected-class-name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">::</span>X<span style="color:#f92672">*</span> q; <span style="color:#75715e">// Error: name lookup finds a variable name, which hides the struct name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<p>Yes, if you define <code>class A</code>, in the class definition, there will be a name <code>class A</code> that is implicitly declared inside the definition braces to mask the outside identifiers with the same name.</p>
<blockquote>
<p>[Note 3: The interpretation of a <em>for-range-declaration</em> produces one or more of the above (8.6.5). — end note]</p>
</blockquote>
<p>The</p>
<h2 id="declaration">
  <a class="Heading-link u-clickable" href="/posts/cpp-odr/#declaration">Declaration</a>
</h2>
<blockquote>
<p>A declaration (Clause 9) may (re)introduce one or more names and/or entities into a translation unit. If so, the declaration specifies the interpretation and semantic properties of these names. A declaration of an entity or typedef-name X is a redeclaration of X if another declaration of X is reachable from it (10.7). A declaration may also have effects including:</p>
</blockquote>
<p>In C++, you can declare an entity or typename <code>X</code> more than one times, but then need to be consistent with each other and all following declarations have no effects.</p>
<p>Declaration itself have a limited range of effects, including:</p>
<ul>
<li>A <strong>static</strong> assertion.</li>
<li>Controlling template instantiation.</li>
<li>Guiding template argument deduction for constructors.</li>
<li>Use of attributes.</li>
<li>Nothing (empty declaration).</li>
</ul>
<p>Each entity declared by a declaration is also defined by that declaration unless:</p>
<ul>
<li>It declares a functions without specifying the function&rsquo;s body.</li>
</ul>
<p>Example:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">foo</span>(<span style="color:#66d9ef">void</span>); <span style="color:#75715e">/* Declare a function without body */</span></span></span></code></pre></div>
<ul>
<li>It contains the <code>extern</code> specifier or a <em>linkage-specifition</em> and neither an <em>initializer</em> nor a <em>function-body</em>.</li>
</ul>
<p>Example:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">int</span> foo; <span style="color:#75715e">/* Foo can be used to denote names outside this translation unit */</span>
</span></span><span style="display:flex;"><span>                <span style="color:#75715e">/* Foo is declared but not defined */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> bar <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">/* Bar is declared and defined */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">sqrt</span>(<span style="color:#66d9ef">double</span>); <span style="color:#75715e">/* sqrt has C linkage */</span>
</span></span><span style="display:flex;"><span>                         <span style="color:#75715e">/* No function body so it is not defined */</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<ul>
<li>It declares a non-inline static data member in a class definition.</li>
</ul>
<p>Example:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">foo</span> { <span style="color:#75715e">/* Struct foo is declared */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">/* Not a definition of foo::i */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> i; <span style="color:#75715e">/* This is declaration and definition of foo::i */</span>
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<ul>
<li>It declares a static data member outside a class definition and the variable was defined within the class with the <code>constexpr</code> specifier. (Deprecated, do not rely on this rule)</li>
</ul>
<p>Example:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>; <span style="color:#75715e">/* Definition (declaration in C++ 2014) */</span>
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">constexpr</span> <span style="color:#66d9ef">int</span> A<span style="color:#f92672">::</span>n; <span style="color:#75715e">/* Redundant declaration (definition in C++ 2014) */</span></span></span></code></pre></div>
<ul>
<li>It is an <em>elaborated-type-specifier</em>.</li>
</ul>
<p>Example:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">s</span> { <span style="color:#66d9ef">int</span> a; };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">g</span>() {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">s</span>; <span style="color:#75715e">// Hide global struct s with a block scope declaration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    s<span style="color:#f92672">*</span> p; <span style="color:#75715e">// Refer to local struct s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">s</span> { <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> p; }; <span style="color:#75715e">// define local struct s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">s</span>; <span style="color:#75715e">// Redeclaration, has no effect
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<ul>
<li>It is an <em>opaque-enum-declaration</em>.</li>
</ul>
<p>Example:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">A</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">int</span>; <span style="color:#75715e">// Opaque enum declaration, can be redeclared later
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">A</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">int</span> {red, blue, yellow}; <span style="color:#75715e">// Redeclared with enum specifier
</span></span></span></code></pre></div>
<ul>
<li>It is a <em>template-parameter</em>.</li>
</ul>
<p>Example:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span> <span style="color:#75715e">// T is declared as a template parameter
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> foo(T<span style="color:#f92672">*</span> a);</span></span></code></pre></div>
<ul>
<li>It is a <em>parameter-declaration</em> in a function declarator that is not the declarator of a <em>function-definition</em>.</li>
</ul>
<p>Example:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">foo</span> (<span style="color:#66d9ef">int</span>) <span style="color:#66d9ef">const</span> <span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">noexcept</span>;</span></span></code></pre></div>
<ul>
<li>It is a <code>typedef</code> declaration.</li>
<li>It is an <em>alias-declaration</em> (<code>using</code>).</li>
</ul>
<p>PS: Both <code>typedef</code> and <code>using</code> do not introduce new types. And <code>using</code> in <em>alias-declaration</em> has the same semantics as <code>typedef</code>. So I just put <code>using</code> examples here to represent both cases:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Alloc</span> {};
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> Vec <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span>T, Alloc<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>; <span style="color:#75715e">// type-id is vector&lt;T, Alloc&lt;T&gt;&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span>Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v; <span style="color:#75715e">// Vec&lt;int&gt; is the same as vector&lt;int, Alloc&lt;int&gt;&gt;
</span></span></span></code></pre></div>
<p>When the result of specializing an alias template is a dependent <em>template-id</em>, subsequent substitutions apply to that <em>template-id</em>:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>...<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">using</span> void_t <span style="color:#f92672">=</span> <span style="color:#66d9ef">void</span>;
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>void_t<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">::</span>foo<span style="color:#f92672">&gt;</span> f();
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span>f<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(); <span style="color:#75715e">// error, int does not have a nested type foo
</span></span></span></code></pre></div>
<ul>
<li>It is a <em>using-declaration</em>.</li>
</ul>
<p>Note this is different from <code>using</code> in alias-declaration above, in this case, <code>using</code> is used to introduce names into the namespace.</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">button</span> {up, down};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">S</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> button:up;
</span></span><span style="display:flex;"><span>    button b<span style="color:#f92672">=</span>up;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<ul>
<li>It is a <em>deduction-guide</em>.</li>
</ul>
<p>Example:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">S</span> {
</span></span><span style="display:flex;"><span>    T data;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>S(U) <span style="color:#f92672">-&gt;</span> S<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> U<span style="color:#f92672">::</span>type<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">A</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> type <span style="color:#f92672">=</span> <span style="color:#66d9ef">short</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">type</span>();
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>S x{A()}; <span style="color:#75715e">// x is of type S&lt;short, int&gt;
</span></span></span></code></pre></div>
<ul>
<li>It is a <em><code>static_assert</code>-declaration</em>.</li>
</ul>
<p>It does not introduce new names, and only should be used just for diagnotic purposes.</p>
<p>Example:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">static_assert</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">==</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>), <span style="color:#e6db74">&#34;wrong pointer size&#34;</span>);</span></span></code></pre></div>
<ul>
<li>It is an <em>attribute-declaration</em>.</li>
</ul>
<p>Note attributes can be tested by <code>__has_cpp_attribute( attribute-token )</code>.</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a6e22e">[[gnu::always_inline]] [[gnu::hot]] [[gnu::const]] [[nodiscard]]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">int</span> f(); <span style="color:#75715e">// declare f with four attributes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span> 
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">[[gnu::always_inline, gnu::const, gnu::hot, nodiscard]]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> f(); <span style="color:#75715e">// same as above, but uses a single attr specifier that contains four attributes
</span></span></span></code></pre></div>
<ul>
<li>It is an <em>empty-declaration</em>.</li>
</ul>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>; <span style="color:#75715e">/* Empty declaration has no effect at all */</span></span></span></code></pre></div>
<ul>
<li>It is a <em>using-directive</em>.</li>
</ul>
<p>A <code>using</code> directive does not introduce any names.</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">namespace</span> A {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">namespace</span> B {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">namespace</span> C {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> i;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> A<span style="color:#f92672">::</span>B<span style="color:#f92672">::</span>C;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f1</span>() {
</span></span><span style="display:flex;"><span>            i <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// OK, C::i visible in B and hides A::i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">namespace</span> D {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> B; 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> C; <span style="color:#75715e">// B::C not in D, cannot hide A::i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f2</span>() {
</span></span><span style="display:flex;"><span>            i <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#75715e">// ambiguous, B::C::i or A::i?
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f3</span>() {
</span></span><span style="display:flex;"><span>        i <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// uses A::i
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f4</span>() {
</span></span><span style="display:flex;"><span>    i <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// error: neither i is visible
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<ul>
<li>It is an <em>using-enum-declaration</em>.</li>
</ul>
<p>A <em>using-enum-declaration</em> is equivalent to a <em>using-declaration</em> for each enumerator.</p>
<p>A <em>using-enum-declaration</em> in <strong>class scope</strong> makes the enumerators of the named enumeration available via
member lookup.</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">enum</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">fruit</span> { orange, apple };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">S</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">using</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">fruit</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// OK, introduces orange and apple into S
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">f</span>() {
</span></span><span style="display:flex;"><span>    S s;
</span></span><span style="display:flex;"><span>    s.orange;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// OK, names fruit::orange
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    S<span style="color:#f92672">::</span>orange;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// OK, names fruit::orange
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}</span></span></code></pre></div>
<ul>
<li>
<p>It is a <em>template-declaration</em> whose <em>template-head</em> is not followed by either a <em>concept-definition</em> or a declaration that defines a function, a class, a variable, or a static data member.</p>
</li>
<li>
<p>It is an <strong>explicit</strong> instantiation declaration, or It is an <strong>explicit</strong> specialization whose <em>declaration</em> is not a definition.</p>
</li>
</ul>
<p>In some circumstances, C++ implementations <strong>implicitly</strong> define the default constructor, copy constructor, move constructor, copy assignment operator, move assignment operator, or destructor member functions.</p>
<p>Example, Given:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">C</span> {
</span></span><span style="display:flex;"><span>        std<span style="color:#f92672">::</span>string s;
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// std::string is the standard library class (23.4)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    };
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>    C a;
</span></span><span style="display:flex;"><span>    C b <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span>    b <span style="color:#f92672">=</span> a;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>
<p>the implementation will implicitly define functions to make the definition of C equivalent to:</p>

<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">C</span> {
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>string s;
</span></span><span style="display:flex;"><span>    C() <span style="color:#f92672">:</span> s() { }
</span></span><span style="display:flex;"><span>    C(<span style="color:#66d9ef">const</span> C<span style="color:#f92672">&amp;</span> x)<span style="color:#f92672">:</span> s(x.s) { }
</span></span><span style="display:flex;"><span>    C(C<span style="color:#f92672">&amp;&amp;</span> x)<span style="color:#f92672">:</span> s(<span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;&amp;&gt;</span>(x.s)) { }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">:</span> s(std<span style="color:#f92672">::</span>move(x.s)) { }
</span></span><span style="display:flex;"><span>    C<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(<span style="color:#66d9ef">const</span> C<span style="color:#f92672">&amp;</span> x) { s <span style="color:#f92672">=</span> x.s; <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>; }
</span></span><span style="display:flex;"><span>    C<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">=</span>(C<span style="color:#f92672">&amp;&amp;</span> x) { s <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>string<span style="color:#f92672">&amp;&amp;&gt;</span>(x.s); <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    { s <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(x.s); <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">this</span>; }
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">~</span>C() { }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<h2 id="one-definition-rule">
  <a class="Heading-link u-clickable" href="/posts/cpp-odr/#one-definition-rule">One Definition Rule</a>
</h2>
<p>Each of the following is termed a definable item:</p>
<ul>
<li>A class type</li>
<li>An enumeration type.</li>
<li>A function.</li>
<li>A variable.</li>
<li>A templated entity.</li>
<li>A default argument for a parameter (for a function in a given scope), or</li>
<li>A default template argument.</li>
</ul>
<p>No translation unit shall contain more than one definition of any definable item.</p>
<p>An expression or conversion is potentially evaluated unless it is an unevaluated operand (7.2.3), a subexpression
thereof, or a conversion in an initialization or conversion sequence in such a context. The set of potential
results of an expression E is defined as follows:</p>

    


  

  





  <footer>
    
      
    
      
        <ul class="Tags">
          
            <li class="Tags-item u-background">
              <a class="Tags-link u-clickable" href="/tags/c&#43;&#43;/" rel="tag">C&#43;&#43;</a>
            </li>
          
        </ul>
      
    
  </footer>

    
  
    
    
    <script src="https://utteranc.es/client.js" data-repo="https://github.com/xiahualiu/blog" data-issue-term="pathname" data-theme="preferred-color-scheme" crossorigin="anonymous" async></script>
  

  </article>


      </div>
    </div>
  </main>
  
  <footer class="Footer">
    <div class="u-wrapper">
      <div class="u-padding">
        Except where otherwise noted, content on this site is licensed under a &#32; <a href="http://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>.
      </div>
    </div>
  </footer>

</body>

</html>
