<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Hugo 0.61.0" />
  
  
  
  <title>
    
    CAN 协议解读 | Xiahua
    
  </title>
  <link rel="canonical" href="https://xiahualiu.github.io/posts/2017-12-12-can_bus/">
  
  
  
  
  
  
  
  
  <link rel="stylesheet" href="https://xiahualiu.github.io/css/base.min.50883c9e7cc6f561db1dcd2089b6b895c60df8d10b9e71a90cbc10e59c8bfc40.css" integrity="sha256-UIg8nnzG9WHbHc0giba4lcYN&#43;NELnnGpDLwQ5ZyL/EA=" crossorigin="anonymous">
  
  
</head>
<body>
  <nav class="u-background">
  <div class="u-wrapper">
    <ul class="Banner">
      <li class="Banner-item Banner-item--title">
        <a class="Banner-link u-clickable" href="https://xiahualiu.github.io/">Xiahua</a>
      </li>
      
      <li class="Banner-item">
        <a class="Banner-link u-clickable" href="https://github.com/xiahualiu">About</a>
      </li>
      
      <li class="Banner-item">
        <a class="Banner-link u-clickable" href="https://xiahualiu.github.io/post/">Posts</a>
      </li>
      
      <li class="Banner-item">
        <a class="Banner-link u-clickable" href="https://xiahualiu.github.io/tags/">Tags</a>
      </li>
      
      <li class="Banner-item">
        <a class="Banner-link u-clickable" href="https://xiahualiu.github.io/categories/">Categories</a>
      </li>
      
      <li class="Banner-item">
        <a class="Banner-link u-clickable" href="https://xiahualiu.github.io/index.xml">RSS</a>
      </li>
      
    </ul>
  </div>
</nav>

  <main>
    <div class="u-wrapper">
      <div class="u-padding">
        

<article>
  <header class="Heading">
  <h2 class="Heading-title">
    <a class="Heading-link u-clickable" href="https://xiahualiu.github.io/posts/2017-12-12-can_bus/" rel="bookmark">CAN 协议解读</a>
  </h2>
  <time datetime="2017-12-12T10:48:30Z">
    12 December, 2017
  </time>
</header>

  <p>本文的首要目标是帮助记忆一下有关 CAN 总线上面的知识，并且也帮助一下感兴趣的同学，从浅入深的了解一下 CAN 总线的一些知识，相比其他的教程，我的初衷是将本文写的尽量接地气，简单明了，因为自己也啃过不少的技术文章，但是从一个读者的角度，有些 CAN 协议内容相当晦涩难懂。如果本文出现错误（肯定有错误），大家可以在下边的评论栏中回复具体内容，以便于我及时更改。</p>
<h1 id="heading">简介</h1>
<p>CAN 协议全称 Controller Area Network protocol，自从 CAN 协议从 1986 年被正式推出后，就一直在不断地更新其标准细节。官方的文献 ISO11898 只提供了一些非常粗浅的相关信息，然而在工业用途上，CAN 网络还有许多不是被规定覆盖的内容，需要自己针对特定的环境理解。</p>
<h1 id="can-">CAN 网络的结构</h1>
<p>CAN 是一个多主机串行总线，在 CAN 总线上的 ECU 被称作节点。在网络上必须有两个或者多个节点才能相互交流。节点的复杂度从简单的 I/O 设备到拥有 CAN 界面的嵌入式电脑。节点同时也有可能是 CAN 网关，允许电脑通过 USB 或者以太网端口进行网络交互。</p>
<p>所有的节点都通过两根线相连接，线缆必须为 120Ω 的标称双绞线。根据 <strong>ISO 11898-2</strong> 标准，高速 CAN 总线必须在两根线的末端用 120Ω 的电阻相互连接。</p>
<p><img src="/img/2017-12-12-CAN_Bus/CAN_ISO11898-2_Network.png" alt="1"></p>
<p>CAN 网络中，这两根线的名称分为别，CAN High 和 CAN Low，简称为 CAN_H 和 CAN_L：</p>
<ul>
<li>在某节点发送 <code>0</code> 的状态下，CAN_H 会被该节点驱动向 5V，CAN_L 会被驱动向 0V，直到两根线间拥有了 2V 的电势差，通常此时 CAN_H 为 3.5V，CAN_L 为 1.5V。</li>
<li>在总线空闲或者某节点在发送 <code>1</code> 的状态下，CAN_H 和 CAN_L 不会被驱动，两根线的电压在线路上电阻的作用下维持相同的电压。（通常是 2.5V）</li>
<li>在隐性状态下的电压值需要保持在 -12~+12V 之间。</li>
</ul>
<p><img src="/img/2017-12-12-CAN_Bus/ISO11898-2.png" alt="2"></p>
<p>图中的黑线为逻辑电平值，红线即为 CAN_H 电平，绿线为 CAN_L 电平。
我们通常称 CAN 总线上的 <code>0</code> 为显性的，一旦有一个设备发送了 <code>0</code> 总线即发生改变，而总线上的 <code>1</code> 是隐性的，<code>1</code> 信号可以当做什么也没干，<code>0</code> 信号可以覆盖 <code>1</code> 信号。隐性状态可以为空闲状态，或者为发送 <code>1</code> 状态。</p>
<p><strong>ISO 11898-3</strong> 还有规定了另外一种类型的 CAN 总线，叫做<strong>低速 CAN 总线</strong>，或者错误包容 CAN 总线，在这种总线上面，各个节点在总线的终端，节点电阻的并联电阻即为原有的末端电阻，这个电阻值应该为 100Ω 左右，但是不能低于 100Ω。</p>
<p><img src="/img/2017-12-12-CAN_Bus/CAN_ISO11898-3_Network.png" alt="3"></p>
<p>低速 CAN 总线上的 CAN_L 在隐性状态下并不与 CAN_H 相同，相反隐性状态下两根线的电平之差最大，具体的时序图见下图：</p>
<p><img src="/img/2017-12-12-CAN_Bus/ISO11898-3_Waveform.png" alt="4"></p>
<p>在这种总线类型下，显性位时，CAN_H 必须高于 CAN_L 超过 2.3V（在 5V 的 VCC 下），隐性条件时，CAN_H 为 4.7V(VCC - 0.3V)，同理 CAN_L 为 0.3V(VCC + 0.3V)。</p>
<p>由于 CAN 总线在隐性位向显性位转变的时候是被节点驱动的，故这种转变要快于显性位向隐性位转变，后者是由两根线的电气特性决定的，故速度和 CAN_H，CAN_L 线之间的等效电容有关，高速 CAN 通常用于汽车和工业，节点较少的环境下，低速 CAN 通常用于多个节点连接在同一位置的情况下。</p>
<p>最常见的 CAN 接口没有被规定，你可以用任何接口，但是最常见的 CAN 接口是 DB9，具有四个引脚，具有一个供电端和地端：</p>
<ul>
<li>CAN-Low(CAN_L)</li>
<li>GND(Ground)</li>
<li>CAN-High(CAN_H)</li>
<li>CAN V+(Power)</li>
</ul>
<p><img src="/img/2017-12-12-CAN_Bus/9_pin_d-sub_connector_male_closeup.jpg" alt=""></p>
<p>这就是标准的 DB9 公接头。</p>
<h2 id="can--1">CAN 节点</h2>
<p>一个标准的 CAN 节点应该有以下的几个部分组成：</p>
<ul>
<li>微处理器 MCU
<ul>
<li>决定接收的 CAN 报文的内容和需要发送的 CAN 报文内容。</li>
<li>传感器和其他信号设备需要连接在微处理器上。</li>
</ul>
</li>
<li>CAN 控制器（一般由 MCU 集成）
<ul>
<li>按位接收数据，并且回馈给微处理器（通常通过中断）。</li>
<li>按位发送数据。</li>
</ul>
</li>
<li>CAN 收发器 ISO 11898-2/3 Medium Access Unit [MAU] 标准
<ul>
<li>接收 CAN 总线上的电位值，并将其转换为数字信号 1/0 通常具有电路保护作用，防止损坏 CAN 控制器。</li>
<li>将数据按位解算成为 CAN 电气信号，发送到总线上。</li>
</ul>
</li>
</ul>
<p><img src="/img/2017-12-12-CAN_Bus/CAN_Node.png" alt=""></p>
<p>CAN 总线具有一个特性就是只单向从隐性状态驱动至显性状态，每个 CAN 节点就像是一个打气筒一样，只把 CAN 线路从 1 打气驱动到 0 ，然后不驱动时总线就会自动漏气归 1（因为两根线是通过电阻连接在一起的）。</p>
<h1 id="can--2">CAN 的数据传输过程</h1>
<p>上面讲的都是一些物理层的特性，我们只讨论了 1 和 0 状态，CAN 总线是串行总线，数据就是按照位一位一位发送的，与其他的串行协议（I2C, SPI, UART）基本类似，CAN 同时也是异步通信协议，没有像 SPI 一样拥有一根时钟线，所以 CAN 传输过程中的波特率必须接收方和发送方一致才可以。</p>
<h2 id="heading-1">数据帧</h2>
<p>CAN 发送的最小信息单位叫做帧，我们先以最基础的 CAN 数据帧讲解：</p>
<p><img src="/img/2017-12-12-CAN_Bus/CAN_data_frame.png" alt=""></p>
<p>首先，如果一个设备要发送数据时，首先向总线发送一个位的显性位（0），我们又称 <strong>帧起始/SOF(Start-of-Frame)</strong>，这个显性位的作用是声明自己已经占有了总线，在发送显性位 <strong>之后</strong>，其他的设备就知道了，哦现在总线有人了，不能再发送数据了。</p>
<p>但是还有一种情况，就是在这个显性位发送的同时，巧了，也有一个设备也同时发送了一个 <strong>帧起始</strong>，这就会导致，这俩设备都以为自己是现在的总线占有者，那这样不就乱了么？这时就要介绍一下 CAN 的仲裁机制，CAN 采用了一种非常巧妙的仲裁机制，叫做 <strong>无损按位仲裁（Lossless Bitwise Arbitration）</strong> 它的作用就是保证在同一时刻只有一个设备在发送数据。</p>
<p>在 <strong>帧起始</strong> 后，接着是 <strong>仲裁段(Arbitration Field)</strong> ，有一个长达 11 位的 <strong>CAN ID/CAN 标识段</strong>。在这段，就开始了比谁更优先的游戏，这个游戏的优先规则就是，谁先显性谁优先。设备在仲裁段发送每一位会时刻注意 CAN 总线的状态，我们知道显性位可以覆盖隐性位，一旦设备它自己发现自己发送的隐性位被别的设备覆盖成了显性了，这个设备就知道自己输了，就不会继续发送数据了。</p>
<p><img src="/img/2017-12-12-CAN_Bus/arbitration_method.png" alt=""></p>
<p>注意：上图中的电平为逻辑电平，0 对应我们的显性位，1 对应我们的隐性位。</p>
<p>在 <strong>CAN ID</strong> 的后边是 <strong>RTR</strong>(Remote Transmission Request) <strong>远程请求位</strong>，这一位也在优先级的比赛内，这一位的作用就是标识本帧是不是远程帧，数据帧这一位为 0；远程帧为 1。所以如果之前都是平局，在这一位到来时，数据帧就要优先于远程帧，远程帧是没有数据的帧哈（后边详细介绍）。</p>
<p>到此为止，<strong>仲裁段(Arbitration Field)</strong> 就已经结束了，成功占据总线的设备就开始了发送 <strong>控制段(Control Field)</strong>，控制段内容有：</p>
<ul>
<li><strong>IDE(Identifier Extension Bit)</strong>，我们可以认作 CAN 拓展帧使能位，这一位的隐性位也即是 1 意味着此 CAN 帧不是标准的，而是拓展的，拓展的 CAN 帧具有 29 位的 CAN ID 而不是标准的 11 位（后边介绍），在标准的 CAN2.0A 帧上此位为 0，CAN2.0B 也即是拓展帧此位为 1。</li>
<li><strong>Reserved bit</strong> 此位为保留位，也可以称作 <strong>r1, r0</strong> 通常情况下保留一个显性位，也即是 <strong>r0</strong>，但是接收设备接收到 <strong>r1</strong> 不会认作错误。</li>
<li><strong>DLC(Data length code)</strong> 后续数据字节的数量，一共有 4 位，但是只能 0-8，在物理上表示 9-15 是可行的，但 DLC&gt;8 时还是按照 8 字节发送和接收。</li>
</ul>
<p>接下来就是数据段了，长度不定，根据控制段的 DLC 变化，长度只能在 0-64bits 或者 0-8bytes 之间。</p>
<p>接下来是 <strong>CRC 段</strong>，这一部分的内容作为校验码，接收方可以根据在此之前的接收数据（从 SOF 到 CRC 段开始）主动计算出一个 CRC 码，然后用自己计算的 CRC 和被动接收的 CRC 比较内容，如果不一致就说明之前接受的数据出现错误，具体感兴趣的可以自行查询 CRC 算法，很神奇，只要用一个寄存器的位移就可以实现计算。注意在 CRC 接收末尾有一个 CRC 边界位，边界位必须为隐性位，是为了给后边的应答做准备。</p>
<p>接下来是 <strong>ACK Field 应答段</strong>：</p>
<ul>
<li><strong>应答槽(ACK Slot)</strong>，这一位发送方会发送一个隐性位，应答方需要发送一个位的显性位，这样发送方才知道数据发送成功了，和 I2C 的应答有点类似。如果接收方接收出现错误，接收方必须保持沉默，这样发送方会知道自己的发送失败了。但是，如果有很多接收方，其中有一部分接收失败了，另一部分接收成功了并且应答，发送方依旧会检测到应答，并认为自己发送成功，<strong>发送方并不知道应答是由哪一个设备发出的</strong>。</li>
<li><strong>应答边界(ACK Delimiter)</strong> 因为之前应答了一位显性位，要保证应答数据不影响后边发送的数据，就要等待一位以确保应答位不因为错位，而影响到后续信息的发送。</li>
</ul>
<p>最后是 <strong>帧结束/EOF(End-of-Frame)</strong>，其实就是 7 个连续的隐性位。在帧结束后，还有一个 <strong>帧间空白/IFS(Interframe Spacing)</strong> 直接翻译是帧之间的空白，IFS 保证在前一帧数据和后一帧数据间要保证有 3 个隐性位的长度，这一段空白是必须的。</p>
<h2 id="heading-2">拓展帧</h2>
<p><img src="/img/2017-12-12-CAN_Bus/CAN_data_frame.png" alt=""></p>
<p>拓展帧中 CAN ID 被分作两部分，合并起来一共有 29 位，就是拓展帧的 CAN ID，拓展帧并不是数据长度变长了，而是 CAN ID 变长了，原有的 <strong>RTR</strong> 位置被 <strong>SRR(Substitute Remote Request)</strong> 取代了，SRR 是一个固定的显性位，原来的 RTR 跑到 CAN ID B 的后边去了。具体可以看做是标准的 CAN 更换了一段额外的 SRR 和增加了一个 18 位的 CAN ID B 段。</p>
<p>为什么要拓展呢，因为有些时候，CAN ID 也是有一定作用的，譬如接收方一般并不是接收所有的 CAN 信息，而是过滤只感兴趣的 CAN ID 帧。有些时候 CAN ID 会被分成两端，一段是发送方的地址，一段是接收方的地址，这样就需要更长的 CAN ID，但是 CAN ID 太长的话，数据发送的效率就会变低（拓展帧帧一共 100 多位，最多只有 60 位数据），所以拓展帧作为一种选择产生了，以满足某些特殊需要。</p>
<p>注意，不是所有的 CAN 网络均支持拓展帧，只有支持 CAN2.0B 标准的 CAN 网络才支持拓展帧，仅支持 CAN2.0A 标准的 CAN 网络只能使用标准数据帧。</p>
<h2 id="heading-3">远程帧</h2>
<p>远程帧英文原意，是远程请求帧，顾名思义，发送此帧的设备请求另外一个节点发送数据。远程帧不包含数据段，但是依旧有 DLC 段，DLC 为请求的数据字节数。在远程帧后，一般会跟随着一个数据帧，由响应的节点发送。</p>
<p>远程帧的结构与标准的数据帧或者拓展的数据帧基本一致，只有一个区别就是没有数据段，在 DLC 后紧跟着的就是 CRC 段。</p>
<h2 id="heading-4">错误帧</h2>
<p>错误帧和上述的 CAN 帧不同，错误帧有两个位段：</p>
<ol>
<li>叠加的错误标志（6-12bits）段，由各个设备发送的错误叠加而成。</li>
<li>错误边界段，由 8 个隐性位组成。</li>
</ol>
<p>错误标志分为两种类型：</p>
<h4 id="heading-5">主动错误标志</h4>
<p>由 6 个显性位组成，由被检测到错误的节点（处于主动错误状态）发送。</p>
<h4 id="heading-6">被动错误标志</h4>
<p>由 6 个隐性位组成，由被检测到错误的节点（处于被动错误状态）发送。</p>
<p>什么是主动错误状态和被动错误状态呢？这个和 CAN 网络中的错误计数器有关，每个 CAN 节点都有两个计数器，一个是 <strong>发送错误计数器(TEC)</strong>，一个是 <strong>接收错误计数器(REC)</strong>，当节点的错误计数值不同时，节点会进入不同的计数状态：</p>
<ul>
<li>当 TEC 或者 REC 小于 128，节点处于主动错误状态。</li>
<li>当 TEC 或者 REC 大于 127 并且小于 255，节点进入被动错误状态。</li>
<li>当 TEC 大于 255，节点进入 Bus Off 状态，不再发送接收任何帧，不对总线有任何影响。</li>
</ul>
<p>错误帧只会在 CAN 总线正在发送的时候才能产生，也就是说主动错误会直接打断当前发送的数据，被动错误标志不会打断总线的传输。错误计数器的累加和很多种情况有关，但是规则很简单：</p>
<ul>
<li>发送错误会导致 TEC 加 8</li>
<li>接收错误会导致 REC 加 1</li>
<li>正确的发送和接受会使 TEC 和 REC 递减或者清 0</li>
</ul>
<p>CAN 控制器一般会提供一个引脚来反馈错误，通常是经过中断方式通知 MCU 该节点进入了 Bus Off 状态或者检测到错误，但是有些芯片会提供完全的错误控制，譬如最常见的 Philips SJA1000。</p>
<p>应该知道的是，错误的种类有哪些呢？
CAN 一共提供了不少于 5 种的错误检测方式，前两种工作在物理层层面，后 3 种工作在信息层。</p>
<h4 id="heading-7">位错误</h4>
<p>发送方独有错误，某个节点在总线上发送数据的时候是按位发送的，节点会自动在发送后，也像接收方一样对总线上的状态采样，一旦发现和自己的发送所需状态不同，即我发的数和总线上的不一样，（举个例子：我发的隐性位，我发完一检测，总线上却是一个显性位，错误产生）就是产生了一个位错误。</p>
<h4 id="heading-8">位填充错误</h4>
<p>在这个地方需要介绍一下 CAN 网络中的一个特有的特性，就是 <strong>位填充(Bit stuffing)</strong> 不同于一般的异步总线，CAN 总线需要连续发送很长的一串位流，这就会导致在连续发送同一状态值（0 或 1）时的时间错位累加，这种错位不能在接收方被检测到，这样很有可能发送和接收时出现错位状态，所以 CAN 定义了如果总线上有<strong>连续 5 个</strong>的 0 或者 1 时，会自动生成一个相反极性的位填充在后边，也相当于一个边界，防止连续过长相同位出现，举个例子：</p>
<blockquote>
<p>11111000011110000&hellip;</p>
</blockquote>
<p>在传输时，其实是这样的：</p>
<blockquote>
<p>11111<strong>0</strong>0000<strong>1</strong>1111<strong>0</strong>0000<strong>1</strong>&hellip;</p>
</blockquote>
<p>第一个 0 被填充后，导致后续的数据出现了 5 个连续相同状态，所以又产生了一连串位填充。</p>
<p>位填充在接收的时候会被硬件忽视，但是硬件同时会检测有无填充，如果 5 个连续相同位后还是相同位，节点会认为产生了位填充错误，但是也有可能是别的节点产生了主动错误帧，无论是哪个，都会使总线上的数据传输挂起。</p>
<p>然而，CAN 网络在 CRC 段时是没有位填充的，在这里不会产生位填充错误。</p>
<p>位填充错误也会在主动错误标志产生时产生，如果一个节点没有检测到错误，同时别的节点发出主动错误标志帧，则该节点就会检测到位填充错误，同时产生错误，实现总线上设备错误同步，保证产生错误的帧不被所有设备接收。</p>
<h4 id="crc-">CRC 错误</h4>
<p>这个不用多说了，是接收方产生的错误，CRC 校验不符，说明该帧之前接收的数据不可靠。</p>
<h4 id="heading-9">应答错误</h4>
<p>发送方独有错误，检测到应答位为隐性，也即无应答。（CAN 总线不能只有一个节点，否则会无限产生应答错误）</p>
<h4 id="heading-10">格式错误</h4>
<p>接收的数据帧没有按照标准的格式，譬如 CRC 边界位或者 ACK 边界位不是隐性，EOF 段出现了显性位。</p>
<h3 id="heading-11">错误同步</h3>
<p>以上五种错误都会使主动状态下的节点触发主动错误标志，连续的 6 个主动错误标志会直接覆盖毁掉数据的发送，这时如果其余节点没有检测到错误时也会由于主动错误标志的破坏而检测到位填充错误，这样所有的设备都会同时检测到错误而丢弃之前的数据。</p>
<p>错误帧与其说是一个帧，不如说是很多错误帧的叠加：</p>
<p><img src="/img/2017-12-12-CAN_Bus/CAN_error_frame.png" alt=""></p>
<h4 id="bus-failure-modes">*总线失败错误(Bus Failure Modes)</h4>
<p>这种错误是物理层错误，并不在上列错误之中，但是也要知道，如果 CAN 线路不符合 ISO 要求的电气标准时会产生该错误，在 ISO 11898 中规定了以下的总线失败：</p>
<ol>
<li>CAN_H 断路</li>
<li>CAN_L 断路</li>
<li>CAN_H 和电池正极短路</li>
<li>CAN_L 和地短路</li>
<li>CAN_H 和地短路</li>
<li>CAN_L 和电池正极短路</li>
<li>CAN_L 和 CAN_H 短路</li>
<li>CAN_L 和 CAN_H 同地点断路</li>
<li>节点无法连接总线</li>
</ol>
<p>在实际环境下，某些错误包容型 CAN 收发器（譬如 TJA1053）可以处理以上的所有总线失败，但是其数据速度会受到影响（125bits/s)。</p>
<h2 id="heading-12">过载帧</h2>
<p>在过去，当设备的性能不是很好的时候，CAN 总线作为一个高速总线，有些节点还偏偏爱一连串发数据帧，相邻两帧间只有 3 位的 IFS 帧间空白时间内供其余节点处理数据，有些节点的数据处理能力较差，需要延长 IFS 时间，过载帧因此而生，过载帧由两段组成：</p>
<ol>
<li>叠加的过载标志（6-7bits）段，为显性，由各个设备发送的过载标志叠加而成。</li>
<li>过载边界段，由 8 个隐性位组成。</li>
</ol>
<p>这个帧很神奇，怎么神奇呢，它格式跟主动错误帧都一模一样，甚至也有同步的作用，，但是有一点和错误帧不同：</p>
<p><strong>过载帧在帧间空白 IFS 段内第一位开始</strong></p>
<p>一个设备会在以下两种情况下发送过载帧：</p>
<ol>
<li>由于设备内部状态需要总线延迟下一帧的数据发送，在 IFS 段第一位开始产生过载标志。</li>
<li>某设备检测到 IFS 段内有显性位。</li>
</ol>
<p>可以看到第二个发送过载帧的条件使总线上所有的过载帧都会同步，没有发送过载帧的节点会因为检测到过载帧而产生过载帧。</p>
<p>过载帧不是错误帧，不会导致内部的错误计数器累加。</p>
<p><img src="/img/2017-12-12-CAN_Bus/CAN_overload_frame.png" alt=""></p>
<p>过载帧将会使下一帧的发送时间推迟，具体推迟多少，发送节点根据规定自行选择。</p>
<p>到此为止，所有的 CAN 规定的帧都已经介绍完毕了，到这里已经基本上可以说了解了 CAN 的基本内容了，但是还有些细节，这些细节不影响使用 CAN，但是了解一些也会有好处。</p>
<h2 id="heading-13">位时间分配</h2>
<p>CAN 在传输每一位的时候，在这一位的时间内，会做一系列的事情，并不是发送就完事了，我们知道，CAN 节点在发送数据的同时还会有检验位错误，在什么时候检测？在接收的时候还要有位时间的校准防止错位，如何自动校准？接收方在什么时刻采样捕获总线上的状态？这一部分的功能都在位时间内表现出来：</p>
<p>CAN 总线每一位的时间，都可以分成以下的几个部分，在不同的部分内，CAN 控制器会做不同的事情。</p>
<p><img src="/img/2017-12-12-CAN_Bus/CAN_bit_time.png" alt=""></p>
<p>我们可以看到一个位的时间其实可以被分成更小的 10 小份时间，其中第一小份是 <strong>SYNCHRONIZATION</strong> 部分，也就是同步部分，这一部分主要用于捕获从隐性位到显性位的跳变沿。</p>
<h4 id="hard-synchronization--">HARD SYNCHRONIZATION  硬同步</h4>
<p>在每个 CAN 帧传输的开头，我们知道有一位的 SOF 帧起始，从总线空闲状态的隐性，向显性位跳变一次，在这个过程中，总线上所有的设备进入了 HARD SYNCHRONIZATION 状态，每个节点捕获到跳变后，都将这个跳变的时刻定义在第一位的 SYNCHRONIZATION 内，实现 CAN 帧开始的同步。</p>
<p>我们知道 CAN 没有一根时钟同步线，所以 CAN 总线空闲的时候，是可以在任意时刻发起传输的，这个硬件同步确保了传输发起时的同步性，即所有设备在第一个隐-&gt;显跳变沿同步。</p>
<p>第二个阶段是 <strong>Propagation Segment</strong> 部分，这一部分和后续的 <strong>Phase 1 Segment(相位缓冲 1)</strong> 和 <strong>Phase 2 Segment(相位缓冲 2)</strong> 都是可以更改的，在这里的长度只是一般情况下的长度 3 3 3 平均分布。</p>
<h4 id="heading-14">位同步</h4>
<p>一般情况下，每次隐性到显性的跳变沿都在开始的 SYNC 段内被捕获，在这种情况下，并不会触发位同步，而一旦检测到隐-&gt;显跳变沿超出 SYNC 范围，譬如提前到前一帧的 Phase 2 中或者推迟到 SYNC 后的 Propagation Segment 段内，就会自动触发位同步功能，这时 CAN 会自动调整 Phase 1 Segment(相位缓冲 1) 或者 Phase 2 Segment(相位缓冲 2) 的长度，以使下一次跳变沿在 SYNC 段内捕获。</p>
<p>举个例子：
<img src="/img/2017-12-12-CAN_Bus/CAN_sync1.png" alt=""></p>
<p>如果接收方发现自己相位靠前了，隐-&gt;显跳边沿到 Prop 段了，就会自动在 Phase 1 缓冲中增加这个靠前的时长，这样当采样的时候，接收方和发送方已经做到了同步，增加的这个时长使得接收方的此位时间长了一丁点。</p>
<p><img src="/img/2017-12-12-CAN_Bus/CAN_sync2.png" alt=""></p>
<p>如果接收方前一位还未结束，在 Phase 2 缓冲区内就检测到了隐-&gt;显跳变，则接收方此时强制进入下一位的 SYNC 状态，这导致了上一位的接收时间稍微短了一点点。</p>
<p>请注意 SYNC 段只能捕获隐-&gt;显跳变，显-&gt;隐跳变由于时间一般较长，不会视作位同步的依据。</p>
<p>到此为止，文章内容就已经全部结束了，如果有什么疑问或者本文有什么错误可以直接在下方留言，感谢您的交流！</p>
<h3 id="heading-15">课后习题：</h3>
<p>哈，还有课后习题？课后习题是一种反馈，在学习中非常重要。</p>
<ol>
<li>DLC 为 0 的数据帧和远程帧有什么区别？</li>
</ol>
<blockquote>
<p>DLC 为 0 的数据帧没有数据段，虽然远程帧也没有数据段，但是远程帧的 DLC 一般都不等于 0，在远程帧中，DLC 对应的是请求的数据帧的数据段长度。当然还有 RTR 位两者的区别，在仲裁的时候，远程帧和数据帧在 CAN ID 优先级相同的条件下由于 RTR 位数据帧为 0 所以优先于远程帧。</p>
</blockquote>
  







  



</article>


      </div>
    </div>
  </main>
  
<footer class="Footer">
  <div class="u-wrapper">
    <div class="u-padding">
      Enjoy yourself!
    </div>
  </div>
</footer>


</body>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
 
</html>
